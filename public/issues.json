[{"url":"https://api.github.com/repos/alienzhou/blog/issues/49","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/49/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/49/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/49/events","html_url":"https://github.com/alienzhou/blog/issues/49","id":874384348,"node_id":"MDU6SXNzdWU4NzQzODQzNDg=","number":49,"title":"DNS 查询导致的 Nodejs 服务疑似“内存泄漏”问题","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-05-03T09:06:42Z","updated_at":"2021-05-03T09:06:42Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 1、OOM 报警：内存泄漏？\r\n\r\n某天下午，线上的服务监控发出报警：在同一个服务下，部署的众多容器中，某一个容器出现 OOM 问题。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858691-5edf4e80-ac31-11eb-94aa-752708dd5df6.png)\r\n\r\n上图是容器维度的资源使用率监控图。可以看到红色的内存使用率曲线，逐步升高将近到 100% 后又迅速降至 0%。这是因为触发 OOM 后容器自动重启。而在重启后，容器的的内存使用率仍在缓慢上升。\r\n\r\n该容器分配的资源为 1 核 1G，其容器内只运行一个 Nodejs 进程。运行的 Nodejs 进程在某段时间的监控曲线如下：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858722-6a327a00-ac31-11eb-8bc8-51e464321ed6.png)\r\n\r\n可以看到，堆内存使用率也是逐步攀升，CPU 使用率则较为稳定。其与容器维度的监控表现一致。从容器与 Nodejs 进程的曲线上来看，非常像是 Nodejs 服务内存泄漏的问题。\r\n\r\n## 2、使用堆内存快照，排查堆内存问题\r\n\r\n既然是内存问题，我很快想到要通过堆内存快照（Heap Snapshot）来排查。该服务使用了快手内部自研的 KNode 运行时来部署服务，因此可以在线上按需实时地打出堆快照，并在线查看：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858755-761e3c00-ac31-11eb-9b0e-307ea6cf0a6d.png)\r\n\r\n> Heapsnaphost 中各项的含义以及如何查看，如果不了解可以看 [Chrome Devtools 的说明文档](https://developer.chrome.com/docs/devtools/memory-problems/memory-101/)。\r\n\r\n不过可能是由于堆快照是一个切面数据，同时，打印这张快照时堆内存使用率也不是太高（大概为 20%），所以在初步看了堆快照后，问题线索不太直接。遇到这个问题，还有一个好办法，就是做两个时间点的快照 Diff。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858773-7e767700-ac31-11eb-90a0-bd52b454c9ab.png)\r\n\r\nv8 会给每个堆内存对象分配一个 ID。因此可以在 Heap 使用率较低和较高两个时间点，分别打印对应的堆快照，通过这个关联 ID，就可以对比出这段时间内新增和回收释放的堆内存对象。而 Chrome Devtools 本身也支持堆快照的 comparison 展示。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858799-8c2bfc80-ac31-11eb-9084-53ddc0988df7.png)\r\n\r\n上图展示了在堆内存从 20% 涨到 50% 后新申请而没有被 GC 的对象（Object Allocated）。结合之前的堆快照（切面数据）和上面的 comparison 数据（Diff 数据），可以发现，红框中的这两类对象非常突出。也就是 `GetAddrInfoReqWrap` 与 `Socket`。\r\n\r\n`Socket` 和网络连接相关，属于比较广的范围。因为我将目光放在了 `GetAdrrInfoReqWrap` 上。基于之前对 Nodejs 的了解，我知道这是和 DNS 查询相关的 JS 层 wrapper 对象。当然，如果大家不知道这个对象，也可以通过[查阅 Nodejs 源码](https://github.com/nodejs/node/blob/v14.16.1/lib/dns.js#L141)来了解到它的功能。展开堆快照中的对象，看下具体信息：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858812-94843780-ac31-11eb-839e-714ecabe5c9b.png)\r\n\r\n从快照中对象的具体信息看，其 hostname 比较分散，所以感觉是和容器内整个 DNS 查询有关。\r\n\r\n## 3、从其他 Nodejs 监控项，来看这个问题\r\n\r\n如果是 DNS 查询的问题，肯定也会间接影响到 HTTP 相关的监控项。而情况也确实如此。从 Nodejs 进程发起的 HTTP 请求的监控来看，有问题的容器，每分钟能完成的请求数只有 3 次（如下图）：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858829-9bab4580-ac31-11eb-9b84-2f103e1b69b7.png)\r\n\r\n而同一个服务下的正常容器内，每个 Nodejs 进程每分钟可以正常发送超过 150 个 HTTP 请求（如下图）：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858851-a2d25380-ac31-11eb-8ec1-fbd74de339a4.png)\r\n\r\n同时，异常容器中的 Nodejs 发送完成一个 HTTP 请求的平均耗时超过了 800 秒（>13分钟）。而正常情况下内网服务之间的 HTTP 请求耗时一般都在几十毫秒，慢的也不太会超过几百毫秒。\r\n\r\n此外，如果查看 Nodejs 的 Active Handle 的数量，也是处于一个持续上涨的状态。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858882-b4b3f680-ac31-11eb-8a6a-f1bbfa8e204f.png)\r\n\r\n这里的 Active Handle 是指 [libuv 中的 Handle](http://docs.libuv.org/en/v1.x/design.html#handles-and-requests)，与其类似的还有一个叫 Request 的概念。它是 libuv 中的抽象概念，用来指代 libuv 中某项操作的对象，例如定时器、设备 IO 等。Nodejs 进程中的 Active Handle 数量持续上涨往往是有问题的，它说明 Nodejs 要处理的东西“积压”地越来越多。\r\n\r\n因此，基本怀疑就是 DNS 查询的问题导致请求积压，从而导致了该故障。\r\n\r\n## 4、故障确定与修复\r\n\r\n通过上面的分析，基本可以确定和 DNS 查询脱不了干系。因为在服务部署的众多容器中，只有这一个有 OOM 问题，所以我分别登进一个健康容器和这个问题容器，执行以下 JS 代码来确认 DNS 查询情况（本文隐去了实际域名）：\r\n\r\n```js\r\nconsole.time('dns');\r\nrequire('dns').lookup('xxx.xxxx.xxx', () => {\r\n    console.timeEnd('dns');\r\n});\r\n```\r\n\r\n这里需要提一下。Nodejs 封装了两类 DNS 查询的方法，一类就是上面用到的 `dns.lookup()`；另一个就是 `dns.resolve()` 和 `dns.resolve*()`。这里之所以在测试代码中使用 `dns.lookup()` 方法，是因为使用 Nodejs 中内置 http 模块的 `http.request()` 请求时，默认使用的就是该方法，而不是 `dns.resolve()`。\r\n\r\n项目使用了 axios，而其在 [Nodejs 环境](https://github.com/axios/axios/blob/v0.21.1/lib/defaults.js#L18-L24)下[使用的是 `http.request()`](https://github.com/axios/axios/blob/v0.21.1/lib/adapters/http.js#L7) 方法来发起 HTTP 请求。`http.request()` 会调用 net 模块中的 [`createConnection` 方法](https://github.com/nodejs/node/blob/v14.16.1/lib/_http_client.js#L321)来建立连接。net 模块创建连接时，[默认的 lookup 方法](https://github.com/nodejs/node/blob/v14.16.1/lib/net.js#L1039)就是 `dns.lookup()`：\r\n\r\n```js\r\nfunction lookupAndConnect(self, options) {\r\n  // ...\r\n  const lookup = options.lookup || dns.lookup;\r\n  defaultTriggerAsyncIdScope(self[async_id_symbol], function() {\r\n    lookup(host, dnsopts, function emitLookup(err, ip, addressType) {\r\n      self.emit('lookup', err, ip, addressType, host);\r\n      // ...\r\n    });\r\n  });\r\n}\r\n```\r\n\r\n当然，lookup 方法是[可以设置](https://nodejs.org/dist/latest-v14.x/docs/api/http.html#http_http_request_url_options_callback)的，例如可以传入 `dns.resolve()` 或者自定义的方法。下图就是 Nodejs 官方文档中的说明截图：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858928-c5646c80-ac31-11eb-932f-39f6f4964728.png)\r\n\r\n回到该故障。测试代码运行后，正常容器（下图左）的 DNS 查询耗时为 33 毫秒；故障容器的耗时为 5000 毫秒，差异极大。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858956-ce553e00-ac31-11eb-83fb-e41250143b91.png)\r\n\r\n那么是什么导致的耗时差异呢？\r\n\r\n`dns.lookup()` 方法会使用系统的 [`/etc/resolv.conf` 配置文件](https://nodejs.org/dist/latest-v14.x/docs/api/dns.html#dns_dns_lookup_hostname_options_callback)。该文件中会设置 nameserver 的地址、超时时间、重试次数、rotate 策略等。通过对比正常容器和故障容器，发现了配置差异：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858966-d44b1f00-ac31-11eb-8b6e-7ca12cb69769.png)\r\n\r\n故障容器中（上图右）有个 nameserver 配置为了 `10.62.38.17`（正常容器是 `10.6.6.6`）。而 `10.62.38.17` 这个 nameserver 之前出现了问题，已经被替换掉了。但是在基础平台批量刷配置的操作中，故障容器所属的宿主机可能遗漏或者失败了。定位到具体原因后，联系了司内的容器化部署/运营平台的同学，修复该配置后后故障就解决了。\r\n\r\n## 5、总结\r\n\r\n这个问题曲折的点在于：其监控表象初看像是内存泄漏，而一般来说内存泄漏都是代码 bug 导致的。但这个故障其实并非如此，实际是宿主机 DNS nameserver 的配置问题。\r\n\r\n原因大致就是，由于 Nodejs 中 DNS 查询耗时过长导致了请求堆积，上游服务与 Nodejs 建立的连接也不会释放。所以在整个请求的生命周期中「持有」的对象未被释放，堆内存中对象不断增多，从而看起来像是「内存泄漏」。\r\n\r\n---\r\n\r\n## 加餐：聊聊 Nodejs 中 DNS 查询与请求堆积\r\n\r\n上面还是只一个粗略的分析和定位。在这一节会尝试能更深入一些，将故障现象和 Nodejs 实现细节联系起来。\r\n\r\n关于 Nodejs 中 DNS 查询故障导致的服务不响应的问题，之前已经有文章阐述了类似的问题：\r\n\r\n> - [node中请求超时的一些坑](https://acemood.github.io/2020/05/02/node%E4%B8%AD%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/)\r\n> - [NodeJS 中 DNS 查询的坑 & DNS cache 分析](https://zhuanlan.zhihu.com/p/138584520)\r\n\r\n下面再尝试简单解释一下。\r\n\r\n使用 http 模块的 `http.request()` 方法默认会使用 `dns.lookup()` 作为 DNS 查询的方法（这个在上中文也已经提到了）。而 `dns.lookup()` 通过 binding 会调用到 [`GetAddrInfo()` 函数](https://github.com/nodejs/node/blob/v14.16.1/src/cares_wrap.cc#L1987-L1991)：\r\n\r\n```c++\r\nvoid GetAddrInfo(const FunctionCallbackInfo<Value>& args) {\r\n  // ...\r\n  int err = req_wrap->Dispatch(uv_getaddrinfo,\r\n                               AfterGetAddrInfo,\r\n                               *hostname,\r\n                               nullptr,\r\n                               &hints);\r\n  if (err == 0)\r\n    // Release ownership of the pointer allowing the ownership to be transferred\r\n    USE(req_wrap.release());\r\n\r\n  args.GetReturnValue().Set(err);\r\n}\r\n```\r\n\r\n其中最重要的调用的就是 `uv_getaddrinfo()`，它会将 [`uv__getaddrinfo_work` 提交到线程池的工作任务中](https://github.com/nodejs/node/blob/v14.16.1/deps/uv/src/unix/getaddrinfo.c#L209-L213)：\r\n\r\n```c++\r\nuv__work_submit(loop,\r\n                &req->work_req,\r\n                UV__WORK_SLOW_IO,\r\n                uv__getaddrinfo_work,\r\n                uv__getaddrinfo_done);\r\n```\r\n\r\n而 `uv__getaddrinfo_work()` 中就会使用 [`getaddrinfo` 函数](https://github.com/nodejs/node/blob/v14.16.1/deps/uv/src/unix/getaddrinfo.c#L101-L108)来做 DNS 查询：\r\n\r\n```c++\r\nstatic void uv__getaddrinfo_work(struct uv__work* w) {\r\n  uv_getaddrinfo_t* req;\r\n  int err;\r\n\r\n  req = container_of(w, uv_getaddrinfo_t, work_req);\r\n  err = getaddrinfo(req->hostname, req->service, req->hints, &req->addrinfo);\r\n  req->retcode = uv__getaddrinfo_translate_error(err);\r\n}\r\n```\r\n\r\n那么为什么会涉及到线程池概念呢？因为调用 `getaddrinfo()` 函数是一个同步调用，所以 [libuv 会通过线程池](https://docs.libuv.org/en/latest/threadpool.html)来实现 Nodejs 所需的异步 IO。线程池默认大小为 4，可以通过 [`UV_THREADPOOL_SIZE` 这个环境变量](https://github.com/nodejs/node/blob/v14.16.1/deps/uv/src/threadpool.c#L194)来配置，在 Nodejs v14 中最大是 1024。\r\n\r\n回到故障场景：\r\n\r\n从正常进程的监控数据看到，每分钟 Nodejs 进程发起的请求大致为 150 个，也就是 1 秒 2.5 个。而在故障容器中，请求在 DNS 查询阶段就要耗时 5s。即使不考虑其他耗时也要 5s 才能发完一个请求。4 个线程平均下来，也就是 1 秒最多能处理 0.8 个请求。显然，2.5 要远大于 0.8，处理能力和请求数量严重不匹配。所以服务运行时间越长，积压的请求数、连接数就越多。\r\n\r\n到这里，还有几个问题可以再说明下：\r\n\r\n### 关于超时\r\n\r\n对于 HTTP 请求，我们一般会设置超时时间。但是 Nodejs 发起的请求可能不会触发到超时，由此使得上游服务到 Nodejs 的连接不会及时断开。这是在使用 axios 时可能出现的问题。\r\n\r\n因为 axios 会基于 [`requset.setTimeout`](https://github.com/axios/axios/blob/v0.21.1/lib/adapters/http.js#L278) 来设置超时。之前的[文章](https://acemood.github.io/2020/05/02/node%E4%B8%AD%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/)也分析过，它是不包含 DNS 查询时间的。从 [Nodejs 官网文档](https://nodejs.org/dist/latest-v14.x/docs/api/http.html#http_request_settimeout_timeout_callback)中也能大致看出这个意思。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116858995-ddd48700-ac31-11eb-9e76-f5dae1de9eac.png)\r\n\r\n### 关于 DNS cache\r\n\r\nNodejs 本身不做 DNS 查询结果的缓存（一些讨论也认为 cache 放在 userland 可能会合理些）。所以如果 `getaddrinfo()` 本身也没有 DNS cache（开启 nscd 似乎可以），Nodejs 就会在每次使用域名做 http 请求时，都会去请求 DNS nameserver。上文故障中的情况便是如此。\r\n\r\n当然，你也可以通过使用类似像 [dnscache](https://www.npmjs.com/package/dnscache) 这类包来做 monkey patch，在 JS 层为 DNS 查询添加缓存；或者通过在 axios 中添加拦截器，实现缓存。不过使用缓存一定要注意处理缓存过期的问题，可以使用 DNS server 返回的 TTL。不过有时这个值也不太可靠，可能会需要基于业务场景设置一个尽量小的值。总之使用缓存一定要谨慎！\r\n\r\n### 关于 `dns.resolve()`/`dns.resolve*()`\r\n\r\n从文章之前的章节可以知道，`dns.resolve()`/`dns.resolve*()` 与 `dns.lookup()` 的实现并不相同。它们是基于 [c-ares](https://github.com/c-ares/c-ares) 实现的。\r\n\r\n> This is c-ares, an asynchronous resolver library. It is intended for applications which need to perform DNS queries without blocking, or need to perform multiple DNS queries in parallel.\r\n\r\n`http.request()` 是支持通过在 options 中传入 lookup 配置来覆盖默认的 `dns.lookup` 的。但是需要注意 `dns.resolve()` 和 `dns.lookup` 存在的[可能区别](https://nodejs.org/dist/latest-v14.x/docs/api/dns.html#dns_dns_resolve_dns_resolve_and_dns_reverse)。\r\n\r\n此外，它们只是不用再使用线程池，如果遇到像文中的故障，DNS 查询的耗时一样会很高，同样会有类似问题。\r\n\r\n完。\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/48","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/48/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/48/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/48/events","html_url":"https://github.com/alienzhou/blog/issues/48","id":873974537,"node_id":"MDU6SXNzdWU4NzM5NzQ1Mzc=","number":48,"title":"npm script 执行”丢失“ root 权限的问题","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845014,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE0","url":"https://api.github.com/repos/alienzhou/blog/labels/JavaScript","name":"JavaScript","color":"d73a4a","default":false,"description":""},{"id":2966265382,"node_id":"MDU6TGFiZWwyOTY2MjY1Mzgy","url":"https://api.github.com/repos/alienzhou/blog/labels/Troubleshooting","name":"Troubleshooting","color":"bfdadc","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-05-02T15:45:44Z","updated_at":"2021-05-02T15:45:44Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"![image](https://user-images.githubusercontent.com/9822789/116818901-3f4c1580-aba0-11eb-9760-48660692f9c4.png)\r\n\r\n## 1、问题背景\r\n\r\n近期，在线上运行服务时遇到了一个诡异的 Linux 权限问题：root 用户在操作本该有权限的资源时，却报了权限错误。\r\n\r\n报错如下：\r\n\r\n```text\r\nError: EACCES: permission denied, mkdir '/root/.pm2/logs'\r\n    at Object.mkdirSync (fs.js:921:3)\r\n    at mkdirpNativeSync (/home/web_server/project/node_modules/pm2/node_modules/mkdirp/lib/mkdirp-native.js:29:10)\r\n    at Function.mkdirpSync [as sync] (/home/web_server/project/node_modules/pm2/node_modules/mkdirp/index.js:21:7)\r\n    at module.exports.Client.initFileStructure (/home/web_server/project/node_modules/pm2/lib/Client.js:133:25)\r\n    at new module.exports (/home/web_server/project/node_modules/pm2/lib/Client.js:38:8)\r\n    at new API (/home/web_server/project/node_modules/pm2/lib/API.js:108:19)\r\n    at Object.<anonymous> (/home/web_server/、project/node_modules/pm2/lib/binaries/CLI.js:22:11)\r\n    at Module._compile (internal/modules/cjs/loader.js:1137:30)\r\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1157:10)\r\n    at Module.load (internal/modules/cjs/loader.js:985:32)\r\n```\r\n\r\n这个错误非常直观，就是用户想要创建 `/root/.pm2/logs` 文件夹，但是没有权限。该服务使用 pm2 做多进程管理。pm2 默认会将其日志信息、进程信息等写入到 `$HOME/.pm2` 下。因为是 root 后用户所以写到了 `/root/.pm2` 里。\r\n\r\n但这个问题的奇怪之处在于，服务是通过 root 用户启动的，对 `/root` 目录是具有写入权限的。但这里却报了名优权限的错我。\r\n\r\n那么是什么导致 root 用户操作 `/root` 目录的权限“丢失”了呢？\r\n\r\n## 2、初步排查\r\n\r\n项目是容器化部署，使用 npm script 启动，代码文件位于 `/home/web_server/project` 下。执行 `npm start` 即可启动。\r\n\r\n这是我们使用的一套标准的构建与部署「模版」，已经在上百个服务上应用，且一直都正常。知道近期的一次上线出现了上面这个问题。\r\n\r\n这次突然出现的这个问题让我充满了疑惑 —— 基于对 Linux 系统用户、用户组权限控制的理解，不可能出现这个错误。难道是我理解有误？\r\n\r\n在疑惑的同时，我尝试不使用 npm script，直接通过 pm2 命令行 `pm2 start ecosystem.config.js` 启动，发现服务正常启动了！莫非是 npm 导致的？\r\n\r\n而在这次上线的时候，确实更新了基础镜像，升级了 npm cli。之前是 v6.x，这次更新到了 v7.x。而当我将 npm 版本回退到 v6.x 后，问题小时。看来是 v7.x 的改动导致了这个问题。\r\n\r\n## 3、问题定位\r\n\r\n先说结论：npm v6.x 使用 npm script 执行命令时默认会使用 unsafe 模式，将子执行命令的子进程设置为 root 用户/用户组，该行为可以通过 `unafe-pem` 配置来控制。而在 v7.x 中，如果通过 root 用户执行 npm script，则会基于当前目录（cwd）所属用户来设置。\r\n\r\n下面通过代码来一起看下。\r\n\r\n### 3.1、v7.x 中 npm script 的实现\r\n\r\n> 以下代码来自 [npm/cli v7.11.1](https://github.com/npm/cli/tree/v7.11.1)\r\n\r\nnpm script 的执行逻辑可以从 [`lib/exec.js`](https://github.com/npm/cli/blob/v7.11.1/lib/exec.js#L88) 中查看：\r\n\r\n```js\r\nclass Exec extends BaseCommand {\r\n  // ...\r\n  async _exec (_args, { locationMsg, path, runPath }) {\r\n    // ...\r\n    if (call && _args.length)\r\n      throw this.usage\r\n\r\n    return libexec({\r\n      ...flatOptions,\r\n      args,\r\n      // ...\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n省略无关代码，可以看到执行 npm script 时会调用 `libexec` 方法，[`libexec` 方法](https://github.com/npm/cli/blob/v7.11.1/node_modules/libnpmexec/lib/index.js#L50)内部会调用 [`runScript` 方法](https://github.com/npm/cli/blob/v7.11.1/node_modules/libnpmexec/lib/index.js#L50)来执行命令。\r\n\r\n> 因为调用链比较长，我把中间代码省略了，只贴出关键的代码，感兴趣的朋友可以点击文中链接跳转查看。\r\n\r\n通过[一系列](https://github.com/npm/cli/blob/v7.11.1/node_modules/%40npmcli/run-script/lib/run-script.js#L9)曲折的调用，代码最后会调用到 [`promiseSpawn` 方法](https://github.com/npm/cli/blob/v7.11.1/node_modules/%40npmcli/run-script/lib/run-script-pkg.js#L54)。这个方法最终会使用 child_process 内置模块里提的 `spawn` 方法来启动子进程执行命令，其[相关代码](https://github.com/npm/cli/blob/v7.11.1/node_modules/%40npmcli/promise-spawn/index.js#L13-L20)如下：\r\n\r\n```js\r\nconst promiseSpawn = (cmd, args, opts, extra = {}) => {\r\n  const cwd = opts.cwd || process.cwd()\r\n  const isRoot = process.getuid && process.getuid() === 0\r\n  const { uid, gid } = isRoot ? inferOwner.sync(cwd) : {}\r\n  return promiseSpawnUid(cmd, args, {\r\n    ...opts,\r\n    cwd,\r\n    uid,\r\n    gid\r\n  }, extra)\r\n}\r\n```\r\n\r\n上面的实现中，有一行非常重要：\r\n\r\n```js\r\nconst { uid, gid } = isRoot ? inferOwner.sync(cwd) : {}\r\n```\r\n\r\n可以看到，如果当前进程的用户是 root，则会使用 `inferOwner` 方法来设置启动的子进程的 uid 和 gid（也就是用户 id 和用户组 id）。\r\n\r\n那么 `inferOwner` 是做什么的呢？它其实就是[用来获取某个文件所属的用户与用户组](https://github.com/npm/cli/blob/v7.11.1/node_modules/%40npmcli/promise-spawn/index.js#L13-L20)的：\r\n\r\n```js\r\nconst inferOwnerSync = path => {\r\n  path = resolve(path)\r\n  if (cache.has(path))\r\n    return cache.get(path)\r\n\r\n  const parent = dirname(path)\r\n\r\n  let threw = true\r\n  try {\r\n    const st = fs.lstatSync(path)\r\n    threw = false\r\n    const { uid, gid } = st\r\n    cache.set(path, { uid, gid })\r\n    return { uid, gid }\r\n  } finally {\r\n    if (threw && parent !== path) {\r\n      const owner = inferOwnerSync(parent)\r\n      cache.set(path, owner)\r\n      return owner // eslint-disable-line no-unsafe-finally\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n其中最重要的代码是这几行：\r\n\r\n```js\r\nconst st = fs.lstatSync(path)\r\n// ...\r\nconst { uid, gid } = st\r\n```\r\n\r\n[`fs.lstatSync` 方法](https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_fs_lstatsync_path_options) 会使用 [`fstat`](https://man7.org/linux/man-pages/man2/lstat.2.html) 这个系统调用来获取文件的 uid 和 gid。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116818830-e67c7d00-ab9f-11eb-902b-143e08bffe04.png)\r\n\r\n`promiseSpawn` 中会将 cwd 传入来获取 uid 和 gid。而在我们线上服务的容器里，我们是在 `/home/web_server/project` 下执行 `npm start`，该目录所属用户是 `web_server`，用户组是 `web_server`。所以 npm 在启动子进程时“切换”了用户。\r\n\r\n所以实际情况是，`pm2 start ecosystemt.config.js` 相当于是被 web_server 用户启动的，但是环境变量 `$HOME` 仍然是 `/root`。所以在 `/root` 中创建文件夹，自然就没有权限。\r\n\r\n### 3.2、v6.x 中 npm script 实现方式的区别\r\n\r\n> 以下代码来自 [npm/cli v6.14.8](https://github.com/npm/cli/tree/v6.14.8)\r\n\r\nv7.x 为了权限安全，做了上述操作，那么 v6.x 如何呢？\r\n\r\nv6.x 的 npm script 入口是 [`lib/run-script.js` 文件](https://github.com/npm/cli/blob/v6.14.8/lib/run-script.js#L173)：\r\n\r\n```js\r\nfunction run (pkg, wd, cmd, args, cb) {\r\n  // ...\r\n  chain(cmds.map(function (c) {\r\n    // pass cli arguments after -- to script.\r\n    if (pkg.scripts[c] && c === cmd) {\r\n      pkg.scripts[c] = pkg.scripts[c] + joinArgs(args)\r\n    }\r\n\r\n    // when running scripts explicitly, assume that they're trusted.\r\n    return [lifecycle, pkg, c, wd, { unsafePerm: true }]\r\n  }), cb)\r\n}\r\n```\r\n\r\n而其实际执行则需要从 `lifecycle` 方法中来找。上面这段代码的最后一行还有一个非常重要的参数 `{ unsafePerm: true }`，之后会用到。\r\n\r\n[lifecycle](https://github.com/npm/cli/blob/v6.14.8/lib/utils/lifecycle.js#L13) 本身代码并不复杂，主要就是参数调整，然后调用实际函数。和 uid、gid 实际的设置代码是在 [`npm-lifecycle/index.js` 中的 `runCmd`](https://github.com/npm/cli/blob/v6.14.8/node_modules/npm-lifecycle/index.js#L264-L276) 里：\r\n\r\n```js\r\nfunction runCmd (note, cmd, pkg, env, stage, wd, opts, cb) {\r\n  // ...\r\n  var unsafe = opts.unsafePerm\r\n  var user = unsafe ? null : opts.user\r\n  var group = unsafe ? null : opts.group\r\n  \r\n  // ...\r\n  if (unsafe) {\r\n    runCmd_(cmd, pkg, env, wd, opts, stage, unsafe, 0, 0, cb)\r\n  } else {\r\n    uidNumber(user, group, function (er, uid, gid) {\r\n      if (er) {\r\n        er.code = 'EUIDLOOKUP'\r\n        opts.log.resume()\r\n        process.nextTick(dequeue)\r\n        return cb(er)\r\n      }\r\n      runCmd_(cmd, pkg, env, wd, opts, stage, unsafe, uid, gid, cb)\r\n    })\r\n  }\r\n}\r\n\r\n// ...\r\nfunction runCmd_ (cmd, pkg, env, wd, opts, stage, unsafe, uid, gid, cb_) {\r\n  // ...\r\n  var proc = spawn(sh, args, conf, opts.log)\r\n  // ...\r\n}\r\n```\r\n\r\n`runCmd` 里会通过传入的 `opt.unsafePem` 参数（就是上面设置的那个 `{ unsafePerm: true }`）来判断是否是 `unsafe` 的。如果是 `unsafe`，则会在调用 `runCmd_` 时将 uid、gid 设置为 0。0 就代表 root 用户和 root 用户组。\r\n\r\n而最终在 `runCmd_` 中的 [`spawn`](https://github.com/npm/cli/blob/v6.14.8/node_modules/npm-lifecycle/lib/spawn.js#L36) 就是 `child_process` 中的 `spawn` 方法：\r\n\r\n```js\r\nconst _spawn = require('child_process').spawn\r\n// ...\r\nfunction spawn (cmd, args, options, log) {\r\n  // ...\r\n  const raw = _spawn(cmd, args, options)\r\n  // ...\r\n}\r\n```\r\n\r\n---\r\n\r\n到这里我们就定位到了该问题：\r\n\r\n- 在 v6.x 中，只要没有设置 `unsafe-pem` 这个 npm config，npm script 就会在启动子进程时默认设置为 root。\r\n- 而在 v7.x 中，如果运行时是 root 用户，则会根据 cwd 所属的用户/用户组，来设置启动子进程的 uid 和 gid。\r\n\r\n目前从代码实现来看，似乎没有特别好的处理方式，比较简答的两种就是：\r\n\r\n- 如果用 v7.x，在我们这个场景下，可以把 `/home/web_server/project` 所属用户/用户组改为 root。但权限的改动可能会引发其他问题。\r\n- 先暂时回退到 v6.x，使环境和保持一致。\r\n\r\n### 3.3、npm cli 的变更日志\r\n\r\n其实，这个变更在 npm [v7.0.0-beta.0 发布时的 CHANGELOG](https://github.com/npm/cli/blob/v7.11.1/CHANGELOG.md#all-lifecycle-scripts) 里是有提到的。不过只有寥寥一行：\r\n\r\n> The user, group, uid, gid, and unsafe-perms configurations are no longer relevant. When npm is run as root, scripts are always run with the effective uid and gid of the working directory owner.\r\n\r\n大致说的就是咱们上面从代码分析的结论：如果是 root 运行 npm，则在脚本执行时切换到当前工作目录的 owner。\r\n\r\n然后如果你跟着代码看下来，也会发现 v6.x 中的 `unsafe-pem` 配置，在 v7.0.0 开始就被废弃了。不过 npm cli 文档更新的较慢，直到 v7.0.0 正式版发布后的一个月后，才在 [v7.0.15 的 Release](https://github.com/npm/cli/blob/v7.11.1/CHANGELOG.md#documentation-16) 里把 `unsafe-pem` 从文档中移除。\r\n\r\n### 3.4、其他可能出现的问题\r\n\r\n这个功能实现的变更，除了会导致一些文件操作时的权限问题，还会有一些其他场景的权限错误。例如在如果你用 npm script 启动一个 nodejs server，要绑定 443 端口，这个时候可能就会报错。因为会需要 root 权限来执行这个端口绑定。在 [issue 里就有人提到了这个情况](https://github.com/npm/cli/issues/3110)。\r\n\r\n---\r\n\r\n## 4、加餐：child_process#spawn 是如何设置 user 和 group 的？\r\n\r\n通过上面的分析，问题已经被解决了。沿着这个问题，可以具体看了下 Nodejs 中，child_process 模块的 `spawn` 方法是如何设置 user 和 group 的。\r\n\r\n> 以下代码基于 [Nodejs v14.16.1](https://github.com/nodejs/node/tree/v14.16.1)。只关注 unix 实现。\r\n\r\nNodejs 中，我们在上层引入的模块，是直接放在 `lib` 下面的，而其一般会在调用 `lib/internal` 下的对应模块，这部分会直接使用 internalBinding 来调用 C++ 对象和方法。child_process 也不例外，你会在 [`lib/internal/child_process.js`](https://github.com/nodejs/node/blob/v14.16.1/lib/internal/child_process.js#L378) 中看到如下代码：\r\n\r\n```js\r\nChildProcess.prototype.spawn = function(options) {\r\n  // ...\r\n  const err = this._handle.spawn(options);\r\n  // ...\r\n```\r\n\r\n因为比较简答，所以这里省去了 `lib/child_process.js` 中的方法。只要知道，我们在 JavaScript 层使用 `spawn` 方法时，最后会调用到 ChildProcess 实例的 `spawn` 方法即可。可以看到最后是调用了 `this._handle.spawn`。那么 `this._handle` 是什么呢？\r\n\r\n它其实就是[通过 binding 创建的 Process 对象](https://github.com/nodejs/node/blob/v14.16.1/lib/internal/child_process.js#L250)：\r\n\r\n```js\r\nconst { Process } = internalBinding('process_wrap');\r\n\r\n// ...\r\nfunction ChildProcess() {\r\n  EventEmitter.call(this);\r\n\r\n  // ...\r\n  this._handle = new Process();\r\n  // ...\r\n}\r\n```\r\n\r\n这个 binding 的设置在 [`src/process_wrap.cc`](https://github.com/nodejs/node/blob/v14.16.1/src/process_wrap.cc#L157-L174) 中，\r\n\r\n```c++\r\n  static void Spawn(const FunctionCallbackInfo<Value>& args) {\r\n    // ...\r\n\r\n    // options.uid\r\n    Local<Value> uid_v =\r\n        js_options->Get(context, env->uid_string()).ToLocalChecked();\r\n    if (!uid_v->IsUndefined() && !uid_v->IsNull()) {\r\n      CHECK(uid_v->IsInt32());\r\n      const int32_t uid = uid_v.As<Int32>()->Value();\r\n      options.flags |= UV_PROCESS_SETUID;\r\n      options.uid = static_cast<uv_uid_t>(uid);\r\n    }\r\n\r\n    // options.gid\r\n    Local<Value> gid_v =\r\n        js_options->Get(context, env->gid_string()).ToLocalChecked();\r\n    if (!gid_v->IsUndefined() && !gid_v->IsNull()) {\r\n      CHECK(gid_v->IsInt32());\r\n      const int32_t gid = gid_v.As<Int32>()->Value();\r\n      options.flags |= UV_PROCESS_SETGID;\r\n      options.gid = static_cast<uv_gid_t>(gid);\r\n    }\r\n    \r\n    int err = uv_spawn(env->event_loop(), &wrap->process_, &options);\r\n    wrap->MarkAsInitialized();\r\n    \r\n    // ...\r\n}\r\n```\r\n\r\n可以看到，它把从 JavaScript 层设置的 uid 和 gid 设置到 options 上，然后调用了 [`uv_spawn`](https://docs.libuv.org/en/latest/process.html?highlight=uv_spawn#c.uv_spawn) 函数创建子进程。在 `uv_spawn` 中对于创建的子进程会通过 [`uv__process_child_init` 来做初始化设置](https://github.com/nodejs/node/blob/v14.16.1/deps/uv/src/unix/process.c#L408)：\r\n\r\n```c++\r\nint uv_spawn(uv_loop_t* loop,\r\n             uv_process_t* process,\r\n             const uv_process_options_t* options) {\r\n\r\n    // ...\r\n    if (pid == 0) {\r\n        uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);\r\n        abort();\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n最后则是在 [`uv__process_child_init`](https://github.com/nodejs/node/blob/v14.16.1/deps/uv/src/unix/process.c#L346-L365) 里通过 [`setuid`](https://man7.org/linux/man-pages/man2/setuid.2.html) 和 [`setgid`](https://man7.org/linux/man-pages/man2/setgid.2.html) 这两个系统调用来实现的：\r\n\r\n```c++\r\nstatic void uv__process_child_init(const uv_process_options_t* options,\r\n                                   int stdio_count,\r\n                                   int (*pipes)[2],\r\n                                   int error_fd) {\r\n    // ...\r\n    if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\r\n        uv__write_int(error_fd, UV__ERR(errno));\r\n        _exit(127);\r\n    }\r\n\r\n    if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\r\n        uv__write_int(error_fd, UV__ERR(errno));\r\n        _exit(127);\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n在 Nodejs 官方文档中也有介绍。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116818837-fac07a00-ab9f-11eb-8abf-81c61edf69d3.png)\r\n\r\n我们通过阅读代码也印证了这一点。\r\n\r\n完。\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/47","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/47/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/47/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/47/events","html_url":"https://github.com/alienzhou/blog/issues/47","id":868421126,"node_id":"MDU6SXNzdWU4Njg0MjExMjY=","number":47,"title":"记一次 Node gRPC 静态生成文件引发的问题","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":2045616625,"node_id":"MDU6TGFiZWwyMDQ1NjE2NjI1","url":"https://api.github.com/repos/alienzhou/blog/labels/Node.js","name":"Node.js","color":"c3ea81","default":false,"description":""},{"id":1159855196,"node_id":"MDU6TGFiZWwxMTU5ODU1MTk2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%9C%8D%E5%8A%A1%E7%AB%AF","name":"服务端","color":"0bbaae","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-04-27T03:34:51Z","updated_at":"2021-04-27T07:05:08Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"![image](https://user-images.githubusercontent.com/9822789/116182463-e2d79900-a74e-11eb-892f-09e7c4687069.png)\r\n\r\n本文记录了使用 Node gRPC（static codegen 方式）时，遇到的一个“奇怪”的坑。虽然问题本身并不常见，但顺着问题排查发现其中涉及到了一些有意思的点。去沿着问题追根究底、增长经验是一种不错的学习方式。所以我把这次排查的过程以及涉及到的点记录了下来。\r\n\r\n> 为了让大家在阅读时有更好的体验，我准备了一个 [demo](https://github.com/alienzhou/grpc-static-pollute-demo) 来还原该问题，感兴趣的朋友可以 clone 下来，配合文章一起“食用”。\r\n\r\n## 1、场景还原\r\n\r\n如果在你了解过或在 NodeJS 中使用过 gRPC，那么一定会知道它有两种使用模式 ——「动态代码生成」（dynamic codegen）和「静态代码生成」（static codegen）。\r\n\r\n> 这里简单解释下（对 gRPC 有了解的小伙伴可以直接跳过这段）。RPC 框架一般都会选择一种 IDL，而 gRPC 默认使用的就是 [protocol bufffers](https://developers.google.com/protocol-buffers)，我们一般会叫该文件 PB 或 proto 文件。根据 PB 文件可以自动生成序列化/反序列化代码（_xxx_pb.js_），用于 gRPC 时还会生成适配 gRPC 的代码（_xxx_grpc_pb.js_`）。如果在 Nodejs 进程启动后，再 load PB 文件生成对应方法，叫做「动态代码生成」；而先用工具生成出对应的 js 文件，运行时直接 require 生成的 js 则叫作「静态代码生成」。可以参见 gRPC 官方库中提供的[示例](https://github.com/grpc/grpc/tree/master/examples/node)。\r\n\r\n我们的项目使用了公司内部的解密组件包（也是我们维护的），叫 keycenter。解密组件中需要用到 gRPC 请求，并且它使用了「静态代码生成」这种模式。\r\n\r\n之前项目一直都正常运行。直到有一天引入了 redis 组件来实现缓存功能。在满心欢喜地加完代码运行后，控制台报出了如下错误信息：\r\n\r\n```bash\r\nError: 13 INTERNAL: Request message serialization failure: Expected argument of type keycenter.SecretData\r\n    at Object.callErrorFromStatus (/Users/xxxx/server/node_modules/@infra-node/grpc-js/build/src/call.js:31:26)\r\n    at Object.onReceiveStatus (/Users/xxxx/server/node_modules/@infra-node/grpc-js/build/src/client.js:176:52)\r\n    at Object.onReceiveStatus (/Users/xxxx/server/node_modules/@infra-node/grpc-js/build/src/client-interceptors.js:342:141)\r\n    at Object.onReceiveStatus (/Users/xxxx/server/node_modules/@infra-node/grpc-js/build/src/client-interceptors.js:305:181)\r\n    at /Users/zhouhongxuan/programming/xxxx/server/node_modules/@infra-node/grpc-js/build/src/call-stream.js:124:78\r\n    at processTicksAndRejections (internal/process/task_queues.js:75:11)\r\n```\r\n\r\n而这个 redis 组件确实间接依赖了 gRPC。这里放一个组件模块依赖关系，说明一下项目使用的各组件包之间的关系。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116182094-4ad9af80-a74e-11eb-8ed3-50d848392c04.png)\r\n\r\n其中每个黄色组件就是一单独的 npm 包。业务代码直接使用了 keycenter 包进行了秘钥的解密；同时引入了 redis 缓存组件，而缓存模块间接依赖了 keycenter。最终 keycenter 组件通过「静态代码生成」的方式使用 gRPC。\r\n\r\n下面我们就来一起看看这个问题。\r\n\r\n## 2、问题排查\r\n\r\n>❗️ 以下的章节顺序并非是排查时的实际顺序。大家实际排查问题时，还是建议先看“最近的现场”。 👀  例如这个问题，就会首先去 `Request message serialization failure` 抛错的地方查看情况。同时再辅以上层（外层）逻辑的排查，两头夹逼找到真相。但为了让文章阅读起来更顺畅，能够有从问题表象一步步走近真相，所以选择了目前的文章结构。我会尝试去尽量保留实际的排查路径。\r\n\r\n### 2.1、莫非是 redis 组件内部逻辑出错了？\r\n\r\n最直接的想法就是：新引入的这个 redis 组件有问题。因为出现问题的第一时间，我就把项目里下面这行代码注释掉了：\r\n\r\n```diff\r\n- this.redis = new Redis(redisConfig);\r\n+ // this.redis = new Redis(redisConfig);\r\n```\r\n\r\n注释完果然就好了。所以引入新组件确实导致了问题。\r\n\r\n由于报错和 gRPC 有关，而 redis 内部也间接依赖到了 gRPC（因为间接依赖了 keycenter），那么我的第一反应就是，这个组件内部逻辑可能有问题。也许是哪步操作使用到了 keycenter 方法，然后报出了错误。\r\n\r\n但这个想法出现的有多快，排除的就有多快。\r\n\r\n通过添加断点、日志的方式，很快就得出了一个结论：redis 组件虽然依赖到了 keycenter，但是整个实例化过程中完全不会调用它的方法，既然没有调用，这个 gRPC 的错误自然不是它直接导致的。\r\n\r\n但它和 redis 组件或多或少脱不了关系。\r\n\r\n### 2.2、是否真的是 redis 实例化导致了报错？\r\n\r\n上面我通过注释掉 Redis 实例化的代码行后运行正常，初步判断是实例化导致的问题。然而我忽略了重要的一点，typescript 编译时，对于 import 但是没有使用的模块，在产出的代码里是会把模块引入的这段删除的。\r\n\r\n例如下面这段代码，导入的模块实际没有使用，[在编译产出的代码中就不会导入该模块](https://www.typescriptlang.org/play?module=1#code/JYWwDg9gTgLgBAJQKYBNgGc4DMoRHAcgAFgA7HAQwFpSIUkB6KVDAgbgCgkAPSWOelgoBXADbwAjGyA)：\r\n\r\n```typescript\r\nimport Redis from '@infra-node/redis';\r\nexport default 1;\r\n```\r\n\r\n而如果是[这样](https://www.typescriptlang.org/play?module=1#code/JYWwDg9gTgLgBAJQKYBNgGc4DMoRHAcgAFgA7HAQwFpSIUkB6KVDAgbgChk102g)\r\n\r\n```typescript\r\nimport Redis from '@infra-node/redis';\r\nRedis;\r\n```\r\n\r\n或者[这样](https://www.typescriptlang.org/play?module=1#code/JYWwDg9gTgLgBAcgALAHYDMoEMC0qIAmApgPRREHADOCA3EA)\r\n\r\n```typescript\r\nimport '@infra-node/redis';\r\n```\r\n\r\n则模块引入的代码 `require(@infra-node/redis)` 在产出中会被保留。因此，实例化操作很可能并不是导致问题的原因。\r\n\r\n通过进一步测试，发现直接原因是引入了 `@infra-node/redis` 模块。导入模块就会导致问题，只要不导入就没事儿，我第一时间的直觉有两个：\r\n\r\n- 副作用\r\n- 依赖关系\r\n\r\n---\r\n\r\n到这里，我们先回到最初的问题。\r\n\r\n### 2.3、`new A instanceof A === false`?\r\n\r\n还记得最初的问题么？问题的抛错 `Error: 13 INTERNAL: Request message serialization failure: Expected argument of type XXX` 来自于 [grpc-tools 生成](https://github.com/grpc/grpc-node/blob/grpc%401.24.x/packages/grpc-tools/src/node_generator.cc#L132-L135)的 Nodejs 版 _xxx_grpc_pb.js_ 代码：\r\n\r\n```JavaScript\r\nfunction serialize_keycenter_SecretData(arg) {\r\n  if (!(arg instanceof keycenter_pb.SecretData)) {\r\n    throw new Error('Expected argument of type keycenter.SecretData');\r\n  }\r\n  return Buffer.from(arg.serializeBinary());\r\n}\r\n```\r\n\r\n`serialize_keycenter_SecretData` 是用于在请求时将 `SecretData` 实例序列化为二进制数据的方法。可以看到，方法里会判断 `arg` 是否是 `keycenter_pb.SecretData` 的实例。\r\n\r\n在我们项目的场景下，我们事先会得到了 pb 对象二进制的 base64 编码值，所以在代码中会使用 _xxx_pb.js_ 文件提供的反序列化生成 `SecretData` 的实例，并设置其他属性。\r\n\r\n```typescript\r\nimport { SecretData } from '../gen/keycenter_pb';\r\n// ...\r\n\r\n// 反序列化二进制\r\nconst secretData = SecretData.deserializeBinary(Buffer.from(base64, 'base64'));\r\nsecretData.setKeyName(keyName);\r\n\r\nkeyCenter.decrypt(secretData, metadata, (err, res) => {\r\n    // ...\r\n});\r\n```\r\n\r\n并且这里我打印 `arg` 后，在控制台看起来它的值也很正常。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116182179-6775e780-a74e-11eb-8f94-87b3fbf3a26f.png)\r\n\r\n`SecretData.deserializeBinary` 的方法实现如下：\r\n\r\n```typescript\r\nproto.keycenter.SecretData.deserializeBinary = function(bytes) {\r\n  var reader = new jspb.BinaryReader(bytes);\r\n  var msg = new proto.keycenter.SecretData;\r\n  return proto.keycenter.SecretData.deserializeBinaryFromReader(msg, reader);\r\n};\r\n\r\nproto.keycenter.SecretData.deserializeBinaryFromReader = function(msg, reader) {\r\n  while (reader.nextField()) {\r\n    if (reader.isEndGroup()) {\r\n      break;\r\n    }\r\n    var field = reader.getFieldNumber();\r\n    switch (field) {\r\n    case 1:\r\n      var value = /** @type {string} */ (reader.readString());\r\n      msg.setKeyName(value);\r\n      break;\r\n    case 2:\r\n      ...\r\n    }\r\n  }\r\n  return msg;\r\n};\r\n```\r\n\r\n从 `var msg = new proto.keycenter.SecretData;` 看起其就是通过 `SecretData` 构造函数创建了一个实例，并传入 `.deserializeBinaryFromReader` 方法中进行赋值，最后返回该实例。\r\n\r\n所以目前从这个错误看起来，像是一个 `new A instanceof A === false` 的伪命题。但显然并不可能。所以我的判断是，这里面一定有一个“李鬼” —— 有一个看起来像是 `SecretData` 但实际不是的家伙冒充了它。\r\n\r\n听起来似乎很奇怪。只能揣着性子继续排查。\r\n\r\n### 2.4、“奇怪”的依赖安装？\r\n\r\n首先回顾一下上面列出的包/模块依赖关系：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116182094-4ad9af80-a74e-11eb-8ed3-50d848392c04.png)\r\n\r\n我瞟了下目前实际的包安装情况。大致如下（省略了一些无关的包信息）：\r\n\r\n```\r\n.\r\n├── grpc-js\r\n│   ...\r\n├── keycenter\r\n└── redis\r\n    ├── Changelog.md\r\n    ├── LICENSE\r\n    ├── README.md\r\n    ├── built\r\n    ├── node_modules\r\n    │   ├── @infra-node\r\n    │   │   │ ...\r\n    │   │   └── keycenter\r\n    │   ├── chokidar\r\n    │   ├── debug\r\n    │   ├── p-map\r\n    │   └── readdirp\r\n    └── package.json\r\n```\r\n\r\n上面列出了目前项目中的包安装情况。可以看到一个比较有意思的地方：外层存在一个 keycenter 包，同时在 redis 内部也安装了一个 keycenter 包。这是为什么呢？\r\n\r\n原因很简单：项目直接依赖的 keycenter 版本声明与 redis 中的依赖版本无法合并指向同一版本，所以会在两个地方分别安装。这是 npm 的正常机制。一般这种情况也并不会出现问题。\r\n\r\n但当我手动删除了 redis 中的 keycenter 后，项目又可以正常运行了。看来“李鬼”就是这儿了。\r\n\r\n### 2.5、莫非引用了错误的模块文件？\r\n\r\n结合上面的情况，对于 `new A instanceof A === false` 的问题，基本可以认定为是 `new A' instanceof A === false`（注意里面的 A 和 A'）。也就是在\r\n\r\n```JavaScript\r\nfunction serialize_keycenter_SecretData(arg) {\r\n  if (!(arg instanceof keycenter_pb.SecretData)) {\r\n    throw new Error('Expected argument of type keycenter.SecretData');\r\n  }\r\n  return Buffer.from(arg.serializeBinary());\r\n}\r\n```\r\n\r\n这个方法执行时，传入的 `arg` 的构造函数与方法中的 `keycenter_pb.SecretData` 实际不同。这让我怀疑，是不是引用了错误的 __pb.js_ 文件。例如一个是用的外层 keycenter 中的 `keycenter_pb.js`，另一个则是使用到了 redis 中 keycenter 中的 `keycenter_pb.js`。两个文件一模一样，函数签名一模一样，但看起相同的两个对象，实则不同，自然过不了判断。\r\n\r\n难道是构造 `arg` 参数时引入的 `keycenter_pb.js` 和 `serialize_keycenter_SecretData` 方法引入的 `keycenter_pb.js` 不同么？\r\n\r\n基于我对 Nodejs `require` 机制的了解，基本排除了这个可能。它们是通过相对路径引入，根据模块寻路的规则，都会命中各自包内的代码模块。不存在引到其他包内的代码文件的情况。\r\n\r\n### 2.6、模块是如何被“污染”的？\r\n\r\n如果引用的模块没有问题，那么会不会是模块内的变量被“污染”了？\r\n\r\n这就和我最开始的直觉 —— “副作用”，有些关联了。副作用的产生场景很多，但是有一个场景非常典型，就是全局变量的使用。在查看 `keycenter_pb.js` 文件的代码后，我发现果然如此：\r\n\r\n```JavaScript\r\nvar jspb = require('google-protobuf');\r\nvar goog = jspb;\r\nvar global = Function('return this')();\r\n// ...\r\ngoog.exportSymbol('proto.keycenter.SecretData', null, global);\r\n// ...\r\ngoog.object.extend(exports, proto.keycenter);\r\n```\r\n\r\n代码通过 `Function('return this')()` 获取了全局对象。然后通过执行 `goog.exportSymbol` 方法，在全局对象上挂载 `global.proto.keycenter.SecretData` 属性值。最后再在 `exports` 上挂载 `proto.keycenter` 对象作为导出。\r\n\r\n但如果仔细分析，仅仅上述代码，并不会导致这个错误。因为它会先修改 global 引用的指向，再修改 global 上对应的对象。例如引入模块后引用关系大致如下：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116182221-75c40380-a74e-11eb-966f-f407ccfca1d7.png)\r\n\r\n当运行环境中再次引入一个同样内容 `_pb'.js` 文件后，就会变成如下引用关系。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/116182235-7a88b780-a74e-11eb-8649-7676223b8c93.png)\r\n\r\n可以看到原先的 proto 对象并不会被修改，即外部之前导入的对象并不会变。那么究竟是如何被“污染”的呢？\r\n\r\n其实问题来自于 2.3 节中用到的 `.deserializeBinary` 这个方法。这是 `_pb.js` 在构造函数上暴露出来的静态方法，可以根据二进制数据生成对应的实例对象：\r\n\r\n```JavaScript\r\nproto.keycenter.SecretData.deserializeBinary = function(bytes) {\r\n    var reader = new jspb.BinaryReader(bytes);\r\n    var msg = new proto.keycenter.SecretData;\r\n    return proto.keycenter.SecretData.deserializeBinaryFromReader(msg, reader);\r\n};\r\n```\r\n\r\n注意第二行 `var msg = new proto.keycenter.SecretData`，使用了 `proto.keycenter.SecretData` 这个构造函数，而我们根据前面的代码可以知道，这里的 proto 其实是 `[global].proto`。所以一旦我们的全局对象上的指向被修改后，这里使用的 `keycenter.SecretData` 其实就是另一个构造函数了。\r\n\r\n真相大白。导致错误的过程如下：\r\n\r\n1. 首先 `keycenter_grpc_pb.js` 引入了同目录下 `keycenter_pb.js` 文件，模块中的 `keycenter.SecretData` 构造函数这时候就确定了\r\n1. 因为一些其他原因，某个包引用了另一个地方的、内容相同的 pb 文件，为了区分我们叫它 `keycenter_pb-2.js`。它和 `keycenter_pb.js` 内容一摸一样，不过是两个文件。这时候 global 上指向的对象就被修改了\r\n1. 然后导入 `keycenter_pb.js` 模块，再使用 `SecretData.deserializeBinary` 生成实例，传入 `keycenter_grpc_pb.js` 中的方法就会出错了\r\n\r\n✨ 为了大家更好理解，我复刻了这个问题的核心逻辑，[做成了 demo](https://github.com/alienzhou/grpc-static-pollute-demo)，大家可以 clone 到本地再配合文章内容来查看、运行。\r\n\r\n---\r\n\r\n☕️ 上面已经完成了问题的排查，下面的文章会进入到另一个主题 —— 问题修复。本身以为会较为顺畅的修复过程，也遇到一些意料之外的问题。\r\n\r\n---\r\n\r\n## 3、解决思路\r\n\r\n如果理解了错误原因，就会发现这个错误出现的条件还是比较苛刻的。需要同时满足以下几个必要条件才会复现：\r\n\r\n1. 进行了挂载全局变量的操作\r\n1. 项目同时 import 两个内容相同的 `_pb.js` 文件\r\n1. 使用了 `.deserializeBinary` 方法来创建实例对象\r\n1. 模块的 import 顺序需要先导入 `_grpc_pb.js`，再导入 `_pb'.js`（同内容的另一个 pb 文件）\r\n\r\n针对 2～4 这三个条件，我们只要破坏其一，就可以避免问题发生。我在 [demo 项目](https://github.com/alienzhou/grpc-static-pollute-demo)中分别写了对应的代码（correct-2.ts、correct-3.ts、correct-4.ts），感兴趣的话可以试下。\r\n\r\n如果作为包提供方，要解决这个问题虽然看似方式很多，但是现实上我们能控制的有限 ——\r\n\r\n- 先是第 2 条，会需要保证只安装一个 keycenter 包。不同包、模块对于包的版本依赖是外部控制的，不受包自身控制，因此很难确保根除；\r\n- 然后是第 3 条，使用 `.deserializeBinary` 是功能要求，如果要规避这个方法的坑会使代码变得较为 tricky；\r\n- 最后是第 4 条，引用顺序显然也是外部控制的，不受包自身所控\r\n\r\n所以我们尽量还是希望能找一个“正规”的路子，使得通过 grpc-tools 或者 protoc 生成的 `_pb.js` 文件，不会产生全局污染（也就是破除条件 1）。\r\n\r\n## 4、修复之路\r\n\r\n### 4.1、让 protoc 生成的代码避免全局污染\r\n\r\n按上面的思路，我们会希望在 protoc 生成时就产出一份“安全”的 `_pb.js` 静态文件。\r\n\r\nprotoc 支持在 js_out 参数中设置 `import_style` 来控制模块类型。[官方文档](https://developers.google.com/protocol-buffers/docs/reference/javascript-generated#commonjs-imports)里提供了 `commonjs` 这个参数。\r\n\r\n```bash\r\nprotoc --proto_path=src --js_out=import_style=commonjs,binary:build/gen src/foo.proto src/bar/baz.proto\r\n```\r\n\r\n但是遗憾的是，这个参数并不会生成我们预想的代码，它生成的代码就是我们在上文中看到的“问题代码”。所以还有其他 `import_style` 么？\r\n\r\n文档里没有，只能去源码里找答案了。\r\n\r\n> 下面会涉及到 protoc，这里简单介绍了一下，便于不了解的朋友能快速理解。[protobuf](https://github.com/protocolbuffers/protobuf#protocol-compiler-installation) 这个仓库中包含了 Protocol Compiler。其中各个语言相关的代码生成器放在了 `src/google/protobuf/compiler/` 下面对应名称的文件夹里。例如 JavaScript 就是 [`/js` 文件夹内](https://github.com/protocolbuffers/protobuf/tree/v3.15.7/src/google/protobuf/compiler/js)。\r\n\r\n在源码中可以发现，其[支持的 style 值](https://github.com/protocolbuffers/protobuf/blob/v3.15.7/src/google/protobuf/compiler/js/js_generator.cc#L3492-L3502)并非只有 commonjs 和 closure 两种：\r\n\r\n```c++\r\n// ...\r\nelse if (options[i].first == \"import_style\") {\r\n  if (options[i].second == \"closure\") {\r\n    import_style = kImportClosure;\r\n  } else if (options[i].second == \"commonjs\") {\r\n    import_style = kImportCommonJs;\r\n  } else if (options[i].second == \"commonjs_strict\") {\r\n    import_style = kImportCommonJsStrict;\r\n  } else if (options[i].second == \"browser\") {\r\n    import_style = kImportBrowser;\r\n  } else if (options[i].second == \"es6\") {\r\n    import_style = kImportEs6;\r\n  } else {\r\n    *error = \"Unknown import style \" + options[i].second + \", expected \" +\r\n              \"one of: closure, commonjs, browser, es6.\";\r\n  }\r\n}\r\n// ...\r\n```\r\n\r\n但大致浏览完源码后，我发现 browser 和 es6 两种 style 实际也不能满足我们的需求。这时候就剩下 `commonjs_strict` 了。这个 strict 感觉就会非常贴合我们的目标。\r\n\r\n主要的[相关代码](https://github.com/protocolbuffers/protobuf/blob/v3.15.7/src/google/protobuf/compiler/js/js_generator.cc#L3635-L3645)如下：\r\n\r\n```c++\r\n// Generate \"require\" statements.\r\nif ((options.import_style == GeneratorOptions::kImportCommonJs ||\r\n      options.import_style == GeneratorOptions::kImportCommonJsStrict)) {\r\n  printer->Print(\"var jspb = require('google-protobuf');\\n\");\r\n  printer->Print(\"var goog = jspb;\\n\");\r\n\r\n  // Do not use global scope in strict mode\r\n  if (options.import_style == GeneratorOptions::kImportCommonJsStrict) {\r\n    printer->Print(\"var proto = {};\\n\\n\");\r\n  } else {\r\n    printer->Print(\"var global = Function('return this')();\\n\\n\");\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\n这里就可以看出 `commonjs_strict` 和 `commonjs` 最大的区别就是是否使用了全局变量。如果是 `commonjs_strict` 则会使用 `var proto = {};` 来代替全局变量。完全满足需求！\r\n\r\n但是，实际使用后，我发现了另一个问题。\r\n\r\n### 4.2、grpc-tools 并不适配 `commonjs_strict`\r\n\r\n`import_style=commonjs_strict` 另一个最大的区别在于[导出代码的生成](https://github.com/protocolbuffers/protobuf/blob/v3.15.7/src/google/protobuf/compiler/js/js_generator.cc#L3690-L3697)：\r\n\r\n```c++\r\n// if provided is empty, do not export anything\r\nif (options.import_style == GeneratorOptions::kImportCommonJs &&\r\n    !provided.empty()) {\r\n  printer->Print(\"goog.object.extend(exports, $package$);\\n\", \"package\",\r\n                  GetNamespace(options, file));\r\n} else if (options.import_style == GeneratorOptions::kImportCommonJsStrict) {\r\n  printer->Print(\"goog.object.extend(exports, proto);\\n\", \"package\",\r\n                  GetNamespace(options, file));\r\n}\r\n```\r\n\r\n这样看可能不太直观，直接贴两种 style 生成的代码就很明白了。\r\n\r\n下面是用 `commonjs_strict` 生成的：\r\n\r\n```\r\ngoog.object.extend(exports, proto);\r\n```\r\n\r\n下面是用 `commonjs` 生成的：\r\n\r\n```\r\ngoog.object.extend(exports, proto.keycenter);\r\n```\r\n\r\n这样就能明显看出区别了。`commonjs` 形式导出时会导出 package 下的对象。因此，在我们使用对应的 `_pb.js` 文件时，会需要调整一下导入的代码。此外，grpc-tools 生成的 __grpc_pd.js_ 静态代码因为也会导入 `_pb.js` 文件，因此也需要适配这种导出。\r\n\r\n> 这里简单介绍下 grpc-tools 的角色。它做了两件事，一个是 wrap 了一些 protoc 命令行，这样用户可以直接使用 grpc-tools 而不去关心 protoc；另一个是实现了一个 protoc 的 grpc 插件。关于 protoc 插件机制与如何实现一个 protoc 插件，后续有机会可以单写篇文章介绍。\r\n\r\n而当我满心欢喜地去翻阅 [grpc-tools 源码](https://github.com/grpc/grpc-node/blob/grpc%401.24.6/packages/grpc-tools/src/node_generator.cc#L218-L221)时发现，\r\n\r\n```c++\r\ngrpc::string file_path =\r\n    GetRelativePath(file->name(), GetJSMessageFilename(file->name()));\r\nout->Print(\"var $module_alias$ = require('$file_path$');\\n\", \"module_alias\",\r\n            ModuleAlias(file->name()), \"file_path\", file_path);\r\n```\r\n\r\n它并不会考虑 `import_style=commonjs_strict` 这种情况，而是固定生成对应 `commonjs` 的导入代码。也有 [issue](https://github.com/grpc/grpc-node/issues/1445) 提到了这个问题。\r\n\r\n### 4.3、只能自己动手了\r\n\r\n好吧，这个导入/导出的问题目前没有特别好的解决办法。\r\n\r\n我们这边之前因为一些特殊需求，所以 folk 了 grpc-tools 的代码，修改了内部实现以适配我们的 RPC 框架。因此这块就自己上手，支持了 `import_style=commonjs_strict` 这种情况，修改了导入时的代码：\r\n\r\n```c++\r\ngrpc::string pb_package = file->package();\r\nif (params.commonjs_strict && !pb_package.empty()) {\r\n  out->Print(\"var $module_alias$ = require('$file_path$').$pb_package$;\\n\", \"module_alias\",\r\n           ModuleAlias(file->name()), \"file_path\", file_path, \"pb_package\", pb_package);\r\n} else {\r\n  out->Print(\"var $module_alias$ = require('$file_path$');\\n\", \"module_alias\",\r\n           ModuleAlias(file->name()), \"file_path\", file_path);\r\n}\r\n```\r\n\r\n当然还需要配合做一些其他改动，例如 CLI 入参的判断处理等，这里就不贴了。\r\n\r\n当然，令人头疼的问题不止这一个，如果你使用了其他 protoc 插件自动生成 .d.ts 文件的话，这块也会需要适配 `import_style=commonjs_strict` 的情况。\r\n\r\n\r\n## 5、最后\r\n\r\n本文主要记录了一次 gRPC 相关报错的排查过程。包括找出原因、提出解决思路到最后修复的整个过程。\r\n\r\n排查问题是每个工程师经常会面对的事儿，也常常充满挑战。往往这些问题的落脚处可能并不大，修复工作也只是简单几行代码。而排障的过程，伴随着各类知识或技术点的使用，从表象到真相，整个过程也是工程师独有的乐趣。\r\n\r\n而在文章写作上，相比介绍一个技术点，要写好一篇排障文章往往更不容易，所以也想挑战一下自己。\r\n\r\n> 文章内容有一个配套的 [demo 代码](https://github.com/alienzhou/grpc-static-pollute-demo)，可以用来配合理解文章中的问题。","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/45","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/45/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/45/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/45/events","html_url":"https://github.com/alienzhou/blog/issues/45","id":818888328,"node_id":"MDU6SXNzdWU4MTg4ODgzMjg=","number":45,"title":"vue-cli 迁移 vite2 实践小结","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":2782716193,"node_id":"MDU6TGFiZWwyNzgyNzE2MTkz","url":"https://api.github.com/repos/alienzhou/blog/labels/vue","name":"vue","color":"42b983","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""},{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-03-01T13:53:28Z","updated_at":"2021-03-09T07:57:10Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"两周前（202.02.17），[vite2.0 发布了](https://dev.to/yyx990803/announcing-vite-2-0-2f0a)，作为使用了浏览器原生 ESM 为下一代前端工具，vite 2.0 相较于 1.0 更加成熟。在此之前笔者就开始[关注这类「新型」的前端工具](https://github.com/alienzhou/blog/issues/42)。这次趁着 vite 2.0 发布，也成功将一个基于 vue-cli(-service) + vue2 的已有项目进行了迁移。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/109505512-a1709780-7ad7-11eb-8315-8fb324a34dfd.png)\r\n\r\n迁移工作比较顺利，花了不到半天时间。但整个迁移过程中也遇到了一些小问题，这里汇总一下，也方便遇到类似问题的朋友一起交流和参考。\r\n\r\n## 项目背景\r\n\r\n在介绍具体迁移工作前，先简单介绍下项目情况。目前该项目上线不到一年，不太有构建相关的历史遗留债务。项目包含 1897 个模块文件（包括 node_modules 中模块），使用了 vue2 + vuex + typescript 的技术栈，构建工具使用的是 vue-cli（webpack）。算是一套比较标准的 vue 技术栈。由于是内部系统，项目对兼容性的要求较低，用户基本都使用较新的 Chrome 浏览器（少部分使用 Safari）。\r\n\r\n## 迁移工作\r\n\r\n下面具体来说下迁移中都做了哪些处理。\r\n\r\n### 1、配置文件\r\n\r\n首先需要安装 vite 并创建 vite 的配置文件。\r\n\r\n```bash\r\nnpm i -D vite\r\n```\r\n\r\nvue-cli-service 中使用 `vue.config.js` 作为配置文件；而 vite 则默认会需要创建一个 `vite.config.ts` 来作为配置文件。基础的配置文件很简单：\r\n\r\n```typescript\r\nimport { defineConfig } from 'vite';\r\n\r\nexport default defineConfig({\r\n  plugins: [\r\n    // ...\r\n  ],\r\n})\r\n```\r\n\r\n创建该配置文件，之前的 vue.config.js 就不再使用了。\r\n\r\n### 2、入口与 HTML 文件\r\n\r\n在 vite 中也需要指定入口文件。但和 webpack 不同，在 vite 中不是指定 js/ts 作为入口，而是指定实际的 HTML 文件作为入口。\r\n\r\n在 webpack 中，用户通过将 entry 设置为入口 js（例如 `src/app.js`）来指定 js 打包的入口文件，辅以 HtmlWebpackPlugin 将生成的 js 文件路径注入到 HTML 中。而 vite 直接使用 HTML 文件，它会解析 HTML 中的 script 标签来找到入口的 js 文件。\r\n\r\n因此，我们在入口 HTML 中加入对 js/ts 文件的 script 标签引用：\r\n\r\n```diff\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\r\n  <title><%= htmlWebpackPlugin.options.title %></title>\r\n</head>\r\n\r\n<body>\r\n  <noscript>\r\n    We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled.\r\n  </noscript>\r\n  <div id=\"app\"></div>\r\n+ <script type=\"module\" src=\"/src/main.ts\"></script>\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n注意上面 `<script type=\"module\" src=\"/src/main.ts\"></script>` 这一行，它使用浏览器原生的 ESM 来加载该脚本，`/src/main.ts` 就是入口 js 的源码位置。在 vite dev 模式启动时，它其实启动了一个类似静态服务器的 server，将 serve 源码目录，因此不需要像 webpack 那样的复杂模块打包过程。模块的依赖加载将完全依托于浏览器中对 `import` 语法的处理，因此可以看到很长一串的脚本加载瀑布流：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/027b6d2e82584d8da2cb8a32c145fff1~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n这里还需要注意 [project root 的设置](https://vitejs.dev/config/#root)。在默认是 `process.cwd()`，而 index.html 也会在 project root 下进行寻找。为了方便我将 `./public/index.html` 移到了 `./index.html`。\r\n\r\n### 3、使用 vue 插件\r\n\r\nvite 2.0 提供了对 vue 项目的良好支持，但其本身并不和 vue 进行较强耦合，因此通过插件的形式来支持对 vue 技术栈的项目进行构建。vite 2.0 官网目前（2021.2.28）推荐的 vue 插件会和 [vue3 的 SFC](https://vitejs.dev/plugins/#vitejs-plugin-vue) 一起使用更好。因此这里使用了一个专门用来支持 vue2 的插件 [vite-plugin-vue2](https://www.npmjs.com/package/vite-plugin-vue2)，支持 JSX，同时目前最新版本也是[支持 vite2 的](https://github.com/underfin/vite-plugin-vue2/pull/13)。\r\n\r\n使用上也很简单：\r\n\r\n```diff\r\nimport { defineConfig } from 'vite';\r\n+ import { createVuePlugin } from 'vite-plugin-vue2';\r\n\r\nexport default defineConfig({\r\n  plugins: [\r\n+   createVuePlugin(),\r\n  ],\r\n});\r\n```\r\n\r\n### 4、处理 typescript 路径映射\r\n\r\n使用 vite 构建 ts 项目时，如果使用了 [typescript 路径映射](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping)的功能，就需要进行特殊处理，否则会出现模块无法解析（找不到）的错误：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/109505866-fdd3b700-7ad7-11eb-85a2-780129e9ada3.png)\r\n\r\n这里需要使用 [vite-tsconfig-paths](https://github.com/aleclarson/vite-tsconfig-paths) 这个插件来做路径映射的解析替换。其原理较为简单，大致就是 vite 插件的 [resolveId 钩子](https://vitejs.dev/guide/api-plugin.html#universal-hooks)阶段，利用 [tsconfig-paths](https://www.npmjs.com/package/tsconfig-paths) 这个库来将路径映射解析为实际映射返回。有兴趣的可以看下该插件的实现，比较简短。\r\n\r\n具体使用方式如下：\r\n\r\n```diff\r\nimport { defineConfig } from 'vite';\r\nimport { createVuePlugin } from 'vite-plugin-vue2';\r\n+ import tsconfigPaths from 'vite-tsconfig-paths';\r\n\r\n// https://vitejs.dev/config/\r\nexport default defineConfig({\r\n  plugins: [\r\n    createVuePlugin(),\r\n+   tsconfigPaths(),\r\n  ],\r\n});\r\n```\r\n\r\n### 5、替换 CommonJS\r\n\r\nvite 使用 ESM 作为模块化方案，因此不支持使用 `require` 方式来导入模块。否则在运行时会报 `Uncaught ReferenceError: require is not defined` 的错误（浏览器并不支持 CJS，自然没有 require 方法注入）。\r\n\r\n此外，也可能会遇到 ESM 和 CJS 的兼容问题。当然这并不是 vite 构建所导致的问题，但需要注意这一点。简单来说就是 ESM 有 default 这个概念，而 CJS 没有。任何导出的变量在 CJS 看来都是 module.exports 这个对象上的属性，ESM 的 default 导出也只是 cjs 上的 module.exports.default 属性而已。例如在 typescript 中我们会通过 esModuleInterop 配置来让 tsc 添加一些兼容代码帮助解析导入的模块，webpack 中也有类似操作。\r\n\r\n例如之前的代码：\r\n\r\n```typescript\r\nmodule.exports = {\r\n    SSO_LOGIN_URL: 'https://xxx.yyy.com',\r\n    SSO_LOGOUT_URL: 'https://xxx.yyy.com/cas/logout',\r\n}\r\n```\r\n\r\n```typescript\r\nconst config = require('./config');\r\n```\r\n\r\n在导出和导入上都需要修改为 ESM，例如：\r\n\r\n```typescript\r\nexport default {\r\n    SSO_LOGIN_URL: 'https://xxx.yyy.com',\r\n    SSO_LOGOUT_URL: 'https://xxx.yyy.com/cas/logout',\r\n}\r\n```\r\n\r\n```typescript\r\nimport config from './config';\r\n```\r\n\r\n### 6、环境变量的使用方式\r\n\r\n使用 vue-cli（webpack）时我们经常会利用环境变量来做运行时的代码判断，例如：\r\n\r\n```typescript\r\nconst REPORTER_HOST = process.env.REPORTER_TYPE === 'mock'\r\n  ? 'http://mock-report.xxx.com'\r\n  : 'http://report.xxx.com';\r\n```\r\n\r\n[vite 仍然支持环境变量](https://vitejs.dev/guide/env-and-mode.html#env-variables)的使用，但不再提供 `process.env` 这样的访问方式。而是需要通过 [`import.meta.env`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import.meta) 来访问环境变量：\r\n\r\n```diff\r\n-const REPORTER_HOST = process.env.REPORTER_TYPE === 'mock'\r\n+const REPORTER_HOST = import.meta.env.REPORTER_TYPE === 'mock'\r\n  ? 'http://mock-report.xxx.com'\r\n  : 'http://report.xxx.com';\r\n```\r\n\r\n与 webpack 类似，vite 也[内置了一些环境变量](https://vitejs.dev/guide/env-and-mode.html#env-variables)，可以直接使用。\r\n\r\n### 7、`import.meta.env` types\r\n\r\n> 补充：vite 提供了它所需要的 types 定义，可以直接应用 [vite/client](https://github.com/vitejs/vite/blob/v2.0.3/packages/vite/client.d.ts) 来引入，可以不需要通过以下方式来自己添加。\r\n\r\n如果在 typescript 中通过 [`import.meta.env`](https://github.com/microsoft/TypeScript/issues/22861) 来访问环境变量，可能会有一个 ts 错误提示：`类型“ImportMeta”上不存在属性“env”`。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/109505944-13e17780-7ad8-11eb-80a2-3bdbd61c241e.png)\r\n\r\n这是因为在目前版本下（v4.2.2）`import.meta` 的定义还是一个[空的 interface](https://github.com/microsoft/TypeScript/blob/v4.2.2/lib/lib.es5.d.ts#L608-L615)：\r\n\r\n```typescript\r\ninterface ImportMeta {\r\n}\r\n```\r\n\r\n但我们可以通过 interface 的 merge 能力，在项目中进一步定义 ImportMeta 的类型来拓展对 `import.meta.env` 的类型支持。例如之前通过 vue-cli 生成的 ts 项目在 src 目录下会生成 `vue-shims.d.ts` 文件，可以在这里拓展 env 类型的支持：\r\n\r\n```typescript\r\ndeclare global {\r\n  interface ImportMeta {\r\n    env: Record<string, unknown>;\r\n  }\r\n}\r\n```\r\n\r\n这样就不会报错了。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/109505976-1c39b280-7ad8-11eb-824e-e9ca017b0c6a.png)\r\n\r\n### 8、webpack require context\r\n\r\n在 webpack 中我们可以通过 [`require.context`](https://webpack.js.org/api/module-methods/#requirecontext) 方法「动态」解析模块。比较常用的一个做法就是指定某个目录，通过正则匹配等方式加载某些模块，这样在后续增加新的模块后，可以起到「动态自动导入」的效果。\r\n\r\n例如在项目中，我们动态匹配 modules 文件夹下的 route.ts 文件，在全局的 vue-router 中设置 router 配置：\r\n\r\n```typescript\r\nconst routes = require.context('./modules', true, /([\\w\\d-]+)\\/routes\\.ts/)\r\n    .keys()\r\n    .map(id => context(id))\r\n    .map(mod => mod.__esModule ? mod.default : mod)\r\n    .reduce((pre, list) => [...pre, ...list], []);\r\n\r\nexport default new VueRouter({ routes });\r\n```\r\n\r\n文件结构如下：\r\n\r\n```\r\nsrc/modules\r\n├── admin\r\n│   ├── pages\r\n│   └── routes.ts\r\n├── alert\r\n│   ├── components\r\n│   ├── pages\r\n│   ├── routes.ts\r\n│   ├── store.ts\r\n│   └── utils\r\n├── environment\r\n│   ├── store\r\n│   ├── types\r\n│   └── utils\r\n└── service\r\n    ├── assets\r\n    ├── pages\r\n    ├── routes.ts\r\n    ├── store\r\n    └── types\r\n```\r\n\r\nrequire context 是 webpack 提供的特有的模块方法，并不是语言标准，所以在 vite 中不再能使用 require context。但如果完全改为开发者手动 import 模块，一来是对已有代码改动容易产生模块导入的遗漏；二来是放弃了这种「灵活」的机制，对后续的开发模式也会有一定改变。但好在 vite2.0 提供了 [glob 模式的模块导入](https://vitejs.dev/guide/features.html#glob-import)。该功能可以实现上述目标。当然，会需要做一定的代码改动：\r\n\r\n```typescript\r\nconst routesModules = import.meta.globEager<{default: unknown[]}>('./modules/**/routes.ts');\r\nconst routes = Object\r\n  .keys(routesModules)\r\n  .reduce<any[]>((pre, k) => [...pre, ...routesMod[k].default], []);\r\n\r\nexport default new VueRouter({ routes });\r\n```\r\n\r\n主要就是将 `require.context` 改为 `import.meta.globEager`，同时适配返回值类型。当然，为了支持 types，可以为 ImportMeta 接口添加一些类型：\r\n\r\n```diff\r\ndeclare global {\r\n  interface ImportMeta {\r\n    env: Record<string, unknown>;\r\n+   globEager<T = unknown>(globPath: string): Record<string, T>;\r\n  }\r\n}\r\n```\r\n\r\n此外再提一下，`import.meta.globEager` 会在构建时做静态分析将代码替换为静态 import 语句。如果希望能支持 dynamic import，请使用 `import.meta.glob` 方法。\r\n\r\n### 9、API 代理\r\n\r\nvite2.0 本地开发时（DEV 模式）仍然提供了一个 HTTP server，同时也支持[通过 proxy 项设置代理](https://vitejs.dev/config/#server-proxy)。其背后和 webpack 一样也是使用了 [http-proxy](https://github.com/http-party/node-http-proxy)，因此针对 vue-cli 的 proxy 设置可以迁移到 vite 中：\r\n\r\n```diff\r\nimport { defineConfig } from 'vite';\r\nimport tsconfigPaths from 'vite-tsconfig-paths';\r\nimport { createVuePlugin } from 'vite-plugin-vue2';\r\n+ import proxy from './src/tangram/proxy-table';\r\n\r\nexport default defineConfig({\r\n  plugins: [\r\n    tsconfigPaths(),\r\n    createVuePlugin(),\r\n  ],\r\n+ server: {\r\n+   proxy,\r\n+ }\r\n});\r\n```\r\n\r\n### 10、HTML 内容插入\r\n\r\n在基于 vue-cli 中我们可以利用 webpack 的 HtmlWebpackPlugin 来实现 HTML 中值的替换，例如 `<%= htmlWebpackPlugin.options.title %>` 这种形式来将该处模板变量在编译时，替换为实际的 title 值。要实现这样的功能也非常简单，例如 [vite-plugin-html](https://www.npmjs.com/package/vite-plugin-html) 。这个插件基于 ejs 来实现模板变量注入，通过 `transformIndexHtml` 钩子，接收原始 HTML 字符串，然后通过 ejs 渲染注入的变量后返回。\r\n\r\n下面是迁移后，使用 vite-plugin-html 的配置方式：\r\n\r\n```diff\r\nimport { defineConfig } from 'vite';\r\nimport tsconfigPaths from 'vite-tsconfig-paths';\r\nimport { createVuePlugin } from 'vite-plugin-vue2';\r\n+ import { injectHtml } from 'vite-plugin-html';\r\n\r\nexport default defineConfig({\r\n  plugins: [\r\n    tsconfigPaths(),\r\n    createVuePlugin(),\r\n+   injectHtml({\r\n+     injectData: {\r\n+       title: '用户管理系统',\r\n+     },\r\n    }),\r\n  ],\r\n  server: {\r\n    proxy,\r\n  },\r\n});\r\n```\r\n\r\n对应的需求修改一下 HTML 的模板变量写法：\r\n\r\n```diff\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\r\n- <title><%= htmlWebpackPlugin.options.title %></title>\r\n+ <title><%= title %></title>\r\n</head>\r\n\r\n<body>\r\n  <noscript>\r\n-   We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled.\r\n+   We're sorry but <%= title %> doesn't work properly without JavaScript enabled.\r\n  </noscript>\r\n  <div id=\"app\"></div>\r\n  <script type=\"module\" src=\"/src/main.ts\"></script>\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n### 11、兼容性处理\r\n\r\n在项目背景介绍上有提到该项目对兼容性要求很低，所以这块在迁移中实际并未涉及。\r\n\r\n当然，如果对兼容性有要求的项目，可以使用 [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) 插件。该插件会打包出两套代码，一套面向新式浏览器，另一套则包含各类 polyfill 和语法兼容来面向老式浏览器。同时在 HTML 中使用 [module/nomodule 技术](https://philipwalton.com/articles/using-native-javascript-modules-in-production-today/)来实现新/老浏览器中的「条件加载」。\r\n\r\n## 总结\r\n\r\n该项目包含 1897 个模块文件（包括 node_modules 中模块），迁移前后的构建（无缓存）耗时如下：\r\n\r\n|     | vue-cli  | vite 2 |\r\n|  ----  | ----  | ----  |\r\n| dev 模式 | ~8s | ~400ms |\r\n| prod 模式 | ~42s | ~36s |\r\n\r\n可以看到，在 DEV 模式下 vite2 构建效率的提升非常明显，这也是因为其在 DEV 模式下只做一些轻量级模块文件处理，不会做较重的打包工作，而在生产模式下，由于仍然需要使用 esbuild 和 rollup 做构建，所以在该项目中效率提升并不明显。\r\n\r\n---\r\n\r\n以上就是笔者在做 vue-cli 迁移 vite 2.0 时，遇到的一些问题。都是一些比较小的点，整体迁移上并未遇到太大的阻碍，用了不到半天时间就迁移了。当然，这也有赖于近年来 JavaScript、HTML 等标准化工作使得我们写的主流代码也能够具备一定的统一性。这也是这些前端工具让我们「面向未来」编程带来的一大优点。希望这篇文章能够给，准备尝试迁移到 vite 2.0 的各位朋友一些参考。","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/43","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/43/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/43/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/43/events","html_url":"https://github.com/alienzhou/blog/issues/43","id":748529110,"node_id":"MDU6SXNzdWU3NDg1MjkxMTA=","number":43,"title":"如何实现可复用的控制台“艺术字”打印","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":2045616625,"node_id":"MDU6TGFiZWwyMDQ1NjE2NjI1","url":"https://api.github.com/repos/alienzhou/blog/labels/Node.js","name":"Node.js","color":"c3ea81","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-11-23T06:59:49Z","updated_at":"2021-03-01T13:55:47Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"之前在使用一些开源项目时，经常会看到在控制台输出项目大大的 LOGO。例如：\r\n\r\n- hexo minos 主题启动时在控制台里会显示「MINOS」文案\r\n- fis3 启动时也会有显示「FIS」\r\n\r\n添加这种大号「艺术字」可以达到「品牌露出」的效果，当然，也是程序员特有「情趣」的体现。 😄\r\n\r\n但它们的实现方式无外乎把编排好的 Logo 通过 `console.log` 输出。这种方式问题在于它几乎没有任何复用能力，而且一些需要转义的情况还会导致字符串的可维护性极差。因此，我花了一个周末的时候，实现了一个易用的、可复用的控制台「艺术字」lib。这样，下次有新的需求，只需要把正常的文本传给它，它就可以帮你**自动编排与打印**。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/99935706-4a527c80-2d9c-11eb-8e36-a455808a03c4.png)\r\n\r\n## 1. 目标\r\n\r\n正如上节所说，目前一般项目的做法都是自定写一串特定的文本，例如 minos：\r\n\r\n```JavaScript\r\nlogger.info(`=======================================\r\n███╗   ███╗ ██╗ ███╗   ██╗  ██████╗  ███████╗\r\n████╗ ████║ ██║ ████╗  ██║ ██╔═══██╗ ██╔════╝\r\n██╔████╔██║ ██║ ██╔██╗ ██║ ██║   ██║ ███████╗\r\n██║╚██╔╝██║ ██║ ██║╚██╗██║ ██║   ██║ ╚════██║\r\n██║ ╚═╝ ██║ ██║ ██║ ╚████║ ╚██████╔╝ ███████║\r\n╚═╝     ╚═╝ ╚═╝ ╚═╝  ╚═══╝  ╚═════╝  ╚══════╝\r\n=============================================`);\r\n```\r\n\r\n还有 fis3 这种由于需要添加转义所以显得凌乱不好维护的\r\n\r\n```JavaScript\r\nlogo = [\r\n      '   /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\  /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   ',\r\n      '   \\\\/\\\\\\\\\\\\///////////  \\\\/////\\\\\\\\\\\\///    /\\\\\\\\\\\\/////////\\\\\\\\\\\\        ',\r\n      '    \\\\/\\\\\\\\\\\\                 \\\\/\\\\\\\\\\\\      \\\\//\\\\\\\\\\\\      \\\\///  ',\r\n      '     \\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\         \\\\/\\\\\\\\\\\\       \\\\////\\\\\\\\\\\\              ',\r\n      '      \\\\/\\\\\\\\\\\\///////          \\\\/\\\\\\\\\\\\          \\\\////\\\\\\\\\\\\          ',\r\n      '       \\\\/\\\\\\\\\\\\                 \\\\/\\\\\\\\\\\\             \\\\////\\\\\\\\\\\\      ',\r\n      '        \\\\/\\\\\\\\\\\\                 \\\\/\\\\\\\\\\\\      /\\\\\\\\\\\\      \\\\//\\\\\\\\\\\\  ',\r\n      '         \\\\/\\\\\\\\\\\\              /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\///\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/   ',\r\n      '          \\\\///              \\\\///////////    \\\\///////////     ',\r\n      ''\r\n    ].join('\\n');\r\n```\r\n\r\n这种些方式都是通过「硬编码」来实现的，如果有了新项目或需求变动还得重新编排调整。\r\n\r\n因此，准备实现一种能够根据输入的字符串进行自动排版展示的控制台「艺术字」打印库，例如通过 `yo('yoo-hoo')` 就会输出：\r\n\r\n```text\r\n /\\\\\\    /\\\\\\  /\\\\\\\\\\\\\\\\      /\\\\\\\\\\\\\\\\                /\\\\\\    /\\\\\\    /\\\\\\\\\\\\\\\\      /\\\\\\\\\\\\\\\\\r\n \\/\\\\\\   /\\\\\\ /\\\\\\_____/\\\\\\  /\\\\\\_____/\\\\\\             \\/\\\\\\   \\/\\\\\\  /\\\\\\_____/\\\\\\  /\\\\\\_____/\\\\\\\r\n   \\/_\\\\\\/\\\\\\ \\/\\\\\\    \\/\\\\\\ \\/\\\\\\    \\/\\\\\\             \\/\\\\\\   \\/\\\\\\ \\/\\\\\\    \\/\\\\\\ \\/\\\\\\    \\/\\\\\\\r\n      \\/_\\\\\\\\  \\/\\\\\\    \\/\\\\\\ \\/\\\\\\    \\/\\\\\\  /\\\\\\\\\\\\\\\\\\ \\/\\\\\\\\\\\\\\\\\\\\\\ \\/\\\\\\    \\/\\\\\\ \\/\\\\\\    \\/\\\\\\\r\n         \\/\\\\\\  \\/\\\\\\    \\/\\\\\\ \\/\\\\\\    \\/\\\\\\ \\/_______/  \\/\\\\\\____/\\\\\\ \\/\\\\\\    \\/\\\\\\ \\/\\\\\\    \\/\\\\\\\r\n          \\/\\\\\\  \\/\\\\\\    \\/\\\\\\ \\/\\\\\\    \\/\\\\\\             \\/\\\\\\   \\/\\\\\\ \\/\\\\\\    \\/\\\\\\ \\/\\\\\\    \\/\\\\\\\r\n           \\/\\\\\\  \\/_/\\\\\\\\\\\\\\\\\\  \\/_/\\\\\\\\\\\\\\\\\\              \\/\\\\\\   \\/\\\\\\ \\/_/\\\\\\\\\\\\\\\\\\  \\/_/\\\\\\\\\\\\\\\\\\\r\n            \\/_/     \\/_______/     \\/_______/               \\/_/    \\/_/    \\/_______/     \\/_______/\r\n```\r\n\r\n下次如果文案改了，直接换下字符串参数就行 —— `yo('new-one')`：\r\n\r\n```text\r\n/\\\\\\\\\\     /\\\\\\  /\\\\\\\\\\\\\\\\\\\\  /\\\\\\  \\\\\\  \\\\\\                /\\\\\\\\\\\\\\\\    /\\\\\\\\\\     /\\\\\\  /\\\\\\\\\\\\\\\\\\\\\r\n\\/\\\\\\ \\\\\\  \\/\\\\\\ \\/\\\\\\_____/  \\/\\\\\\  \\\\\\  \\\\\\              /\\\\\\_____/\\\\\\ \\/\\\\\\ \\\\\\  \\/\\\\\\ \\/\\\\\\_____/\r\n \\/\\\\\\ /\\\\\\ \\/\\\\\\ \\/\\\\\\        \\/\\\\\\  \\\\\\  \\\\\\             \\/\\\\\\    \\/\\\\\\ \\/\\\\\\ /\\\\\\ \\/\\\\\\ \\/\\\\\\\r\n  \\/\\\\\\  /\\\\\\ /\\\\\\ \\/\\\\\\\\\\\\\\\\\\\\ \\/\\\\\\  \\\\\\  \\\\\\  /\\\\\\\\\\\\\\\\\\ \\/\\\\\\    \\/\\\\\\ \\/\\\\\\  /\\\\\\ /\\\\\\ \\/\\\\\\\\\\\\\\\\\\\\\r\n   \\/\\\\\\ \\/\\\\\\ /\\\\\\ \\/\\\\\\_____/  \\/\\\\\\  \\\\\\  \\\\\\ \\/_______/  \\/\\\\\\    \\/\\\\\\ \\/\\\\\\ \\/\\\\\\ /\\\\\\ \\/\\\\\\_____/\r\n    \\/\\\\\\ \\ /\\\\\\ \\\\\\ \\/\\\\\\        \\/\\\\\\ \\\\\\\\\\ \\\\\\             \\/\\\\\\    \\/\\\\\\ \\/\\\\\\ \\ /\\\\\\ \\\\\\ \\/\\\\\\\r\n     \\/\\\\\\  \\/_\\\\\\\\\\\\ \\/\\\\\\\\\\\\\\\\\\\\ \\/\\\\\\\\\\__/\\\\\\\\\\             \\/_/\\\\\\\\\\\\\\\\\\  \\/\\\\\\  \\/_\\\\\\\\\\\\ \\/\\\\\\\\\\\\\\\\\\\\\r\n      \\/_/    \\/____/  \\/________/  \\/_/      \\/_/                \\/_______/   \\/_/    \\/____/  \\/________/\r\n```\r\n\r\n总结来说，就是实现一个通用的、可复用的控制台「艺术字」打印功能。基于这个目标开发了 [yoo-hoo](https://github.com/alienzhou/yoo-hoo) 这个库。\r\n\r\n下面来说说大致怎么实现。\r\n\r\n## 2. 如何实现\r\n\r\n和其他字体显示的需求类似，我们可以将功能抽象为三个部分：\r\n\r\n1. 字体库的生成\r\n2. 字体的排版\r\n3. 字体的渲染\r\n\r\n这里我们先说一下字体的渲染。\r\n\r\n### 2.1. 字体渲染\r\n\r\n之所以先说这部分，是因为它会影响排版信息的输出格式。\r\n\r\n其实字体渲染这部分并没有什么特别的，我们在控制台这个环境，受限于 API，基本就是使用 `console.log` 来将内容「渲染」到屏幕上。不过，正是这里的「渲染」形式的限制，会倒推我们的排版方式。\r\n\r\n我们知道，控制台基本都是单行顺序渲染的，大致就是「Z」字型。同时，由于我们的「艺术字」会占据多行，所以最终的渲染不是按单个字顺序渲染的，需要先排好版，然后按行来逐步渲染到屏幕上。\r\n\r\n这有点像是咱们常见的打印机。如果你要打印一个苹果，它会从上往下逐步打印出这个苹果，而不是直接像盖章那样\b\b直接印刷一个苹果。\r\n\r\n下面我们会先介绍字体库的生成，而不是紧接挨着的字体排版。因为排版是一个承上启下的过程，当我们确定了上下游环节，这块的逻辑自然也就确定了。\r\n\r\n### 2.2. 字体库生成\r\n\r\n当我们想要实现可复用能力时，因此我们需要找到或者抽象出系统内逻辑上的最小可复用单元 —— 在这里显然就是字符。简单来说，对于输入字符串 `JS` 时，如果我们能找到对应的 J 和 S 的字符表示形式，辅以排版，理论上就有能力实现我们的目标。这有点像是咱们老祖宗的活字印刷术。\r\n\r\n所以在字体库这里，我们会有一个字义与字型的映射。这个其实和咱们前端常见的字体文件内格式的思想一样，都需要有这么一个映射关系。\r\n\r\n字型哪里来呢？好吧，我也是用了一个笨办法 —— 自己「手绘」😂。举个例子，下面就是我「手绘」的 1：\r\n\r\n```text\r\n1\r\n  /\\\\\\\r\n/\\\\\\\\\\\\\r\n\\/__/\\\\\\\r\n    \\/\\\\\\\r\n     \\/\\\\\\\r\n      \\/\\\\\\\r\n      /\\\\\\\\\\\\\\\r\n      \\/_____/\r\n```\r\n\r\n绘制的过程是枯燥的，好再很多字型的局部是有一定复用的，简化了这项繁琐的工作。当然，这只是一次性的工作，一旦创建好一类「字体」，以后就不需要再重复这项工作了。\r\n\r\n我把上面这个内容存在一个单独的文件中，目前直接以 .txt 为后缀，这就是我们的字体原始格式。之所以不放在 .js 中，是因为 JavaScript 中 `\\` 是想要转义的，这样文本的视觉和最后的呈现效果就不一致了，不利于调试和维护。\r\n\r\n原始字体文件分为两部分：\r\n\r\n- 上面第一行是字义，支持一个多个字义对应一个图形。例如 `·` 和 `*` 我使用了同一个图形。多个字义间空格分割，不换行。\r\n- 除去第一行，剩下的内容就是字型。\r\n\r\n理论上，我们可以以这个原始字体文件来作为字体库了，通过 NodeJS 中的 `fs` 模块读取并解析文件内容即可得到映射关系。\r\n\r\n但我希望它也能在非 NodeJS 环境（例如浏览器）中使用，所以不能依赖 `fs` 模块。这里做了一个原始文件的解析脚本，生成对应的 JS 模块。由于我们并不直接维护这些生成的 JS 模块，所以它的可读性不重要，可以设计数据格式的时候可以完全面向后续的排版流程。\r\n\r\n首先实现一个简单的解析器来解析第一行的字义。这也类似一个词法解析器，但由于语法规则极其弱智（简单），所以也就不用多说了，大致如下：\r\n\r\n```typescript\r\nconst parseDefinition = function (line: string) {\r\n    let token = '';\r\n    const defs: string[] = [];\r\n    for (const char of line) {\r\n        if (char === ' ' && token) {\r\n            defs.push(token);\r\n            token = '';\r\n        }\r\n        if (char !== ' ') {\r\n            token += char;\r\n        }\r\n    }\r\n    if (token) {\r\n        defs.push(token);\r\n    }\r\n    return defs;\r\n}\r\n```\r\n\r\n下面就是处理字型部分。之所以需要处理字型，是因为上面提到的转义问题。由于我们在原始格式中使用了 `\\` 来进行字型展示，而将其直接放入生成的 JS 文件中这个 `\\` 就变为了转义符，要想正常展示需要变为 `\\\\`。一种方式是正则匹配，将所有源文本中的 `\\` 替换为 `\\\\` 再写入。但我选择了另一种方式。\r\n\r\n将字符通过 `.charCodeAt` 方法转为 char code 存储，读取字体信息时再通过 `String.fromCharCode` 转回来。原来的字符串变成了数字类型的数组，这样就没有特殊字符的问题了。最后，通过拼接文本并生成 JS 文件来将原始的、利于人维护的字体文件，转成了编译 JS 工作的模块。\r\n\r\n```typescript\r\nconst arrayToString = <T>(arr: T[]) => '[' + arr.map(d => `'${d}'`).join(',') + ']';\r\n\r\nconst text = parsedFonts.reduce((t, f, idx) => {\r\n    return t + (\r\n        '\\n/**\\n'\r\n        + f.content\r\n        + '\\n*/\\n'\r\n        + `fonts[${idx}] = {\\n`\r\n        + `  defs: ${arrayToString(f.defs)},\\n`\r\n        + `  codes: ${arrayToString(f.codes)}\\n`\r\n        + '};\\n'\r\n    );\r\n}, '');\r\nconst moduleText = (\r\n    'const fonts = [];\\n'\r\n    + text\r\n    + 'module.exports.fonts = fonts;\\n'\r\n);\r\n\r\nfs.writeFileSync(fontFilepath, moduleText, 'utf-8');\r\n```\r\n\r\n其中 defs 就是这个字型对应的字义列表，codes 则是字型的 char code 数组，所有的字体都被放在一个 JS 文件中。\r\n\r\n这里提一下，第 3 行的 `parsedFonts` 就是遍历所有原始字体文件解析到的内容，因此得到这部分也是需要通过 NodeJS 的 `fs` 模块来递归读取源文件目录下的字体文件的。算是基操，就不用展开了。\r\n\r\n由于这部分是可以提前解析编译的，一旦生成了 JS 模块后就不会对 NodeJS 运行时有依赖，所以保证了其依然可以运行在浏览器中。\r\n\r\n### 2.3. 字体的排版\r\n\r\n我们的字体格式确定了，目标的渲染方式也确定了。最后就可以填充这部分的逻辑实现了。\r\n\r\n具体排版上会遇到一些细节点，例如不等高字体的空行填充、最大行宽的换行判断（需要用户执行行宽），不过这些都是小点，处理也不太复杂。这里可能介绍一下稍有特殊的一块 —— 字间距调整。\r\n\r\n我们知道，一些艺术字的倾斜程度可能很大，例如这个字符「1」：\r\n\r\n```text\r\n  /\\\\\\\r\n/\\\\\\\\\\\\\r\n\\/__/\\\\\\\r\n    \\/\\\\\\\r\n     \\/\\\\\\\r\n      \\/\\\\\\\r\n      /\\\\\\\\\\\\\\\r\n      \\/_____/\r\n```\r\n\r\n如果按简单的矩形型包围盒来分配空间，大概会是下面这样：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/99935762-69e9a500-2d9c-11eb-82bc-64406030d8fe.png)\r\n\r\n前后两个字体，即使设置为最小间距（0），仍然会距离很远，这样就破坏了一定的显示效果。例如上图中我两个包围盒间距其实只有 1，但看起来就很大。我们实际希望的可能是下面这样：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/99935801-808ffc00-2d9c-11eb-8c66-62e50570aa97.png)\r\n\r\n间距为 1 时，两个字符「1」调整为在最近的地方间距为 1。如果要更宽的效果可以设置更多间距。这个处理起来主要就是需要算出最大的「挤压空间」（即两个盒子最大支持的交叉空间）。最开始渲染的时候说了，我们是按 console 出的行来存储的与打印的，举个例子，这个「1」高度为 8 ，所以渲染的时候就是一个 8 个元素的字符串数组：\r\n\r\n```text\r\nconst lines = [\r\n    '  /\\\\\\',\r\n    '/\\\\\\\\\\\\',\r\n    '\\/__/\\\\\\',\r\n    '    \\/\\\\\\',\r\n    '     \\/\\\\\\',\r\n    '      \\/\\\\\\',\r\n    '      /\\\\\\\\\\\\\\',\r\n    '      \\/_____/',\r\n];\r\n```\r\n\r\n渲染的时候直接 `lines.forEach(l => console.log(l))` 即可。\r\n\r\n> 💣 注意，为了便于读者阅读，上面的 lines 数组内的字符串我没有加上转义，它是不合法的！只是为了展示起来更便于阅读理解，实际中不能这么写。\r\n\r\n最大缩进（缩进这个词不准确，但希望大家能够理解那个意思）的计算只需要知道之前的每个 line 尾部对应有多少空格，同时需要再其后新添加字符每个 line 前面又分别有多少空格，综合两者，再遍历所有的 line 取一个最小值即可：\r\n\r\n```typescript\r\n// calc the prefix space\r\nconst prefixSpace = function (str: string) {\r\n    const matched = /^\\s+/gu.exec(str);\r\n\r\n    return matched ? matched[0].length : 0;\r\n};\r\n\r\n// calc the tail space\r\nconst tailSpace = function (str: string) {\r\n    const matched = /\\s+$/gu.exec(str);\r\n\r\n    return matched ? matched[0].length : 0;\r\n};\r\n\r\n// calc how many spaces need for indent for layout\r\n// overwise the gap between two characters will be different\r\nconst calcIndent = function (lines: string[], charLines: string[]): number {\r\n    // maximum indent that won't break the layout\r\n    let maxPossible = Infinity;\r\n\r\n    for (let i = 1; i < lines.length; i++) {\r\n        const formerTailNum = tailSpace(lines[i]);\r\n        const latterPrefixNum = prefixSpace(charLines[i]);\r\n\r\n        maxPossible = Math.min(maxPossible, formerTailNum + latterPrefixNum);\r\n    }\r\n\r\n    return maxPossible;\r\n};\r\n```\r\n\r\n最后 `calcIndent` 方法返回的就是新字符需要向前缩进（或者说缩紧）的值。最后渲染的时候根据这个值来调整每行连接时添加的空格数即可。\r\n\r\n捎带一提，之前的字体格式 load 进来会被转换为类似字典的格式 —— 字义作为 key，字型等一系列属性作为 value：\r\n\r\n```JavaScript\r\nconst dictionary = {\r\n    'a': {\r\n        lines: [...],\r\n        width: ...,\r\n        height: ...,\r\n    },\r\n    'b': {\r\n        ...\r\n    },\r\n    ...\r\n}\r\n```\r\n\r\n这样遍于 `split` 完用户传入的字符串后，更简单的索引到对应的字型和字体信息。\r\n\r\n### 2.4. 其他\r\n\r\n当然，其他还会有一些工作，包括\r\n\r\n- 支持颜色\r\n- 支持返回排版完的 lines 让用户自己渲染\r\n- 支持用户自定义调整字间距\r\n\r\n这些目前实现上遇到的问题不大，篇幅原因也就不说了。具体的代码可以在 [Github](https://github.com/alienzhou/yoo-hoo) 上看到。\r\n\r\n## 3. 总结\r\n\r\n实现可复用的控制台“艺术字”功能，总的来说并没有太多复杂的点，整体的流程模型就是\r\n\r\n`生成字体库 --> 字体排版 --> 渲染文本`\r\n\r\n这对于前端来说应该是非常好理解的。\r\n\r\n做这个项目也确实是自己在工作中希望给一些库加上这种 logo 或者 banner 展示，但每次重复枯燥的工作确实令人反感。所以想了下可行性之后就搞了 [yoo-hoo](https://www.npmjs.com/package/yoo-hoo) 这么个小玩意儿，如果大家也遇到类似的问题，希望能有所帮助。\r\n\r\n```bash\r\nnpm i yoo-hoo\r\n```\r\n\r\n## 4. 最后\r\n\r\n目前 yoo-hoo@1.0.x 内置了一套 26 个字母（A-Z）、10 个数字（0-9）、`·` `*` `-` `|` 这些字符的字体库。\r\n\r\n考虑到单一的字型和有限的字体量肯定不能满足所有需求，所以开发时代码结构就留下了支持外部扩展的模式。\r\n\r\n后续可以把 2.2 节中的字体源文件解析工具独立出来，支持用户「手绘」自己的字型，用工具生成对应格式后，将字体的 JS 模块传入 `yo` 方法中作为扩展字体加载。\r\n\r\n字体源文件的「手绘」虽有成本，但所见即所得，编写难度不大 🐶 同时也算是一劳永逸。\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/42","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/42/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/42/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/42/events","html_url":"https://github.com/alienzhou/blog/issues/42","id":748524877,"node_id":"MDU6SXNzdWU3NDg1MjQ4Nzc=","number":42,"title":"替代 webpack？带你了解 snowpack 原理","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""},{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-11-23T06:52:41Z","updated_at":"2021-03-01T13:55:30Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"近期，随着 vue3 的各种曝光，[vite](https://github.com/vitejs/vite) 的热度上升，与 vite 类似的 [snowpack](https://github.com/pikapkg/snowpack) 的关注度也逐渐增加了。**目前（2020.06.18）snowpack 在 Github 上已经有了将近 1w stars。**\r\n\r\nsnowpack 的代码很轻量，本文会从实现原理的角度介绍 snowpack 的特点。同时，带大家一起看看，作为一个以原生 JavaScript 模块化为核心的年轻的构建工具，它是如何实现“老牌”构建工具所提供的那些特性的。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/99935319-64d82600-2d9b-11eb-935f-edf098721a3e.png)\r\n\r\n<!-- more -->\r\n\r\n## 1. 初识 snowpack\r\n\r\n近期，随着 vue3 的各种曝光，[vite](https://github.com/vitejs/vite) 的热度上升，与 vite 类似的 [snowpack](https://github.com/pikapkg/snowpack) 的关注度也逐渐增加了。目前（2020.06.18）snowpack 在 Github 上已经有了将近 1w stars。\r\n\r\n时间拨回到 2019 年上半年，一天中午我百无聊赖地读到了 [A Future Without Webpack](https://www.pika.dev/blog/pika-web-a-future-without-webpack) 这篇文章。通过它了解到了 pika/snowpack 这个项目（当时还叫 pika/web）。\r\n\r\n文章的核心观点如下：\r\n\r\n在如今（2019年），我们完全可以抛弃打包工具，而直接在浏览器中使用浏览器原生的 JavaScript 模块功能。这主要基于三点考虑：\r\n\r\n1. 兼容性可接受：基本主流的浏览器版本都支持直接使用 JavaScript Module 了（当然，IE 一如既往除外）。\r\n2. 性能问题的改善：之前打包的一个重要原因是 HTTP/1.1 的特性导致，我们合并请求来优化性能；而如今 HTTP/2 普及之后，这个性能问题不像以前那么突出了。\r\n3. 打包的必要性：打包工具的存在主要就是为了处理模块化与合并请求，而以上两点基本解决这两个问题；再加之打包工具越来越复杂，此消彼长，其存在的必要性自然被作者所质疑。\r\n\r\n---\r\n\r\n由于我认为 webpack 之类的打包工具，“发家”后转型做构建工具并非最优解，实是一种阴差阳错的阶段性成果。所以当时对这个项目提到的观点也很赞同，其中印象最深的当属它提到的：\r\n\r\n> In 2019, you should use a bundler because you want to, not because you need to.\r\n\r\n同时，我也认为，打包工具(Bundler) ≠ 构建工具(Build Tools) ≠ 工程化。\r\n\r\n## 2. 初窥 snowpack\r\n\r\n看到这片文章后（大概是19年6、7月？），抱着好奇立刻去 Github 上读了这个项目。当时看这个项目的时候大概是 0.4.x 版本，其源码和功能都非常简单。\r\n\r\nsnowpack 的最初版核心目标就是方便开发者使用浏览器原生的 JavaScript Module 能力。所以从它的处理流程上来看，**对业务代码的模块，基本只需要把 ESM 发布（拷贝）到发布目录，再将模块导入路径从源码路径换为发布路径即可。**\r\n\r\n而对 node_modules 则通过遍历 package.json 中的依赖，按该依赖列表为粒度将 node_modules 中的依赖打包。**以 node_modules 中每个包的入口作为打包 entry，使用 rollup 生成对应的 ESM 模块文件，放到 web_modules 目录中，最后替换源码的 import 路径，是得可以通过原生 JavaScript Module 来加载 node_modules 中的包。**\r\n\r\n```diff\r\n- import { createElement, Component } from \"preact\";\r\n- import htm from \"htm\";\r\n+ import { createElement, Component } from \"/web_modules/preact.js\";\r\n+ import htm from \"/web_modules/htm.js\";\r\n```\r\n\r\n从 [v0.4.0 版本的源码](https://github.com/pikapkg/snowpack/blob/v0.4.0/src/index.ts) 可以看出，其初期功能确实非常简单，甚至有些简陋，以至于缺乏很多现代前端开发所需的特性，明显是不能用于生产环境的。\r\n\r\n直观感受来说，它当时就欠缺以下能力：\r\n\r\n1. import CSS / image / …：由于 webpack 一切皆模块的理念 + 组件化开发的深入人心，import anything 的书写模式已经深入开发者的观念中。对 CSS 等内容依赖与加载能力的缺失，将成为它的阿克琉斯之踵。\r\n2. 语法转换能力：作为目标成为构建工具的 snowpack（当时叫 web），并没有能够编译 Typescript、JSX 等语法文件的能力，你当然可以再弄一个和它毫无关系的工具来处理语法，但是，这不就是构建工具应该集成的么？\r\n3. HMR：这可能不那么要命，但俗话说「由俭入奢易，由奢入俭难」，被“惯坏”开发者们自然会有人抵触这一特性的缺失。\r\n4. 性能：虽说它指出，上了 HTTP2 后，使用 JavaScript modules 性能并不会差，但毕竟没有实践过，对此还是抱有怀疑。\r\n5. 环境变量：这虽然是一个小特性，但在我接触过的大多数项目中都会用到它，它可以帮助开发者自动测卸载线上代码中的调试工具，可以根据环境判断，自动将埋点上报到不同的服务上。确实需要一个这样好用的特性。\r\n\r\n## 3. snowpack 的进化\r\n\r\n时间回到 2020 年上半年，随着 vue3 的不断曝光，与其有一定关联的另一个项目 vite 也逐渐吸引了人们的目光。而其[介绍中提到的 snowpack](https://github.com/vitejs/vite#how-is-this-different-from-snowpack) 也突然吸引到了更多的热度与讨论。当时我只是对 pika 感到熟悉，好奇的点开 snowpack 项目主页的时候，才发现这个一年前初识的项目（pika/web）已经升级到了 pika/snowpack v2。而项目源码也不再是之前那唯一而简单的 index.ts，在核心代码外，还包含了诸多官方插件。\r\n\r\n看着已经完全变样的 Readme，我的第一直觉是，之前我想到的那些问题，应该已经有了解决方案。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/99935332-702b5180-2d9b-11eb-93e6-26b8efca9160.png)\r\n\r\n抱着学习的态度，对它进行重新了解之后，发现果然如此。好奇心趋势我对它的解决方案去一探究竟。\r\n\r\n> 本文写于 2020.06.18，源码基于 [snowpack@2.5.1](https://github.com/pikapkg/snowpack/tree/v2.5.1)\r\n\r\n### 3.1. import CSS\r\n\r\nimport CSS 的问题还有一个更大的范围，就是非 JavaScript 资源的加载，包括图片、JSON 文件、文本等。\r\n\r\n先说说 CSS。\r\n\r\n```JavaScript\r\nimport './index.css';\r\n```\r\n\r\n上面这种语法目前浏览是不支持的。所以 snowpack 用了一个和之前 webpack 很类似的方式，将 CSS 文件变为用于注入样式的 JS 模块。如果你熟悉 webpack，肯定知道如果你只是在 loader 中处理 CSS，那么并不会生成单独的 CSS 文件（这就是为什么会有 [`mini-css-extract-plugin`](https://webpack.js.org/plugins/mini-css-extract-plugin/)），而是加载一个 JS 模块，然后在 JS 模块中通过 DOM API 将 CSS 文本作为 style 标签的内容插入到页面中。\r\n\r\n为此，snowpack 自己写了一个简单的模板方法，生成将 CSS 样式注入页面的 JS 模块。下面这段代码可以实现样式注入的功能：\r\n\r\n```JavaScript\r\nconst code = '.test { height: 100px }';\r\nconst styleEl = document.createElement(\"style\");\r\nconst codeEl = document.createTextNode(code);\r\nstyleEl.type = 'text/css';\r\nstyleEl.appendChild(codeEl);\r\ndocument.head.appendChild(styleEl);\r\n```\r\n\r\n可以看到，除了第一行式子的右值，其他都是不变的，因此可以很容易生成一个符合需求的 JS 模块：\r\n\r\n```JavaScript\r\nconst jsContent = `\r\n  const code = ${JSON.stringify(code)};\r\n  const styleEl = document.createElement(\"style\");\r\n  const codeEl = document.createTextNode(code);\r\n  styleEl.type = 'text/css';\r\n  styleEl.appendChild(codeEl);\r\n  document.head.appendChild(styleEl);\r\n`;\r\n\r\nfs.writeFileSync(filename, jsContent);\r\n```\r\n\r\nsnowpack 中的[实现代码](https://github.com/pikapkg/snowpack/blob/v2.5.1/src/commands/build-util.ts#L146-L169)比我们上面多了一些东西，不过与样式注入无关，这个放到后面再说。\r\n\r\n通过将 CSS 文件的内容保存到 JS 变量，然后再使用 JS 调用 DOM API 在页面注入 CSS 内容即可使用 JavaScript Modules 的能力加载 CSS。而源码中的 `index.css` 也会被替换为 `index.css.proxy.js`：\r\n\r\n```diff\r\n- import './index.css';\r\n+ import './index.css.proxy.js';\r\n```\r\n\r\nproxy 这个名词之后会多次出现，因为为了能够以模块化方式导入非 JS 资源，snowpack 把生成的中间 JavaScript 模块都叫做 proxy。这种实现方式也几乎和 webpack 一脉相承。\r\n\r\n### 3.2. 图片的 import\r\n\r\n在目前的前端开发场景中，还有一类非常典型的资源就是图片。\r\n\r\n```JavaScript\r\nimport avatar from './avatar.png';\r\n\r\nfunction render() {\r\n    return (\r\n        <div class=\"user\">\r\n            <img src={avatar} />\r\n        </div>\r\n    );\r\n}\r\n```\r\n\r\n上面代码的书写方式已经普遍应用在很多项目代码中了。那么 snowpack 是怎么处理的呢？\r\n\r\n太阳底下没有新鲜事，snowpack 和 webpack 一样，对于代码中导入的 `avatar` 变量，最后其实都是该静态资源的 URI。\r\n\r\n我们以 snowpack 提供的官方 React 模版为例来看看图片资源的引入处理。\r\n\r\n> `npx create-snowpack-app snowpack-test --template @snowpack/app-template-react`\r\n\r\n初始化模版运行后，可以看到源码与构建后的代码差异如下：\r\n\r\n```diff\r\n- import React, { useState } from 'react';\r\n- import logo from './logo.svg';\r\n- import './App.css';\r\n\r\n+ import React, { useState } from '/web_modules/react.js';\r\n+ import logo from './logo.svg.proxy.js';\r\n+ import './App.css.proxy.js';\r\n```\r\n\r\n与 CSS 类似，也为图片（svg）生成了一个 JS 模块 logo.svg.proxy.js，其模块内容为：\r\n\r\n```JavaScript\r\n// logo.svg.proxy.js\r\nexport default \"/_dist_/logo.svg\";\r\n```\r\n\r\n套路与 webpack 如出一辙。以 build 命令为例，我们来看一下 snowpack 的处理方式。\r\n\r\n首先是将源码中的静态文件（logo.svg）[拷贝到发布目录](https://github.com/pikapkg/snowpack/blob/master/src/commands/build.ts#L219)：\r\n\r\n```JavaScript\r\nallFiles = glob.sync(`**/*`, {\r\n    ...\r\n});\r\nconst allBuildNeededFiles: string[] = [];\r\nawait Promise.all(\r\n    allFiles.map(async (f) => {\r\n        f = path.resolve(f); // this is necessary since glob.sync() returns paths with / on windows.  path.resolve() will switch them to the native path separator.\r\n        ...\r\n        return fs.copyFile(f, outPath);\r\n    }),\r\n);\r\n```\r\n\r\n然后，我们可以看到 snowpack 中的一个叫 `transformEsmImports` 的关键方法调用。这个方法可以将源码 JS 中 import 的模块路径进行转换。例如对 node_modules 中的导入都替换为 web_modules。在这里[对 svg 文件的导入名也会被加上 `.proxy.js`](https://github.com/pikapkg/snowpack/blob/master/src/commands/build.ts#L315-L317)：\r\n\r\n```JavaScript\r\ncode = await transformEsmImports(code, (spec) => {\r\n    ……\r\n    if (spec.startsWith('/') || spec.startsWith('./') || spec.startsWith('../')) {\r\n        const ext = path.extname(spec).substr(1);\r\n        if (!ext) {\r\n            ……\r\n        }\r\n        const extToReplace = srcFileExtensionMapping[ext];\r\n        if (extToReplace) {\r\n            ……\r\n        }\r\n        if (spec.endsWith('.module.css')) {\r\n            ……\r\n        } else if (!isBundled && (extToReplace || ext) !== 'js') {\r\n            const resolvedUrl = path.resolve(path.dirname(outPath), spec);\r\n            allProxiedFiles.add(resolvedUrl);\r\n            spec = spec + '.proxy.js';\r\n        }\r\n        return spec;\r\n    }\r\n    ……\r\n});\r\n```\r\n\r\n此时，我们的 svg 文件和源码的导入语法（`import logo from './logo.svg.proxy.js'`）均已就绪，最后剩下的就是[生成 proxy 文件](https://github.com/pikapkg/snowpack/blob/master/src/commands/build.ts#L359-L369)了。也非常简单：\r\n\r\n```JavaScript\r\nfor (const proxiedFileLoc of allProxiedFiles) {\r\n    const proxiedCode = await fs.readFile(proxiedFileLoc, {encoding: 'utf8'});\r\n    const proxiedExt = path.extname(proxiedFileLoc);\r\n    const proxiedUrl = proxiedFileLoc.substr(buildDirectoryLoc.length);\r\n    const proxyCode = wrapEsmProxyResponse({\r\n      url: proxiedUrl,\r\n      code: proxiedCode,\r\n      ext: proxiedExt,\r\n      config,\r\n    });\r\n    const proxyFileLoc = proxiedFileLoc + '.proxy.js';\r\n    await fs.writeFile(proxyFileLoc, proxyCode, {encoding: 'utf8'});\r\n }\r\n```\r\n\r\n`wrapEsmProxyResponse` 是一个生成 proxy 模块的方法，目前只处理包括 JSON、image 和其他类型的文件，对于其他类型（包括了图片），就是非常简单的[导出 url](https://github.com/pikapkg/snowpack/blob/v2.5.1/src/commands/build-util.ts#L168)：\r\n\r\n```JavaScript\r\nreturn `export default ${JSON.stringify(url)};`;\r\n```\r\n\r\n所以，对于 CSS 与图片，由于浏览器模块规范均不支持该类型，所以都会转换为 JS 模块，这块 snowpack 和 webpack 实现很类似。\r\n\r\n### 3.3. HMR（热更新）\r\n\r\n如果你刚才仔细去看了 `wrapEsmProxyResponse` 方法，会发现对于 CSS “模块”，它除了有注入 CSS 的功能代码外，还多着这么几行：\r\n\r\n```JavaScript\r\nimport * as __SNOWPACK_HMR_API__ from '/${buildOptions.metaDir}/hmr.js';\r\nimport.meta.hot = __SNOWPACK_HMR_API__.createHotContext(import.meta.url);\r\nimport.meta.hot.accept();\r\nimport.meta.hot.dispose(() => {\r\n  document.head.removeChild(styleEl);\r\n});\r\n```\r\n\r\n这些代码就是用来实现热更新的，也就是 HMR（Hot Module Reload）。它使得当一个模块更新时，应用会在前端自动替换该模块，而不需要 reload 整个页面。这对于依赖状态构建的单页应用开发非常友好。\r\n\r\n`import.meta` 是一个包含模块元信息的对象，例如模块自身的 url 就可以在这里面取到。而 HMR 其实和 `import.meta` 没太大关系，snowpack 只是借用这块地方存储了 HMR 相关功能对象。所以不必过分纠结于它。\r\n\r\n我们再来仔细看看上面这段 HMR 的功能代码，API 是不是很熟悉？可下面这段对比一下\r\n\r\n```diff\r\nimport _ from 'lodash';\r\nimport printMe from './print.js';\r\n\r\nfunction component() {\r\n  const element = document.createElement('div');\r\n  const btn = document.createElement('button');\r\n\r\n  element.innerHTML = _.join(['Hello', 'webpack'], ' ');\r\n\r\n  btn.innerHTML = 'Click me and check the console!';\r\n  btn.onclick = printMe;\r\n\r\n  element.appendChild(btn);\r\n\r\n  return element;\r\n}\r\n\r\ndocument.body.appendChild(component());\r\n+\r\n+ if (module.hot) {\r\n+   module.hot.accept('./print.js', function() {\r\n+     console.log('Accepting the updated printMe module!');\r\n+     printMe();\r\n+   })\r\n+ }\r\n```\r\n\r\n上面的代码取自 webpack 官网上 HMR 功能的[使用说明](https://webpack.js.org/guides/hot-module-replacement/)，可见，snowpack 站在“巨人”的肩膀上，沿袭了 webpack 的 API，其原理也及其相似。网上关于 webpack HMR 的讲解文档很多，这里就不细说了，基本的实现原理就是：\r\n\r\n- snowpack 进行构建，并 watch 源码；\r\n- 在 snowpack 服务端与前端应用间建立 websocket 连接；\r\n- 当源码变动时，重新构建，完成后通过 websocket 将模块信息（id/url）推送给前端应用；\r\n- 前端应用监听到这个消息后，根据模块信息加载模块\r\n- 同时，触发该模块之前注册的回调事件，这个在以上代码中就是传入 `accept` 和 `dispose` 中的方法\r\n\r\n因此，`wrapEsmProxyResponse` 里构造出的这段代码\r\n\r\n```JavaScript\r\nimport.meta.hot.dispose(() => {\r\n  document.head.removeChild(styleEl);\r\n});\r\n```\r\n\r\n其实就是表示，当该 CSS 更新并要被替换时，需要移除之前注入的样式。而执行顺序是：远程模块 --> 加载完毕 --> 执行旧模块的 accept 回调 --> 执行旧模块的 dispose 回调。\r\n\r\nsnowpack 中 HMR 前端核心代码放在了 [`assets/hmr.js`](https://github.com/pikapkg/snowpack/blob/v2.5.1/assets/hmr.js)。代码也非常简短，其中值得一提的是，不像 webpack 使用向页面添加 script 标签来加载新模块，snowpack 直接使用了原生的 dynamic import 来[加载新模块](https://github.com/pikapkg/snowpack/blob/v2.5.1/assets/hmr.js#L109-L112)：\r\n\r\n```JavaScript\r\nconst [module, ...depModules] = await Promise.all([\r\n  import(id + `?mtime=${updateID}`),\r\n  ...deps.map((d) => import(d + `?mtime=${updateID}`)),\r\n]);\r\n```\r\n\r\n也是秉承了使用浏览器原生 JavaScript Modules 能力的理念。\r\n\r\n---\r\n\r\n小憩一下。看完上面的内容，你是不是发现，这些技术方案都和 webpack 的实现非常类似。snowpack 正是借鉴了这些前端开发的优秀实践，而其一开始的理念也很明确：**为前端开发提供一个不需要打包器（Bundler）的构建工具。**\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/99935359-7de0d700-2d9b-11eb-9960-084a9af6a686.png)\r\n\r\nwebpack 的一大知识点就是优化，既包括构建速度的优化，也包括构建产物的优化。其中一个点就是如何拆包。webpack v3 之前有 CommonChunkPlugin，v4 之后通过 SplitChunk 进行配置。使用声明式的配置，比我们人工合包拆包更加“智能”。合并与拆分是为了减少重复代码，同时增加缓存利用率。但如果本身就不打包，自然这两个问题就不再存在。而如果都是直接加载 ESM，那么 Tree-Shaking 的所解决的问题也在一定程度上也被缓解了（当然并未根治）。\r\n\r\n再结合最开始提到的性能与兼容性，如果这两个坎确实迈了过去，那我们何必要用一个内部流程复杂、上万行代码的工具来解决一个不再存在的问题呢？\r\n\r\n好了，让我们回来继续聊聊 snowpack 里其他特性的实现。\r\n\r\n---\r\n\r\n### 3.4. 环境变量\r\n\r\n通过环境来判断是否关闭调试功能是一个非常常见的需求。\r\n\r\n```JavaScript\r\nif (process.env.NODE_ENV === 'production') {\r\n  disableDebug();\r\n}\r\n```\r\n\r\nsnowpack 中也实现了环境变量的功能。从使用文档上来看，你可以在模块中的 `import.meta.env` 上取到变量。像下面这么使用：\r\n\r\n```JavaScript\r\nif (import.meta.env.NODE_ENV === 'production') {\r\n  disableDebug();\r\n}\r\n```\r\n\r\n那么环境变量是如何被注入进去的呢？\r\n\r\n还是以 build 的源码为例，在代码生成的阶段上，通过 [`wrapImportMeta` 方法的调用](https://github.com/pikapkg/snowpack/blob/v2.5.1/src/commands/build.ts#L346)生成了新的代码段，\r\n\r\n```JavaScript\r\ncode = wrapImportMeta({code, env: true, hmr: false, config});\r\n```\r\n\r\n那么经过 `wrapImportMeta` 处理后的代码和之前有什么区别呢？答案从源码里就能知晓：\r\n\r\n```JavaScript\r\nexport function wrapImportMeta({\r\n  code,\r\n  hmr,\r\n  env,\r\n  config: {buildOptions},\r\n}: {\r\n  code: string;\r\n  hmr: boolean;\r\n  env: boolean;\r\n  config: SnowpackConfig;\r\n}) {\r\n  if (!code.includes('import.meta')) {\r\n    return code;\r\n  }\r\n  return (\r\n    (hmr\r\n      ? `import * as  __SNOWPACK_HMR__ from '/${buildOptions.metaDir}/hmr.js';\\nimport.meta.hot = __SNOWPACK_HMR__.createHotContext(import.meta.url);\\n`\r\n      : ``) +\r\n    (env\r\n      ? `import __SNOWPACK_ENV__ from '/${buildOptions.metaDir}/env.js';\\nimport.meta.env = __SNOWPACK_ENV__;\\n`\r\n      : ``) +\r\n    '\\n' +\r\n    code\r\n  );\r\n}\r\n```\r\n\r\n对于包含 `import.meta` 调用的代码，snowpack 都会在里面注入对 `env.js` 模块的导入，并将导入值赋在 `import.meta.env` 上。因此构建后的代码会变为：\r\n\r\n```diff\r\n+ import __SNOWPACK_ENV__ from '/__snowpack__/env.js';\r\n+ import.meta.env = __SNOWPACK_ENV__;\r\n\r\nif (import.meta.env.NODE_ENV === 'production') {\r\n    disableDebug();\r\n}\r\n```\r\n\r\n如果是在开发环境下，还会加上 `env.js` 的 HMR。而 `env.js` 的内容也很简单，就是直接将 env 中的键值作为对象的键值，通过 `export default` 导出。\r\n\r\n默认情况下 `env.js` 只包含 MODE 和 NODE_ENV 两个值，你可以通过 @snowpack/plugin-dotenv 插件来直接读取 `.env` 相关文件。\r\n\r\n### 3.5. CSS Modules 的支持\r\n\r\nCSS 的模块化一直是一个难题，其一个重要的目的就是做 CSS 样式的隔离。常用的解决方案包括：\r\n\r\n- 使用 BEM 这样的命名方式\r\n- 使用 webpack 提供的 CSS Module 功能\r\n- 使用 styled components 这样的 CSS in JS 方案\r\n- shadow dom 的方案\r\n\r\n我之前的[文章](https://juejin.im/post/5b20e8e0e51d4506c60e47f5)详细介绍了这几类方案。snowpack 也提供了类似 webpack 中的 CSS Modules 功能。\r\n\r\n```JavaScript\r\nimport styles from './index.module.css' \r\n\r\nfunction render() {\r\n    return <div className={styles.main}>Hello world!</div>;\r\n}\r\n```\r\n\r\n而在 snowpack 中启用 CSS Module 必须要以 `.module.css` 结尾，只有这样才会[将文件特殊处理](https://github.com/pikapkg/snowpack/blob/v2.5.1/src/commands/build.ts#L310-L313)：\r\n\r\n```JavaScript\r\nif (spec.endsWith('.module.css')) {\r\n    const resolvedUrl = path.resolve(path.dirname(outPath), spec);\r\n    allCssModules.add(resolvedUrl);\r\n    spec = spec.replace('.module.css', '.css.module.js');\r\n}\r\n```\r\n\r\n而所有 CSS Module 都会经过 `wrapCssModuleResponse` 方法的[包装](https://github.com/pikapkg/snowpack/blob/v2.5.1/src/commands/build.ts#L362-L367)，其主要作用就是将生成的唯一 class 名的 token 注入到文件内，并作为 default 导出：\r\n\r\n```\r\n_cssModuleLoader = _cssModuleLoader || new (require('css-modules-loader-core'))();\r\nconst {injectableSource, exportTokens} = await _cssModuleLoader.load(code, url, undefined, () => {\r\n    throw new Error('Imports in CSS Modules are not yet supported.');\r\n});\r\nreturn `\r\n    ……\r\n    export let code = ${JSON.stringify(injectableSource)};\r\n    let json = ${JSON.stringify(exportTokens)};\r\n    export default json;\r\n    ……\r\n`;\r\n```\r\n\r\n这里我将 HMR 和样式注入的代码省去了，只保留了 CSS Module 功能的部分。可以看到，它其实是借力了 [css-modules-loader-core](https://www.npmjs.com/package/css-modules-loader-core) 来实现的 CSS Module 中 token 生成这一核心能力。\r\n\r\n以创建的 React 模版为例，将 App.css 改为 App.module.css 使用后，代码中会多处如下部分：\r\n\r\n```diff\r\n+ let json = {\"App\":\"_dist_App_module__App\",\"App-logo\":\"_dist_App_module__App-logo\",\"App-logo-spin\":\"_dist_App_module__App-logo-spin\",\"App-header\":\"_dist_App_module__App-header\",\"App-link\":\"_dist_App_module__App-link\"};\r\n+ export default json;\r\n```\r\n\r\n对于导出的默认对象，键为 CSS 源码中的 classname，而值则是构建后实际的 classname。\r\n\r\n### 3.6. 性能问题\r\n\r\n还记得[雅虎性能优化 35 条军规](https://github.com/creeperyang/blog/issues/1)么？其中就提到了通过合并文件来减少请求数。这既是因为 TCP 的慢启动特点，也是因为浏览器的并发限制。而伴随这前端富应用需求的增多，前端页面再也不是手工引入几个 script 脚本就可以了。同时，浏览器中 JS 原生的模块化能力缺失也让算是火上浇油，到后来再加上 npm 的加持，打包工具呼之欲出。webpack 也是那个时代走过来的产物。\r\n\r\n随着近年来 HTTP/2 的普及，5G 的发展落地，浏览器中 JS 模块化的不断发展，这个合并请求的“真理”也许值得我们再重新审视一下。去年 PHILIP WALTON 在博客上发的「[Using Native JavaScript Modules in Production Today](https://philipwalton.com/articles/using-native-javascript-modules-in-production-today/)」就推荐大家可以在生产环境中尝试使用浏览器原生的 JS 模块功能。\r\n\r\n「Using Native JavaScript Modules in Production Today」 这片文章提到，根据之前的测试，非打包代码的性能较打包代码要差很多。但该实验有偏差，同时随着近期的优化，非打包的性能也有了很大提升。其中推荐的实践方式和 snowpack 对 node_modules 的处理基本如出一辙。保证了加载不会超过 100 个模块和 5 层的深度。\r\n\r\n同时，由于业务技术形态的原因，我所在的业务线经历了一次构建工具迁移，对于模块的处理上也用了类似的策略：业务代码模块不合并，只打包 node_modules 中的模块，都走 HTTP/2。但是没有使用原生模块功能，只是模块的分布状态与 snowpack 和该文中提到的类似。从上线后的性能数据来看，性能并未下降。当然，由于并非使用原生模块功能来加载依赖，所以并不全完相同。但也算有些参考价值。\r\n\r\n### 3.7. JSX / Typescript / Vue / Less …\r\n\r\n对于非标准的 JavaScript 和 CSS 代码，在 webpack 中我们一般会用 babel、less 等工具加上对应的 loader 来处理。最初版的 snowpack 并没有对这些语法的处理能力，而是推荐将相关的功能外接到 snowpack 前，先把代码转换完，再交给 snowpack 构建。\r\n\r\n而新版本下，snowpack 已经内置了 JSX 和 Typescript 文件的处理。对于 typescript，snowpack 其实用了 typescript 官方提供的 tsc 来编译。对于 JSX 则是通过 [@snowpack/plugin-babel](https://www.npmjs.com/package/@snowpack/plugin-babel) 进行编译，其实际上只是对 @babel/core 的一层简单包装，机上 babel 相关配置即可完成 JSX 的编译。\r\n\r\n```JavaScript\r\nconst babel = require(\"@babel/core\");\r\n\r\nmodule.exports = function plugin(config, options) {\r\n  return {\r\n    defaultBuildScript: \"build:js,jsx,ts,tsx\",\r\n    async build({ contents, filePath, fileContents }) {\r\n      const result = await babel.transformAsync(contents || fileContents, {\r\n        filename: filePath,\r\n        cwd: process.cwd(),\r\n        ast: false,\r\n      });\r\n\r\n      return { result: result.code };\r\n    },\r\n  };\r\n};\r\n```\r\n\r\n从上面可以看到，核心就是调用了 `babel.transformAsync` 方法。而使用 [@snowpack/app-template-react-typescript](https://github.com/pikapkg/create-snowpack-app/tree/master/templates/app-template-react-typescript) 模板生成的项目，依赖了一个叫 @snowpack/app-scripts-react 的包，它里面就使用了 @snowpack/plugin-babel，且相关的 babel.config.json 如下：\r\n\r\n```JavaScript\r\n{\r\n  \"presets\": [[\"@babel/preset-react\"], \"@babel/preset-typescript\"],\r\n  \"plugins\": [\"@babel/plugin-syntax-import-meta\"]\r\n}\r\n```\r\n\r\n对于 Vue 项目 snowpack 也提供了一个对应的插件 [@snowpack/plugin-vue](https://www.npmjs.com/package/@snowpack/plugin-vue) 来打通构建流程，如果去看下该插件，核心是使用的 [@vue/compiler-sfc](https://www.npmjs.com/package/@vue/compiler-sfc) 来进行 vue 组件的编译。\r\n\r\n此外，对于 Sass（Less 也类似），snowpack 则推荐使用者添加相应的 script 命令：\r\n\r\n```JavaScript\r\n\"scripts\": {\r\n  \"run:sass\": \"sass src/css:public/css --no-source-map\",\r\n  \"run:sass::watch\": \"$1 --watch\"\r\n}\r\n```\r\n\r\n所以实际上对于 Sass 的编译直接使用了 sass 命令，snowpack 只是按其约定语法对后面的指令进行执行。这有点类似 gulp / grunt，你在 scripts 中定义的是一个简单的“工作流”。\r\n\r\n综合 ts、jsx、vue、sass 这些语法处理的方式可以发现，snowpack 在这块自己实现的不多，主要依靠“桥接”已有的各种工具，用一种方式将其融入到自己的系统中。与此类似的，webpack 的 loader 也是这一思想，例如 babel-loader 就是 webpack 和 babel 的桥。说到底，还是指责边界的问题。如果目标是成为前端开发的构建工具，你可以不去实现已有的这些子构建过程，但需要将其融入到自己的体系里。\r\n\r\n也正是因为近年来前端构建工具的繁荣，让 snowpack 可以找到各类借力的工具，轻量级地实现了构建流程。\r\n\r\n## 4. 最后聊聊\r\n\r\nsnowpack 的一大特点是快 —— 全量构建快，增量构建也快。因为不需要打包，所以它不需要像 webpack 那样构筑一个巨大的依赖图谱，并根据依赖关系进行各种合并、拆分计算。snowpack 的增量构建基本就是改动一个文件就处理这个文件即可，模块之间算是“松散”的耦合。\r\n\r\n而 webpack 还有一大痛点就是“外部“依赖的处理，“外部”依赖是指：\r\n\r\n- 模块 A 运行时对 B 是有依赖关系\r\n- 但是不希望在 A 构建阶段把 B 也拿来一起构建\r\n\r\n这时候 B 就像是“外部”依赖。在之前典型的一个解决方式就是 external，当然还可以通过使用前端加载器加载 UMD、AMD 包。或者更进一步，在 webpack 5 中使用 Module Federation 来实现。这一需求的可能场景就是微前端。各个前端微服务如果要统一一起构建，必然会随着项目的膨胀构建越来越慢，所以独立构建，动态加载运行的需求也就出现了。\r\n\r\n对于打包器来说，`import 'B.js'` 默认其实就是需要将 B 模块打包进来，所以我们才需要那么多“反向”的配置将这种默认行为禁止掉，同时提供一个预期的运行时方案。而如果站在原生 JavaScript Module 的工作方式上来说，`import '/dist/B.js'` 并不需要在构建的时候获取 B 模块，而只是在运行时才有耦合关系。其天生就是构建时非依赖，运行时依赖的。当然，目前 snowpack 在构建时如果缺少的依赖模块仍然会抛出错误，但上面所说的本质上是可实现，难度较打包器会低很多，而且会更符合使用者的直觉。\r\n\r\n那么 snowpack 是 bundleless 的么？我们可以从这几个方面来看：\r\n\r\n- 它对业务代码的处理是 bundleless 的\r\n- 目前对 node_modules 的处理是做了 bundle 的\r\n- 它仍然提供了 @snowpack/plugin-webpack / @snowpack/plugin-parcel 这样的插件来让你能[为生产环境做打包](https://www.snowpack.dev/#bundle-for-production)。所以，配合 module/nomodule 技术，它将会有更强的抵御兼容性问题的能力，这也算是一种渐进式营销手段\r\n\r\n最后，还是那句话：\r\n\r\n**In 2019, you should use a bundler because you want to, not because you need to.**","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/39","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/39/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/39/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/39/events","html_url":"https://github.com/alienzhou/blog/issues/39","id":612641497,"node_id":"MDU6SXNzdWU2MTI2NDE0OTc=","number":39,"title":"lookup-dns-cache 相关调研","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":2045616625,"node_id":"MDU6TGFiZWwyMDQ1NjE2NjI1","url":"https://api.github.com/repos/alienzhou/blog/labels/Node.js","name":"Node.js","color":"c3ea81","default":false,"description":""},{"id":1159855196,"node_id":"MDU6TGFiZWwxMTU5ODU1MTk2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%9C%8D%E5%8A%A1%E7%AB%AF","name":"服务端","color":"0bbaae","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-05-05T14:21:00Z","updated_at":"2020-05-08T08:18:51Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 引言\r\n\r\n近期在做一个 DNS 服务器切换的演练中发现我们在 NodeJS 中使用的 axios 以及默认的 `dns.lookup` 方法存在一些问题，会导致切换过程中的响应耗时从 ~80ms 上升至 ~3min（具体参见[node中请求超时的一些坑](https://acemood.github.io/2020/05/02/node%E4%B8%AD%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/)）。计划的部分解决方案是使用 lookup-dns-cache 来替换默认的 `dns.lookup` 方法。\r\n\r\n## 需要解答的疑问\r\n\r\n如果使用 lookup-dns-cache 来替换默认的 `dns.lookup`，需要确认以下三个问题：\r\n\r\n1. 使用该 package 后，DNS 查询与缓存的具体实现细节是怎样的？\r\n1. 使用该 package 后是否与 `dns.lookup` 一样，在 Linux 上也使用 resolv.conf 配置？\r\n1. 使用 lookup-dns-cache 后无法控制 timeout 值\r\n\r\n下面基于 [NodeJS v12.16.3](https://github.com/nodejs/node/tree/v12.16.3) 分别对这三个问题进行分析。\r\n\r\n## TL;DR\r\n\r\n1. lookup-dns-cache 在 JS 这一层做了防止重复请求和缓存两处优化\r\n1. lookup-dns-cache 最底层也使用了 resolv.conf 这个配置\r\n1. 使用 lookup-dns-cache 后无法控制 timeout 值\r\n\r\n## 问题一：查询与缓存实现细节\r\n\r\n[lookup-dns-cache](https://www.npmjs.com/package/lookup-dns-cache) 整体代码量很少，DNS 查询相关功能都委托给了 `dns.resolve*` 方法。[与 `dns.lookup` 不同](https://nodejs.org/docs/latest-v10.x/api/dns.html#dns_implementation_considerations)，`dns.resolve*` 并不使用 `getaddrinfo`，并且是异步实现。\r\n\r\nlookup-dns-cache 主要是在 `dns.resolve*` 之上提供了两个优化点：\r\n\r\n1. 避免额外的并行请求：对同一个 hostname 的并行查询，在查询请求未结束前，只会执行一次 `dns.resolve*`，其余放置在回调队列；\r\n1. DNS 查询结果的缓存：提供基于 TTL 的缓存能力。\r\n\r\n### 1 - 避免额外的并行请求\r\n\r\n该处主要是用过 `TasksManager` 来实现。[实现很简单](https://github.com/eduardbcom/lookup-dns-cache/blob/2.1.0/src/TasksManager.js)，发起 DNS 查询时，用 Map 存储当前正在进行查询的 hostname，查询结束后，从 Map 中删除。具体调用则在 Lookup.js 的 [`_innerResolve` 中](https://github.com/eduardbcom/lookup-dns-cache/blob/2.1.0/src/Lookup.js#L200-L218)：\r\n\r\n```JavaScript\r\nlet task = this._tasksManager.find(key);\r\n\r\nif (task) {\r\n  task.addResolvedCallback(callback);\r\n} else {\r\n  task = new ResolveTask(hostname, ipVersion);\r\n  this._tasksManager.add(key, task);\r\n  task.on('addresses', addresses => {\r\n    this._addressCache.set(key, addresses);\r\n  });\r\n  task.on('done', () => {\r\n    this._tasksManager.done(key);\r\n  });\r\n  task.addResolvedCallback(callback);\r\n  task.run();\r\n}\r\n```\r\n\r\n其中的 key 是通过 ``${hostname}_${ipVersion}`` 拼接而成（ipVersion:ipv4/ipv4）。可以看到，如果在 `TasksManager` 实例中找到 task，则只添加回调，否则就发起一个查询，即创建一个 `ResolveTask` 实例。\r\n\r\n### 2 - DNS 缓存\r\n\r\nlookup-dns-cache 通过为 resolve* 方法设置 `ttl: true` 来让 DNS 查询结果返回 TTL 值。对于查询回来的结果会在当前时间基础上[加上 TTL 来作为过期时间](https://github.com/eduardbcom/lookup-dns-cache/blob/2.1.0/src/ResolveTask.js#L82-L85)：\r\n\r\n```JavaScript\r\naddresses.forEach(address => {\r\n  address.family = this._ipVersion;\r\n  address.expiredTime = Date.now() + address.ttl * 1000;\r\n});\r\n```\r\n\r\n当进行 DNS 查询前，会先查缓存，如果存在则直接返回。而在 AddressCache 中进行缓存查询时，[如果判断当前时间超过过期时间，则不再返回缓存结果](https://github.com/eduardbcom/lookup-dns-cache/blob/2.1.0/src/AddressCache.js#L21-L23)：\r\n\r\n```JavaScript\r\nfind(key) {\r\n  if (!this._cache.has(key)) {\r\n    return;\r\n  }\r\n\r\n  const addresses = this._cache.get(key);\r\n  if (this._isExpired(addresses)) {\r\n    return;\r\n  }\r\n\r\n  return addresses;\r\n}\r\n```\r\n\r\n这里可能会存在一个问题：如果查询的域名名称无限，由于缓存中仅判断是否过期，并无过期清理操作，因此过期缓存可能会一直占用内存而不释放。当然，由于普通业务项目中，域名查询的种类有限，并且基本会一直重复，因此并不会暴露该问题。\r\n\r\n---\r\n\r\n## 问题二：是否使用 resolv.conf 配置\r\n\r\n### 1 - `dns.resolve*` 等方法源码分析\r\n\r\n#### NodeJS 部分\r\n\r\n在 `lib/dns.js` 最后可以发现，dns 模块导出的相关 resolve 方法是通过\r\n\r\n```JavaScript\r\nbindDefaultResolver(module.exports, getDefaultResolver());\r\n```\r\n\r\n这行绑定上去的。\r\n\r\n而在 `lib/internal/dns/utils.js` 中会发现，`getDefaultResolver` 方法会返回一个 Resolver 实例。在这个模块里并没有各种 resolve 方法，而具体其上的 resolve 方法则还是在 [`lib/dns.js` 中实现的](https://github.com/nodejs/node/blob/v12.16.3/lib/dns.js#L207-L246)：\r\n\r\n```JavaScript\r\n...\r\nfunction resolver(bindingName) {\r\n  function query(name, /* options, */ callback) {\r\n    let options;\r\n    if (arguments.length > 2) {\r\n      options = callback;\r\n      callback = arguments[2];\r\n    }\r\n\r\n    validateString(name, 'name');\r\n    if (typeof callback !== 'function') {\r\n      throw new ERR_INVALID_CALLBACK(callback);\r\n    }\r\n\r\n    const req = new QueryReqWrap();\r\n    req.bindingName = bindingName;\r\n    req.callback = callback;\r\n    req.hostname = name;\r\n    req.oncomplete = onresolve;\r\n    req.ttl = !!(options && options.ttl);\r\n    const err = this._handle[bindingName](req, toASCII(name));\r\n    if (err) throw dnsException(err, bindingName, name);\r\n    return req;\r\n  }\r\n  ObjectDefineProperty(query, 'name', { value: bindingName });\r\n  return query;\r\n}\r\n\r\nconst resolveMap = ObjectCreate(null);\r\nResolver.prototype.resolveAny = resolveMap.ANY = resolver('queryAny');\r\nResolver.prototype.resolve4 = resolveMap.A = resolver('queryA');\r\nResolver.prototype.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\r\nResolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname');\r\n...\r\n```\r\n\r\n而这里关于 DNS 查询调用的核心的方法就是 `this._handle[bindingName](req, toASCII(name))`。如果我们再回到 [`lib/internal/dns/utils.js` 这个定义 Resolver 类的地方就会发现](https://github.com/nodejs/node/blob/v12.16.3/lib/internal/dns/utils.js#L28)：\r\n\r\n```JavaScript\r\n...\r\nclass Resolver {\r\n  constructor() {\r\n    this._handle = new ChannelWrap();\r\n  }\r\n  ...\r\n}\r\n...\r\n```\r\n\r\n`this._handle` 是 `ChannelWrap` 的一个实例。`ChannelWrap` 来自于对 [c-ares](https://github.com/c-ares/c-ares) 的内部绑定 —— [cares_wrap.cc](https://github.com/nodejs/node/blob/v12.16.3/src/cares_wrap.cc)。\r\n\r\n> [c-ares](https://github.com/c-ares/c-ares): This is an asynchronous resolver library. It is intended for applications which need to perform DNS queries without blocking, or need to perform multiple DNS queries in parallel.\r\n\r\n**按照官方文档的说法，c-ares 支持 resolv.conf。但为了保险起见，具体情况如何需要继续向下进一步确认。**\r\n\r\n拉到 cares_wrap.cc 的最后就可以看到针对 NodeJS 层的[一些绑定代码](https://github.com/nodejs/node/blob/v12.16.3/src/cares_wrap.cc#L2225-L2251)，这里截取和 `dns.resolve` 相关部分：\r\n\r\n```C++\r\n...\r\nLocal<FunctionTemplate> channel_wrap =\r\n      env->NewFunctionTemplate(ChannelWrap::New);\r\n  channel_wrap->InstanceTemplate()->SetInternalFieldCount(1);\r\n  channel_wrap->Inherit(AsyncWrap::GetConstructorTemplate(env));\r\nenv->SetProtoMethod(channel_wrap, \"queryAny\", Query<QueryAnyWrap>);\r\nenv->SetProtoMethod(channel_wrap, \"queryA\", Query<QueryAWrap>);\r\nenv->SetProtoMethod(channel_wrap, \"queryAaaa\", Query<QueryAaaaWrap>);\r\nenv->SetProtoMethod(channel_wrap, \"queryCname\", Query<QueryCnameWrap>);\r\n...\r\nLocal<String> channelWrapString =\r\n      FIXED_ONE_BYTE_STRING(env->isolate(), \"ChannelWrap\");\r\n  channel_wrap->SetClassName(channelWrapString);\r\n  target->Set(env->context(), channelWrapString,\r\n              channel_wrap->GetFunction(context).ToLocalChecked()).Check();\r\n...\r\n```\r\n\r\n以上代码主要包括两个部分，在 C++ 层创建了 JS 的 `ChannelWrap` 类，同时设置相应的原型方法。因此，在 JS 层 `new ChannelWrap()` 基本上的调用链条为 `ChannelWrap::New` --> `ChannelWrap::ChannelWrap` --> `ChannelWrap::Setup`。其中 Setup 阶段调用了 c-ares 的[初始化配置方法](https://github.com/nodejs/node/blob/v12.16.3/src/cares_wrap.cc#L476)：\r\n\r\n```C++\r\nvoid ChannelWrap::Setup() {\r\n  ...\r\n\r\n  /* We do the call to ares_init_option for caller. */\r\n  r = ares_init_options(&channel_,\r\n                        &options,\r\n                        ARES_OPT_FLAGS | ARES_OPT_SOCK_STATE_CB);\r\n\r\n  ...\r\n}\r\n```\r\n\r\n注意这里的第三个参数，就是该方法的 opmask，会决定使用哪些 options。\r\n\r\n#### c-ares 部分\r\n\r\n在 c-ares 中具体配置（包括 dns server）的初始化有四个步骤，从前到后分别是：\r\n\r\n- [通过传参初始化配置：init_by_options](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L196)\r\n- [通过环境变量初始化配置：init_by_environment](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L203)\r\n- [通过 resolv conf 初始化： init_by_resolv_conf](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L208)\r\n- [默认值填充：init_by_defaults](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L218)\r\n\r\n在第一种通过 option 结构体传参中，ares 会通过 `options->nservers` 来获取 DNS 服务器配置。但同时，需要在[操作掩码中设置 `ARES_OPT_SERVERS`](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L482-L502)。而在 NodeJS 中值设置了 `ARES_OPT_FLAGS | ARES_OPT_SOCK_STATE_CB`，因此不会设置 nservers。此外，init_by_options 中还会[设置 resolvconf_path 的值](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L547-L552)，该值所指向的地址就是系统 resolv.conf 的地址：\r\n\r\n```C++\r\n/* Set path for resolv.conf file, if given. */\r\nif ((optmask & ARES_OPT_RESOLVCONF) && !channel->resolvconf_path)\r\n  {\r\n    channel->resolvconf_path = ares_strdup(options->resolvconf_path);\r\n    if (!channel->resolvconf_path && options->resolvconf_path)\r\n      return ARES_ENOMEM;\r\n  }\r\n```\r\n\r\n同样的，从上面节选的代码可以看出，NodeJS 调用中 optmask 并不包含 `ARES_OPT_RESOLVCONF`，因此 `channel->resolvconf_path` 为空，而此处也会影响后续的 `init_by_resolv_conf` 方法。\r\n\r\n从 `ares_init_options` 代码的流程控制来看，正常情况下，设置完传参和环境变量后，最终会走到 `init_by_resolv_conf` 中。`init_by_resolv_conf` 方法主要是用来解析和获取 nameservers，其中包含比较多平台相关的条件编译，我们可以关注两个条件分支：\r\n\r\n- `#elif defined(CARES_USE_LIBRESOLV)`\r\n- 最后的条件分支\r\n\r\n`CARES_USE_LIBRESOLV` 这个宏表示[是否使用 resolv 这个库](https://github.com/c-ares/c-ares/blob/baf6f4eb4240d6c8844f751570b3c151af263d93/CMakeLists.txt#L140-L142)。\r\n\r\n```\r\nIF ((IOS OR APPLE) AND HAVE_LIBRESOLV)\r\n\tSET (CARES_USE_LIBRESOLV 1)\r\nENDIF()\r\n```\r\n\r\n看起来似乎是在苹果系统下会启用。一旦使用这个库，条件分支里就会有两个重要的函数调用 —— [`res_ninit`](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L1607) 和 [`res_getservers`](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L1613)。\r\n\r\n从手册中可以看出，`res_ninit` 会读取 [resolv.conf](http://man7.org/linux/man-pages/man3/resolver.3.html#:~:text=read%20the%20configuration%20files)，\r\n\r\n> The res_ninit() and res_init() functions read the configuration files (see resolv.conf(5)) to get the default domain name and name server address(es).\r\n\r\n因此在该分支中会使用 resolv.conf 文件。\r\n\r\n再看另一条分支。[最后条件分支（看起来应该是 Linux）的处理](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L1661)，其中会[优先读取 resolv.conf 的配置地址，不存在则取预定义的宏变量](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L1678-L1682)：\r\n\r\n```C++\r\n/* Support path for resolvconf filename set by ares_init_options */\r\nif(channel->resolvconf_path) {\r\n  resolvconf_path = channel->resolvconf_path;\r\n} else {\r\n  resolvconf_path = PATH_RESOLV_CONF;\r\n}\r\n```\r\n\r\n`PATH_RESOLV_CONF` 则定义在 [`ares_private.h`](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_private.h#L84) 中：\r\n\r\n```C++\r\n#define PATH_RESOLV_CONF        \"/etc/resolv.conf\"\r\n```\r\n\r\n`channel->nservers` 的设置也是通过读取文件中的 nameserver 配置项来添加的：\r\n\r\n```C++\r\nelse if ((p = try_config(line, \"nameserver\", ';')) &&\r\n      channel->nservers == -1)\r\n  status = config_nameserver(&servers, &nservers, p);\r\n```\r\n\r\n> 这里有个值得注意的地方，如果你具体去看，会发现并没有读取 timeout 配置，这个可能说明，如果使用 `dns.resolve`，配置中的 timeout 变量并不会生效。\r\n\r\n\r\n设置完成之后，当需要进行 DNS 查询时，最终会调用 ares_send.c 中的 `ares_send` 方法来发送查询请求。其中就会[使用 `channel->nservers` 中的值来作为本地 DNS 查询服务器](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_send.c#L103-L105)，其中 last_server [默认为 0](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_init.c#L174)：\r\n\r\n```C++\r\n/* Choose the server to send the query to. If rotation is enabled, keep track\r\n * of the next server we want to use. */\r\nquery->server = channel->last_server;\r\nif (channel->rotate == 1)\r\n  channel->last_server = (channel->last_server + 1) % channel->nservers;\r\n```\r\n\r\n> 这里还有个细节，[从代码上来看](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_send.c#L104-L105)，可以通过控制 `channel->rotate` 的值为 1 来开启本地 DNS 查询服务器的 RoundRobin 策略。而从实现上来看，它是通过 options 和 opmask 来控制的，似乎不会因为 resolv.conf 配置多个 nameserver 而自动 rr？\r\n\r\n综合上面的分析可知，在 NodeJS（v12.16.3）中，调用 `dns.resolve*` 相关方法，底层会调用 [c-ares](https://github.com/c-ares/c-ares) 这个库。根据 c-ares 的实现来分析，其最终会读取 `resolv.conf` 的 nameserver 设置本地 DNS，并用其进行查询。\r\n\r\nP.S. c-ares 也[依赖 glibc 的 resolv](https://github.com/c-ares/c-ares/blob/master/CMakeLists.txt#L217-L218)。\r\n\r\n### 2 - 实际验证\r\n\r\n经过上面的分析之后，可以再简单进行一下实际验证。下面是一段调用 `dns.resolve`（其他 resolve 方法同理）的代码：\r\n\r\n```JavaScript\r\nconst dns = require('dns');\r\ndns.resolve('www.acfun.cn', function (...args) {\r\n  console.log(...args);\r\n});\r\n```\r\n\r\n#### 实验一：\r\n\r\n环境：CentOS Linux release 7.4.1708\r\n\r\n运行输出：\r\n\r\n```TEXT\r\n$ node test.js\r\nnull [ '172.18.201.64' ]\r\n```\r\n\r\n用 strace 看下它的调用链：\r\n\r\n```Bash\r\n$ strace node test.js\r\n```\r\n\r\n内容比较多，下图只截取其中一部分，可以看到打开并读取了 resolv.conf。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/81075707-47399100-8f1d-11ea-87c3-52bc9e6e6558.png)\r\n\r\nstrace 输出（第8行的 open 调用）：\r\n\r\n```\r\nmprotect(0x43c0b904000, 503808, PROT_READ|PROT_EXEC) = 0\r\nread(21, \"const dns = require('dns');\\ndns.\"..., 102) = 102\r\nclose(21)                               = 0\r\nmprotect(0x43c0b884000, 503808, PROT_READ|PROT_WRITE) = 0\r\nmprotect(0x43c0b904000, 503808, PROT_READ|PROT_WRITE) = 0\r\nmprotect(0x43c0b884000, 503808, PROT_READ|PROT_EXEC) = 0\r\nmprotect(0x43c0b904000, 503808, PROT_READ|PROT_EXEC) = 0\r\nopen(\"/etc/resolv.conf\", O_RDONLY)      = 21\r\nfstat(21, {st_mode=S_IFREG|0644, st_size=176, ...}) = 0\r\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f4d5c7e6000\r\nread(21, \"#nameserver 10.75.60.252\\n#namese\"..., 4096) = 176\r\nread(21, \"\", 4096)                      = 0\r\nclose(21)                               = 0\r\nmunmap(0x7f4d5c7e6000, 4096)            = 0\r\nopen(\"/etc/nsswitch.conf\", O_RDONLY)    = 21\r\nfstat(21, {st_mode=S_IFREG|0644, st_size=1746, ...}) = 0\r\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f4d5c7e6000\r\nread(21, \"#\\n# /etc/nsswitch.conf\\n#\\n# An ex\"..., 4096) = 1746\r\nread(21, \"\", 4096)                      = 0\r\nclose(21)                               = 0\r\nmunmap(0x7f4d5c7e6000, 4096)            = 0\r\nuname({sysname=\"Linux\", nodename=\"hb2-acfuntest-ls004.aliyun\", ...}) = 0\r\nopen(\"/dev/urandom\", O_RDONLY)          = 21\r\nfstat(21, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 9), ...}) = 0\r\n```\r\n\r\n#### 实验二：\r\n\r\n环境：macOS 10.15.3 \r\n\r\n运行输出：\r\n\r\n```TEXT\r\n$ node test.js\r\nnull [\r\n  '61.149.11.118',\r\n  '111.206.4.103',\r\n  '61.149.11.116',\r\n  '61.149.11.117',\r\n  '61.149.11.115',\r\n  '61.149.11.113',\r\n  '61.149.11.112',\r\n  '111.206.4.98',\r\n  '111.206.4.97',\r\n  '61.149.11.119',\r\n  '111.206.4.96',\r\n  '61.149.11.114'\r\n]\r\n```\r\n\r\n可以看到，域名被正常解析了。下面修改 `/etc/resolv.conf` 内容，将 nameserver 改为一个无法访问的 IP（前面三个被注释的是原 DNS server）：\r\n\r\n```\r\n#\r\n# macOS Notice\r\n#\r\n# This file is not consulted for DNS hostname resolution, address\r\n# resolution, or the DNS query routing mechanism used by most\r\n# processes on this system.\r\n#\r\n# To view the DNS configuration used by this system, use:\r\n#   scutil --dns\r\n#\r\n# SEE ALSO\r\n#   dns-sd(1), scutil(8)\r\n#\r\n# This file is automatically generated.\r\n#\r\n#nameserver 172.18.1.166\r\n#nameserver 192.168.43.27\r\n#nameserver 192.168.1.1\r\nnameserver 192.168.2.2\r\n```\r\n\r\n此时再执行，会触发超时错误：\r\n\r\n```\r\nError: queryA ETIMEOUT www.acfun.cn\r\n    at QueryReqWrap.onresolve [as oncomplete] (dns.js:202:19) {\r\n  errno: 'ETIMEOUT',\r\n  code: 'ETIMEOUT',\r\n  syscall: 'queryA',\r\n  hostname: 'www.acfun.cn'\r\n}\r\n```\r\n\r\n### 结论\r\n\r\n通过源码和测试，可以确定 dns.resolve 相关方法，在 Linux 仍然会读取 resolv.conf 配置来设置本地 DNS 服务器。\r\n\r\n---\r\n\r\n## 问题三：关于 DNS 查询的 timeout\r\n\r\n在 c-ares 部分有提到两个编译分支，在最后一个 else 中，并不会对 timeout 的值进行处理，因此会落到最后的默认赋值上（5s）\r\n\r\n```C++\r\nif (channel->timeout == -1)\r\n    channel->timeout = DEFAULT_TIMEOUT;\r\n```\r\n\r\n`DEFAULT_TIMEOUT` [定义在这](https://github.com/nodejs/node/blob/v12.16.3/deps/cares/src/ares_private.h#L40:9)，为 5s \r\n\r\n```C++\r\n#define DEFAULT_TIMEOUT         5000 /* milliseconds */\r\n```\r\n\r\n而对于走到 CARES_USE_LIBRESOLV 分支的代码，则因为调用了 `res_ninit`，可以在 [`__res_state`](https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/resolv/bits/types/res_state.h#L13) 结构体中取到 retrans 值，该值会被[用作 timeout 值](https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/resolv/bits/types/res_state.h#L13)：\r\n\r\n```C++\r\nif (channel->timeout == -1)\r\n      channel->timeout = res.retrans * 1000;\r\n```\r\n\r\n> c-ares 文档也有关于 timeout 的[简单说明](https://c-ares.haxx.se/ares_init_options.html#:~:text=ARES_OPT_TIMEOUTMS%20int%20timeout;)\r\n\r\n如果以上分析没有问题的话，在生产环境中应该是属于上一种情况，但由于 NodeJS 层没有暴露对应设置超时的入口，所以，如果替换为 lookup-dns-cache，则无法控制 timeout 的时间。\r\n\r\n## 综上\r\n\r\n1. lookup-dns-cache 在 JS 这一层做了防止重复请求和缓存两处优化\r\n1. lookup-dns-cache 最底层也使用了 resolv.conf 这个配置\r\n1. 使用 lookup-dns-cache 后无法控制 DNS 查询的 timeout 值\r\n\r\n## 参考资料\r\n\r\n- NodeJS 官方文档\r\n  - [DNS](https://nodejs.org/dist/latest-v12.x/docs/api/dns.html)\r\n  - [Dependencies](https://nodejs.org/en/docs/meta/topics/dependencies/#c-ares)\r\n- [c-ares](https://github.com/c-ares/c-ares)\r\n- [man-pages: RESOLVER](http://man7.org/linux/man-pages/man3/resolver.3.html)\r\n- [How to fix nodejs DNS issues?](https://medium.com/@amirilovic/how-to-fix-node-dns-issues-5d4ec2e12e95)\r\n- [axios: difference in timeout behavior between versions 0.18.1 and 0.19.0-2](https://github.com/axios/axios/issues/2710)\r\n\r\n---\r\n\r\nP.S. resolv 中设置 timeout（retrans）值目测是在[这个地方](https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/resolv/res_init.c#L644-L651)\r\n\r\n```C++\r\n...\r\nelse if (!strncmp (cp, \"timeout:\", sizeof (\"timeout:\") - 1))\r\n{\r\n  int i = atoi (cp + sizeof (\"timeout:\") - 1);\r\n  if (i <= RES_MAXRETRANS)\r\n    parser->template.retrans = i;\r\n  else\r\n    parser->template.retrans = RES_MAXRETRANS;\r\n}\r\n...\r\n```\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/38","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/38/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/38/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/38/events","html_url":"https://github.com/alienzhou/blog/issues/38","id":589535488,"node_id":"MDU6SXNzdWU1ODk1MzU0ODg=","number":38,"title":"聊一聊 webpack 的打包优化实践","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1392194871,"node_id":"MDU6TGFiZWwxMzkyMTk0ODcx","url":"https://api.github.com/repos/alienzhou/blog/labels/Performance","name":"Performance","color":"65ed99","default":false,"description":""},{"id":1159845019,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE5","url":"https://api.github.com/repos/alienzhou/blog/labels/Webpack","name":"Webpack","color":"e4e669","default":false,"description":""},{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-03-28T08:44:33Z","updated_at":"2020-03-28T08:48:08Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"# 遇到了什么问题?\r\n\r\n去年接触了公司内一个开发运行了两年多的项目，整体应用是基于 React 技术栈的，多个单页应用有构成了多页应用。可以理解为比较独立的子业务之间是 MPA 形式跳转，而子业务内部则是 SPA 形式。\r\n\r\n项目的构建使用了 webpack，发现存在较大问题：\r\n\r\n- 在生产环境上线编译大致需要 13 min+；\r\n- 本地开发环境下，代码改动后的热更新（增量编译）需要大概 10～20s 的时间，使得开发体验很差。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/3/28/1711ccd02f1caa9e?w=794&h=335&f=png&s=227359)\r\n\r\n相信这些问题在很多上线迭代了很长时间的、使用了 webpack 的团队中都会遇到，所以把自己的优化实践经历写出来，和大家交流下。我在优化的时候也参考了许多网络上介绍的优化手段，当然，有些具有不错效果，有些可能对我们来说不适用。这并不是一篇罗列各种 webpack 优化技巧的文章，除了优化实践，还会有一些期间的反思。\r\n\r\n# 如何分析性能问题?\r\n\r\n优化前自然需要找到问题点。\r\n\r\n首先，你可以使用一些开源工具来分析。针对 webpack 性能分析的工具，用的很多的有 [speed-measure-webpack-plugin](https://github.com/stephencookdev/speed-measure-webpack-plugin)，我们可以用它来统计各个 plugin 和 loader 的耗时。这部分上网络各类介绍 webpack 性能优化的文章都会提到，本文就不赘述了。\r\n\r\n![](https://www.alienzhou.com/img/improvement-in-webpack/1711a6ee306dd462.jpg)\r\n\r\n其次，需要结合你的业务来具体分析。例如，在最开头我提到，我们的项目虽然在子业务中是属于 SPA 形式的，但是整体上是 MPA 的方式，因此在项目打包时会有多个入口，针对每个入口 [html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin) 也会帮我们生成多个文件。因此，即使我只开发一个用户中心子业务，也会完整编译一次整体项目，显然是存在问题的。\r\n\r\n最后，优化也会有一些通用的手段，或者说是业务“最佳实践经验”的总结。例如，保持升级到新版的 webpack（这里是指 major version），为 loader 提供 cache 等。\r\n\r\n这大致就是性能优化前进行问题和现状分析的一些手段。总计来说就是：\r\n\r\n- 通过自动化检测工具，来直观反映出系统的性能数据；\r\n- 充分理解业务特点，结合实际业务情况分析问题；\r\n- 查阅与了解一些业务“通用建议”，这些一般都具有一定普适性，可以进一步帮助你优化。\r\n\r\n# 性能优化的实践与思考\r\n\r\n一旦分析完目前项目中 webpack 的性能问题，就可以着手进行优化实践了。不过很多时候，性能问题的分析与处理是一个交错循环的过程。你在解决性能问题的同时，也可能发现新的性能优化点。\r\n\r\n下面介绍一些我在项目中尝试的优化措施、优化效果和一些思考。\r\n\r\n## 需要升级到最新的 webpack 么？\r\n\r\nwebpack 的一些版本迭代本身就会包含其自身的性能优化，所以升如果你的 major version 比较老了，那么升级到新版就会提高整体的性能。\r\n\r\n例如我接触到该业务项目时，由于其此 2017 年开始就没有升级过 webpack，所以还是使用的 webpack v3。着手优化的第一件事就是将其升级到 webpack v4。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/3/28/1711ccd31ee8f82b?w=794&h=360&f=png&s=635290)\r\n\r\nwebpack v4 已经发布很长时间了（目前 webpack v5 的 beta 版都已经更新了很多次了），而项目中还在使用 webpack v3 算是一个遗留问题，有必要升级。关于 v3 升级到 v4 的指南网上很多，主要都是一些配置更新，像是代码压缩、commonChunks 更新到 splitChunks、使用 MiniCssExtractPlugin 等，[官方](https://v4.webpack.js.org/migrate/4/)也提供了升级指导，我在这里就不赘述了，只是列几个项目中可能会用到的依赖项的版本更新吧：\r\n\r\n- html-webpack-plugin >= 4.0.0（用于和 splitChunks 配合使用）\r\n- eslint-loader >= 2.1.0）\r\n- react-dev-utils >= 6.0.0（一些早期 create-react-app 创建的项目 eject 后需要升级这个）\r\n- happypack >= 5.0.0\r\n- file-loader >= 2.0.0\r\n\r\n升级完成后的效果显著，根据多次对比实验的结果，会有 **30%～40% 的性能提升**。正如江湖中所说，很多时候各种优化手段带来的提升，不及升级一下 webpack。所以后续 webpack v5 稳定后大家跟上也是个不错的选择。因此，如果你项目中的 webpack 的主版本已经落后主流（稳定）的版本，建议优先进行升级。\r\n\r\n## 使用 DLLPlugin 有收益么？\r\n\r\n[DLLPlugin](https://v4.webpack.js.org/plugins/dll-plugin/) 是借鉴 DLL 的思路，将一些更新频率极低的模块（例如 node_modules 中的各个包）单独存储到一个文件中，然后项目中通过生成的 manifest 与 DLL 产物将所需的模块打包进项目中。\r\n\r\n我们也是使用业界常见的一种用法，对 node_modules 中代码运用的 DLLPlugin，不过在业务应用后提升并不明显。同时使用 DLL 还有一个需要解决的问题。\r\n\r\n我们各类项目都是用云端编译的方式，只将源代码提交仓库，通过 CI 在编译集群中编译。任何产出的代码都不会提交仓库内。这样保证所有的编译环境、编译工具都是收敛统一的。由于 DLL 文件是编译产出的，这套理念之下，我们自然也倾向于不在本地构建出 DLL，而是云端编译。\r\n\r\n另一方面，业务代码在提交到仓库进行云端编译时，就会需要去获取 DLL 文件加入到自己的编译流程中。这时候可能有这么几种获取 DLL 的方式：\r\n\r\n1. 开发者把之前云端编译好的 DLL 和放到仓库里一起提交。但这个里面有较大的维护成本，开发者需要知道 DLL 什么时候更新了，并且手动获取到最新的 DLL。不推荐。\r\n2. 自制一套 DLL 的发布、更新与拉取服务，然后在业务项目中声明所需的 DLL，在构建流程中集成 DLL 的拉取操作。如果要做的完善，会需要较大成本。\r\n3. 把 DLL 与 manifest 发布为一个 npm 包，业务代码通过 node_modules 方式引入。其实就是借用 npm 的能力实现了方法2中能力。是个不错的选择。\r\n\r\n但是最终我并没有使用 DLLPlugin。一是因为上面提到的，在我们的业务中实际提升效果不明显；其二是引入后即使用方法3，也会增加复杂性，提高开发人员理解的门槛。正负向效果权衡后，并没有用。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/3/28/1711ccd63915f3c6?w=794&h=399&f=png&s=556071)\r\n\r\n所以这里也想说明，**一些大家推荐的方式，究竟有没有收益，仍然需要结合自己的项目来考量。利弊权衡，方得正道**。\r\n\r\n## 是否需要使用 Linter？\r\n\r\n这似乎是一个开倒车的问题。在前端工程化不断完善的今天，Linter 被无数次证明其价值，为什么不使用呢？但结合本篇「webpack 打包优化」的主题，它其实是在问，我们需要在 webpack 中集成 Linter 么？\r\n\r\n众所周知，我们在 webpack 中可以通过 eslint-loader 来集成 eslint。这么做的目标主要包括：\r\n\r\n1. 让开发人员能实时获知代码检查的结果，越早知道，越容易修复；\r\n2. 同时也是提供代码检查的规范，控制不良的编码进入仓库。\r\n\r\n但在 webpack 中集成 Linter 并不一定是最佳解法。针对目的 1，我们完全可以在编辑器中加入相应的 Linter 规范。大多数情况下，团队内编码规范一旦确定，就不常更改。所以提供与编辑器集成的 Linter 对于完成目标 1 来说是更好的选择。而鉴于 vscode 的流程与插件体系的便利，提供一个包含你们团队 Linter 规则的 vscode 插件成本并不高，并且覆盖面广。\r\n\r\n而针对目标 2，可以通过 git hook 的方式在来触发代码检查。最简单的方式可以通过 [husky](https://github.com/typicode/husky) 来配置，让 eslint 在 `git commit` 或 `git push` 时触发。但是本地检查是可以人为注销的（例如为了绕过检查在提交时注释掉 hook）。所以更进一步，如果你们公司的基建能力够强，并且需要大范围推广代码规范，甚至可以考虑给 git 流程添加更严格的控制。让所有 push 的代码都只能先推入暂存分支，分支合入必须去代码管理平台操作，合入前服务端会 diff 文件并运行 Linter 进行检查。\r\n\r\n此外，Linter 其实只需要检查变动的文件。由于集成在 webpack 中，所以它无法通过 `git diff` 来限制只检查变化的文件，全量编译时处理了很多不必要的文件。同时，eslint 和 webpack 的“标配” babel 一样，都要经过 source code -> AST -> source code 的过程，但两者 AST 又无法共享，本身也有效率的浪费。\r\n\r\n既然会带来额外开销同时也不是最好的选择，那自然选择移除 webpack 中的 eslint 使用。但这并不代表不要 Linter 了。取而代之的是，会提供一个 vscode 插件来服务于开发阶段，同时在 CI/CD 中将 git 能力与 Linter 集成，做更有效的代码检查。\r\n\r\n借着这个话题，想额外展开一句。一些小伙伴在提到前端构建、前端工程化时，眼光都落在 webpack 上。但它其实只是构建工具中的一种甚至只是一部分，对于工程化更是如此。没必要让 webpack 去承载所有工作。\r\n\r\n## 使用 cache 香不香？\r\n\r\n利用 cache 是各类优化的一个常见手段。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/3/28/1711ccd9116d31ff?w=794&h=301&f=png&s=538889)\r\n\r\n在 webpack v4 中可以使用 [cache-loader](https://github.com/webpack-contrib/cache-loader) 来提高 loader 处理的效率。更进一步的，可以使用 [hard-source-webpack-plugin](https://github.com/mzgoddard/hard-source-webpack-plugin) 来缓存编译的中间产物，大幅提升后续的编译效率。而 webpack v5 的一大亮点也是[加入了缓存能力](https://zhuanlan.zhihu.com/p/110995118)，hard-source-webpack-plugin 久未维护估计也是因为其作者加入 webpack v5 的开发中。\r\n\r\n> 同时提一句，hard-source-webpack-plugin 从 0.7.x 版本后，只支持 node 8+。\r\n\r\n个人实践后，使用 cache-loader 与 hard-source-webpack-plugin 确实可以有效提升编译效率。尤其是 hard-source-webpack-plugin，使用后可以获取 60%～70% 的效率提升。不过引入该插件一定要非常谨慎，这个插件很“脆弱”，因为它使用 webpack 内部的数据结构，这些数据结构本身就是不准备开放给外部开发者和用户的，因此并没有很好的保障，很可能会因为 webpack 的迭代或引入一些插件导致出错。例如，我就遇到了一个与 DLL 一起使用后无法解决的 bug。\r\n\r\n同时，如果你使用云端编译的方式，生产环境一般也是无法使用缓存的。如果是用编译集群，编译机的一般流程是会自动创建一个新的空目录，拉取最新代码，安装依赖，执行打包编译，将产物传到产品库中，最后清理文件。这个过程中资源都是全新的，不会存在缓存；而本次产出的缓存下次也不会用上。甚至可能会使用像 docker 这样的容器技术来创建编译环境。那么不仅资源是全新的，连环境也是全新的。\r\n\r\n所以在这种主流的构建模式下，本地开发可以享受缓存，发布生产环境的流程是无法利用缓存的。同时，像 hard-source-webpack-plugin 这类的插件，我个人的信任度还是比较低，而其确实也容易出错，所以完全不推荐用于生产环境。个人建议是，如果想在生产环境中使用缓存，一定要慎重，确保缓存功能是“官方认证”且经历过考验的。因为这类功能很容易成为错误的来源。\r\n\r\n针对上面提到的这种构建流程，当你决定了要在生产环境的编译中使用 cache 时，不论是在 v4 中使用 cache-loader 与 hard-source-webpack-plugin 这样的工具还是使用 v5 的缓存，你都需要一套保存与使用缓存的机制。这可能需要你和基建或工程效率团队的同学合作，增加相应的流程机制了。\r\n\r\n基于上面的考虑，我还是选择只在开发环境支持 cache，同时提供一个开关，开发人员可以自由选择是否使用 cache；而在生产环境下完全不使用 cache。\r\n\r\n## 最快的编译就是不编译\r\n\r\n让你的仓库编译速度最快的方法就是把所有模块文件都删掉，变成一个空代码仓库，这样连一毫秒都不会花了。\r\n\r\n当然这是一个玩笑。但它表达的观点是：只编译你所需要的东西，编译的越少，编译就越快。\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/3/27/1711cb2a4f6b370d?w=587&h=350&f=png&s=226698)\r\n\r\n我们的业务是一个在 MPA 中融合 SPA 的形态 —— 独立子业务间是 MPA 的形式，而子业务内则是 SPA 的模式。因此针对每个子业务的 SPA 在 webpack 中都会有一个对应的 entry。编译的过程就是将所有这些子业务的 entry 丢给 webpack 让它一起编译。由于子业务间的依赖较为复杂，个人中心的代码可能 `import` 了一个资源搜索业务中的模块，而 common 里的有些模块又“不够common”，所以当下又无法简单的拆分为不同仓库分开编译。开发人员的体验非常差，因为我只需要开发其中一小部分，却要整个仓库各类子业务都编译一遍。开发的启动和增量编译时间都很长。\r\n\r\n你可能会觉得不合理，但业务业务是演进的，架构和技术也是演进的。并且问题已经出现，需要去解决，像是给行驶的车子换轮胎，你既不能要求停车，也不能坐视不管。通过良好的业务拆分与架构迁移也许可以解决这个问题，但目前时间与人力不允许，因此优先着眼编译的优化。\r\n\r\n办法其实很简单。因为一般某个人一段时间的开发都是集中在一个子业务内，因此可以在开始开发时，让开发人员选择需要编译的子业务，webpack 只需要装载这一部分 entry 即可。具体可以通过使用 [enquirer](https://github.com/enquirer/enquirer) 列出 entry 选项让开发者选择，之后再将所选 entry 放入 webpack config 中启动。这个功能可以添加到你的 build 脚本之中。\r\n\r\n实施时，业务总共有五个子业务，其中大部分的开发工作集中在一个较新的子业务中。通过只选择它，避免了编译另一个“沉重”的老业务模块，开发环境的启动耗时大幅缩减。\r\n\r\n额外还要提一下，这个问题是架构模式导致的，这里的方法算是指标不治本。但有些时候，止疼药也得先吃着。而关于前端代码架构的拆分的讨论就不在本主题范围内了。\r\n\r\n## 减少项目依赖的安装\r\n\r\n本块针对的是编译集群里进行的生产编译的优化。我们的项目每次发布，都会在编译机上，拉取项目代码后，创建一个新的空环境，使用 `npm i` 安装一遍依赖（包括编译工具和源码依赖）。这其中的两块地方可能是不必要的：\r\n\r\n- 一些项目依赖其实已经废弃了，不需要安装；\r\n- 还有一些编译工具是长期稳定的，可以考虑做预装。\r\n\r\n针对第一个问题，基本不会有太多争议，这类依赖应该从项目中移除。具体做法可以基于 babel 写一个简单的工具遍历 JavaScript 代码，收集其中所有对 node_modules 中各包的依赖，最终与 package.json 进行对比，标出所有没有用到的包。\r\n\r\n针对第二个问题，一种做法是固定编译工具集。一般对于编译工具来说，团队内部会尽量统一与收敛，例如 webpack、Babel、PostCSS、Less 这些包长期会稳定使用某一个版本，因此可以考虑在编译机上预装这些依赖。尤其像 SASS 这种还需要 binding.node 的安装耗时更长。如果希望做环境隔离，还可以考虑通过虚拟机或容器的方式来交付你定制话的构建工具环境。\r\n\r\n当然，对于第二个问题，也有同学会觉得，每次发布重新安装一遍编译工具集会更好，因为可以通过 npm 版本的语义来自动安装适合的版本，可以享受到一些补丁修复的好处。上面提到的预装，则是一种变相的所版本了。关于是否要锁版本这块其实也是仁者见仁智者见智。\r\n\r\n我在实践中则是这块快都进行了优化。通过优化，在编译集群中进行生产环境编译的整体耗时减少了 10% 左右。\r\n\r\n## 其他\r\n\r\n还有一些其他的优化细节可以简单说一下：\r\n\r\n- 开发环境可以将 [`devtool`](https://v4.webpack.js.org/configuration/devtool/#devtool) 设为 `eval`。\r\n- 开发时如果没有需求，可以考虑将 `pathinfo` 设为 `false`。\r\n- html-webpack-plugin 的缓存机制似乎仍然有些问题，如果追求极致的热更新（增量编译）速度，可以加入一些[魔改代码](https://github.com/jantimon/html-webpack-plugin/pull/963/files)。由于热更新本来就分秒必争（是 0.1s，还是 1s，还是 10s 看到热更新效果，体验差距很大），因此该改动还是会带来一定的提升。\r\n- [happypack](https://github.com/amireh/happypack)。happypack 号称会利用多线程加速 loader 处理，不过你可千万别期望开 4 个线程就会使 loader 耗时变为原先的 1/4。实践下来很多时候性能提升并不明显，在极好的机子（例如 32 core）上差距才会明显。同时，happypack 作者已经声明不再维护该仓库，如果有需求可以考虑用 [thread-loader](https://github.com/webpack-contrib/thread-loader)。所以我建议在自己的项目与构建环境中实测一下效果，再决定使不使用。\r\n- 合理使用 `noParse` 来跳过一些代码模块，例如 jquery。\r\n- 此外，resolve 也会有消耗，可以尽量避免一些后缀不全或路径查找。\r\n\r\n## 效果\r\n\r\n通过上面的一系列优化，\r\n\r\n- 开发环境全量编译从耗时缩减 71%。如果只编译开发所需的单入口，耗时可下降 91%。\r\n- 开发环境增量编译从原先的 20s 下降为 870ms 左右，耗时缩减 95%。\r\n- 生产环境编译从原先的 13min+ 缩减为 5min，耗时降低 61 %。\r\n\r\n# 最后\r\n\r\n开篇就说到，这并不是一篇罗列各种 webpack 优化技巧的文章，更像是对于一次优化实践的总结与反思。\r\n\r\n我的目的一直是提升 CI/CD 中「构建」这一环的效率和稳定性，同时提升本地开发体验，而项目在这一环节的核心工具就是 webpack。所以优化的中很多工作涉及到了这一块。但是，你完全没必要局限在 webpack 的优化上。正如文中关于 Linter 的那一节，并没有一门心思去想如何在 webpack 中加速 eslint，而是直接把它从 webpack 里去掉了。因为我们可以把它安排在其他地方，这样只需要检查更少的文件，做更少次的检查，就可以达到相同的目的，甚至更好的效果。\r\n\r\n所以，优化 webpack 打包性能只是手段，不是目的。脚手架是因为其自身边界的原因，所以将很多工具都集中在了 webpack 身上，但你确完全不必，因为你面前的是星辰大海。如果你眼里只有 webpack，那你看什么都会是 loader 和 plugin。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/3/28/1711cbc8be7e5116?w=794&h=336&f=png&s=510966)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/36","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/36/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/36/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/36/events","html_url":"https://github.com/alienzhou/blog/issues/36","id":573776420,"node_id":"MDU6SXNzdWU1NzM3NzY0MjA=","number":36,"title":"信息规则：网络经济的策略指导","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1940757530,"node_id":"MDU6TGFiZWwxOTQwNzU3NTMw","url":"https://api.github.com/repos/alienzhou/blog/labels/Reading","name":"Reading","color":"c9ff9e","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-03-02T07:39:52Z","updated_at":"2020-03-28T08:49:43Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"https://www.alienzhou.com/2020/03/02/a-strategic-guide-to-the-network-economy/\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/75654765-699ffb80-5c9b-11ea-8ca3-adbbc5b7fba1.png)\r\n\r\n今天的许多管理者“只见树木不见森林”，仅仅关注技术变革，而忽视决定生死的经济规律。如果你无法理解网络经济（network economy），那么如何能够理解信息时代（例如互联网）的商业运作模式呢？\r\n\r\n记得读书时老师曾经推荐过一篇 Hal Varian 的微观经济学论文，文章很多，没有那种论文里面常见的“弯弯绕绕”的措辞，数学模型计算与推理简洁明了，看着就像是一份随堂作业一般的随笔之作。然而文章发在了经济学的重要期刊上，不得不让人佩服，大师就是大师。\r\n\r\n而这本[《信息规则》](https://book.douban.com/subject/27179558/)不是网上那种充斥着博人眼球的小知识点的“伪学术”书，也不是那种在学校图书馆里的枯燥的教课书。书中没有晦涩的专业知识，艰深的模型公式，而是通过一个个现实案例来对书中提到的论点进行解释和印证。让即使不具备经济学基础的读者也能很好理解其中的内容。\r\n\r\n---\r\n\r\n网络经济和以前的经济规律有区别么？\r\n\r\n**有也没有。**\r\n\r\n之所一说有是在于，书中提到，作者们经常听到别人抱怨说经济学在现今的经济活动中已没什么用了。之后他们了解到：“抱怨针对的是大多数在校学习的古典经济学，其核心是供给需求曲线和完全竞争市场，比如农产品市场”。显然，针对当今信息经济的一些经济学研究是与传统古典经济学存在差异的。而正是有这些差异，才需要这么一本书来进行分析与归纳。\r\n\r\n而说它没有，也是因为信息经济并非是一种横空出世、超脱于所有经济规律的“神物”。如果你仔细分析，会发现仍然有许多经济规律在其中运行，只是现在的限制条件、前提变了。书中经常会指出一些经济活动或形式背后的本质逻辑，并提供一些历史上的先例来告诉你 —— 它并不是什么新鲜事。例如数字化拷贝带来的更便宜的生产和分销机制，在历史上的图书馆、打印机、复印机也一样导致了这些变革。又例如在阐述“锁定”的章节，作者说：“摩擦并没有消失，它们只是变换了形式”。\r\n\r\n所以我们更应该辨证地看待网络经济：既要认识到它的独特之处，学习新时代的“玩法”；也要避免“神话”这种现象，因为它也是符合经济学规律，很多历史先例更我们提供了一些蓝本。\r\n\r\n书中信息还是比较丰富的，整理了如下的思维导图以供参考：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/75654892-a4099880-5c9b-11ea-9469-aab477812e47.png)\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/35","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/35/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/35/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/35/events","html_url":"https://github.com/alienzhou/blog/issues/35","id":569461009,"node_id":"MDU6SXNzdWU1Njk0NjEwMDk=","number":35,"title":"凤凰项目：一个 IT 运维的传奇故事","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1940757530,"node_id":"MDU6TGFiZWwxOTQwNzU3NTMw","url":"https://api.github.com/repos/alienzhou/blog/labels/Reading","name":"Reading","color":"c9ff9e","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-02-23T08:30:33Z","updated_at":"2020-03-28T08:49:31Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"![image](https://user-images.githubusercontent.com/9822789/75106637-a9426400-5659-11ea-814d-ae8e225d5860.png)\r\n\r\n> 这是一本非常真实的虚构小说，反应了今天 IT 部门几乎所有常见问题。。。\r\n\r\n[《凤凰项目：一个 IT 运维的传奇故事》](https://book.douban.com/subject/34820436/)虽然是一本和 DevOps 相关的“技术书”，但主体内容其实是使用小说的形式呈现的。\r\n\r\n故事的主人公比尔原本只是一个中型机管理部的技术经理，但公司面临 IT 项目危机，他临危受命，出任 IT 运维副总裁。别以为这是个美差，对于他来说，走出舒适圈，在经验不足的同时，面临的是几近崩溃的 IT 状况 💢：\r\n\r\n<!-- more -->\r\n\r\n- 😵管理混论不堪，没人能说清楚大家都在做什么；\r\n- 🕳项目不断延期，永远没有能按时完成的需求；\r\n- 💣事故不断，几乎每天都要处理安全、财务等相关的 IT 事故；\r\n- 🧟‍♂️核心项目失败，“凤凰”延期两年多，耗资 2000 万美元，眼看着就要血本无归；\r\n- ……\r\n\r\n面对这些问题，本书从主人公比尔的第一视角展开，带我们看了他如何从迷茫、出入门道、找到方向到最后解决问题，最终帮助公司扭亏为盈的传奇“历险故事”。文中没有大段的说教、公式、定律，抛开这些教科书式的内容形态，这本技术书以小说的形式来阐述，引人入胜，完全不无聊。如果不是想规范自己的作息，很多次我都想通宵刷完。\r\n\r\n通过故事的方式来阐述有一个非常突出的有优点，所有的理论和方法不再是冷冰冰的文字，你可以从主人公面临的问题开始，一步步推演出解决方案与最佳实践。更好的是，很多章节都以问题结束，这时候你可以自然地停下来，思考如果是你，你会怎么办，然后再来揭开“答案”。文中有很多方法论，可能需要你在实践中体会才能更深入地理解。所以我不准备罗列所有这些，只是简单谈谈一些印象比较深刻的地方。\r\n\r\n书中其实有一个非常内核的问题：IT 的价值流到底是什么样的？这既需要你回答，IT 工作是如何流动的，同时，还需要你认识到，IT 也是业务价值的生产部门，这就意味着，你需要让这个价值流/工作流更好地与上下游部分对接。文中一个典型案例就是信息安全部门的负责人约翰。他一直强调安全的重要性，并一直抱怨着大家对他们的安全工作重视太低，这似乎也符合我们技术人的直觉。但直到有一次，一个关乎公司存亡的安全审计在没有他的安全部门的帮助下，而是通过业务部门的努力被成功化解了，他才开始反思。正如书中的大师艾瑞克告诫他的那样：如果他（约翰）搞不清楚业务部门是如何在没有安全部门的帮助下渡过安全危机的，那他就不可能做出“好事”。\r\n\r\n难道安全问题不重要么？显然重要。但关键在于，你从什么维度，从什么视角来看待它、解决它。你需要把 IT 的价值流与其他部门的价值流连通起来，这样，顺畅的 IT “管道”才能更高效、更安全、更稳定地向整体战略输送养料。正如文中比尔、约翰他们在评估工作的优先级时，正是从准确理解业务目标开始，分离出核心任务，再进一步通过优化工作流来提升 IT 的价值流的。也就是说你需要从全局视角，来理解 IT 工作的的价值。同时，理解如何从工作流角度而非业务功能角度看 IT 工作，超脱角色限制。\r\n\r\n此外，书中还有三个不错的知识点。\r\n\r\n首先是关于等待时间的讨论，它告诉我们\r\n\r\n> 等待时间 = 忙碌时间百分比 / 空闲时间百分比\r\n\r\n所以有下面这张图（也是书中唯一一张图表）：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/75106642-b2333580-5659-11ea-9d71-bc55f7284beb.png)\r\n\r\n可以看到，当忙碌时间百分比超过 80% 时，等待时间将呈几何级上升。\r\n\r\n其次，是“四种工作内容”：业务项目、IT 内部项目、变更和计划外工作（救火）。这四种工作构成了 IT 运维（或者也可以说就是 IT）的最主要工作。其中计划外工作往往是由于其他工作或流程上的疏忽带来的额外工作，是有负向影响的。例如你正按计划在开发报表系统，这时候突然数据库发生故障，这就是一个计划外的工作。而重点就是尽量去避免计划外的工作，从源头上遏制住它。\r\n\r\n此外，书中提到了三步工作法：\r\n\r\n- 第一工作法是关于从开发到 IT 运维再到客户的整个自左向右的工作流。我们希望流量最大化，减小批量规模和工作间隔。\r\n- 第二工作法是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保防止问题再次发生，或者更快地发现和修复问题。\r\n- 第三工作法是关于创造公司文化，包括：不断尝试，能够承担风险并从中学习经验教训；理解重复和练习是熟练掌握的前提。\r\n\r\n文中的三步工作法给我很大启发，虽然它具体落地是在 DevOps 上，但其思想内核在在或大或小地方都是可以用到的。它表述了的三部分是：\r\n\r\n1. 最优化你开展工作的流程\r\n2. 建立反馈循环的机制\r\n3. 营造与培养相应的文化\r\n\r\n就拿推行单元测试这个技术例子来说，你需要思考的不光是什么单测框架好用、怎样给一个私有方法写测试，而是要去分析从业务需求到产生单测再到最后输出的整个流程，清楚它是如何从业务价值里流向来的，并通过“约束理论”等方法来优化它。那建立反馈机制呢？例如一个可能的方式是通过单测经验或报告来对反哺开发团队，提高其效率与系统的稳定性。而最后一步工作文化呢？千万不要小看它，技术只是一种解决手段，在很多 DevOps 的分享中也会在开篇章节就强调：DevOps 更重要的是一种文化，是一系列价值观，你只有认同它，技术工具才有发挥的空间。试想，如果每个开发人员、测试人员都不认同单元测试的价值，那么即使强制推行了，写出来的测试代码也不过是为了通过测试覆盖率的累赘，既不能提升软件的可靠性，也不能提高研发效率，久而久之，反而会带来副作用，影响产研团队，阻碍业务发展。\r\n\r\n最后，提一下书里留给我影响很深的一个理论 —— 约束理论。它表明，在约束点之外的任何地方做的任何改进都是徒劳无功的。因此，我们需要去解决约束点的问题，解决的步骤一般是：\r\n\r\n1. 识别约束点\r\n2. 利用约束点\r\n3. 让所有其他活动都从属于约束点\r\n4. 把约束点提升到新的水平\r\n5. 寻找下一个约束点\r\n\r\n不过本书只是引用了一些约束理论的方法论，如果想深入理解我可能得再去读一读[高德拉特的《目标》](https://book.douban.com/subject/3859892/)这本书了。\r\n\r\n---\r\n\r\n《凤凰项目：一个 IT 运维的传奇故事》里其实借鉴了很多“生产运作管理”和“精益生产”的思想与知识。鉴于我也修过“生产运作管理”这门课，所以读起来也有些亲切。书中艾瑞克反问比尔：“你以为 IT 运维管理会比管理一个生产车间更复杂、更高深么？”我不知到究竟哪个更加高深，但我相信，从其他的先行领域中借鉴思想，寻找解决方案是一个聪明的做法，从来如此。\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/34","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/34/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/34/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/34/events","html_url":"https://github.com/alienzhou/blog/issues/34","id":558522134,"node_id":"MDU6SXNzdWU1NTg1MjIxMzQ=","number":34,"title":"【3分钟速览】如何“严谨地”判断两个变量是否相同","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845014,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE0","url":"https://api.github.com/repos/alienzhou/blog/labels/JavaScript","name":"JavaScript","color":"d73a4a","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-02-01T10:44:44Z","updated_at":"2020-02-01T10:44:44Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 引言\r\n\r\n如何“严谨地”判断两个变量相同？仅仅使用 `===` 就可以了么？\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/1/4/16f6f67316cf3a36?w=1400&h=200&f=png&s=34612)\r\n\r\n## 严格相等\r\n\r\n我们可以非常快的写一个 `is` 方法来判断变量 x 是否就是 y：\r\n\r\n```JavaScript\r\n// 第一版\r\nfunction is(x, y) {\r\n  return x == y;\r\n}\r\n```\r\n\r\n当然，你会很快发现，方法里用了 `==`，由于[隐式转换](https://www.w3schools.com/js/js_type_conversion.asp)的问题，这并不严谨。所以我们自然会使用如下的方法：\r\n\r\n```JavaScript\r\n// 第二版\r\nfunction is(x, y) {\r\n  return x === y;\r\n}\r\n```\r\n\r\n那么这是否完美了呢？\r\n\r\n## 一个“更严谨”的方法\r\n\r\n```JavaScript\r\n// 第三版\r\nfunction is(x, y) {\r\n  if (x === y) {\r\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\r\n  } else {\r\n    return x !== x && y !== y;\r\n  }\r\n}\r\n```\r\n\r\n上面方法相较于我们常用的第二版更复杂了。那么为什么多了这么多判断呢？\r\n\r\n下面让我们来详细看看。\r\n\r\n### 1. Infinity\r\n\r\n了解 JavaScript 的同学应该会记得，在全局中有一个叫做 [`Infinity`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Infinity) 的属性，表示数值上的无穷大。\r\n\r\n| Infinity 属性的属性特性 |  |\r\n|---|---|\r\n| writable | false |\r\n| enumerable | false |\r\n| configurable | false |\r\n\r\n同时，你用 `Number.POSITIVE_INFINITY` 也能获取到该值。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/1/4/16f6f132c0bec8ec?w=436&h=39&f=png&s=3876)\r\n\r\n于此对应的，也有个 `Number.NEGATIVE_INFINITY` 的值，实际就是 `-Infinity`。\r\n\r\n而 `Infinity` 比较特殊的一点在于，在 JavaScript 中 `1 / Infinity` 与 `-1 / Infinity`。 被认为是相等的（由于 `+0` 和 `-0`，下一节会进一步介绍）\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/1/4/16f6f174c669e5f3?w=322&h=41&f=png&s=2913)\r\n\r\n而在很多场景中，包括像一些 deepEqual 之类的方法中，我们不希望将其判定为相等。学过统计的同学都知道[假设检验中有两类错误](https://en.wikipedia.org/wiki/False_positives_and_false_negatives)：\r\n\r\n- I类错误：弃真错误（false positive）\r\n- II类错误：取伪错误（false negative）\r\n\r\n结合我们上面提到的，第一个条件判断可能就会犯II类错误 —— `1 / Infinity` 与 `-1 / Infinity` 不相同，却判断为相同了。所以需要进一步判断：\r\n\r\n```JavaScript\r\nx !== 0 || y !== 0 || 1 / x === 1 / y\r\n```\r\n\r\n`1 / Infinity` 与 `-1 / Infinity` 在与 `0` 的相等判断中都会为 `true`\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/1/4/16f6f2ddd2f954bc?w=574&h=41&f=png&s=4875)\r\n\r\n而其倒数 `Infinity` 与 `-Infinity` 是不相等的，所以避免了 `1 / Infinity` 与 `-1 / Infinity` 的判断问题。\r\n\r\n### 2. `+0` 与 `-0`\r\n\r\n其实，上面 `Infinity` 问题的核心原因在于于 JavaScript 中存在 `+0` 与 `-0`。\r\n\r\n我们知道每个数字都有其对应的二进制编码形式，因此 `+0` 与 `-0` 编码是有区别的，平时我们不主动声明的话，所使用的其实都是 `+0`，而 JavaScript 为了我们的运算能更加方便，也做了很多额外工作。\r\n\r\n> 想要更进一步了解 `+0` 与 `-0` 可以读一下 [JavaScript’s two zeros](https://2ality.com/2012/03/signedzero.html) 这篇文章。\r\n\r\n但在很多判断相等的工作上，我们还是会把 `+0` 与 `-0` 区分开。\r\n\r\n```JavaScript\r\nx !== 0 || y !== 0 || 1 / x === 1 / y\r\n```\r\n\r\n上面这个式子也就起到了这个作用。\r\n\r\n### 3. `NaN`\r\n\r\nJavaScript 中还有一个叫 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN) 全局属性，用来表示不是一个数字（Not-A-Number）\r\n\r\n| NaN 属性的属性特性 |  |\r\n|---|---|\r\n| writable | false |\r\n| enumerable | false |\r\n| configurable | false |\r\n\r\n它有一个特点 —— 自己不等于自己：\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/1/4/16f6f35688449594?w=328&h=36&f=png&s=2128)\r\n\r\n这可能会导致判断出现 I 类错误（弃真错误）：原本是相同的，却被我们判断为不相同。\r\n\r\n解决的方法也很简单，JavaScript 中只有 `NaN` 会有“自己不等于自己”的特点。所以只需要判断两个变量是否都“自己不等于自己”即可，即都为 `NaN` ：\r\n\r\n```JavaScript\r\nx !== x && y !== y\r\n```\r\n\r\n如果两个变量都为 `NaN`，那么他们其实就还是相同的。\r\n\r\n## 总结\r\n\r\n总的来说，我们的加强版就是额外处理了 `+0`/`-0` 与 `NaN` 的情况。\r\n\r\n实际项目中，很多时候由于并不会碰这样的业务值，或者这些边界情况的判断并不影响业务逻辑，所以使用 `===` 就足够了。\r\n\r\n而在一些开源库中，由于需要更加严谨，所以很多时候就会考虑使用第三版的这类方法。例如在 [react-redux 中对 props 和 state 前后相等性判断](https://github.com/reduxjs/react-redux/blob/58ae5edee510a2f2f3bc577f55057fe9142f2976/src/utils/shallowEqual.js#L1-L7)，[underscore 中的相等判断方法](https://github.com/jashkenas/underscore/blob/master/underscore.js#L1191-L1198)等。而 underscore 中更进一步还对 `null` 与 `undefined` 做了特殊处理。\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/33","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/33/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/33/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/33/events","html_url":"https://github.com/alienzhou/blog/issues/33","id":545222880,"node_id":"MDU6SXNzdWU1NDUyMjI4ODA=","number":33,"title":"【漫游Github】无编译/无服务器，实现浏览器的 CommonJS 模块化","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845014,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE0","url":"https://api.github.com/repos/alienzhou/blog/labels/JavaScript","name":"JavaScript","color":"d73a4a","default":false,"description":""},{"id":1159845015,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%B5%8F%E8%A7%88%E5%99%A8","name":"浏览器","color":"cfd3d7","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-01-04T01:14:32Z","updated_at":"2020-03-28T08:48:44Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 引言\r\n\r\n平时经常会逛 Github，除了一些 star 极高的大项目外，还会在 Github 上发现很多有意思的小项目。项目或是想法很有趣，或是有不错的技术点，读起来都让人有所收获。所以准备写一个「漫游Github」系列，不定期分享与解读在 Github 上偶遇的有趣项目。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/71757685-7807ac00-2ed2-11ea-97e7-c93eec7b6017.png)\r\n\r\n好了下面进入正题。本期要介绍的仓库叫 [one-click.js](https://github.com/jordwalke/one-click.js) 。\r\n\r\n## 1. one-click.js 是什么\r\n\r\n[one-click.js](https://github.com/jordwalke/one-click.js) 是个很有意思的库。Github 里是这么介绍它的：\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/71757693-8f469980-2ed2-11ea-8e08-97f216665249.png)\r\n\r\n我们知道，如果希望 CommonJS 的模块化代码能在浏览器中正常运行，通常都会需要构建/打包工具，例如 webpack、rollup 等。而 one-click.js 可以让你在不需要这些构建工具的同时，也可以在浏览器中正常运行基于 CommonJS 的模块系统。\r\n\r\n进一步的，甚至你都不需要启动一个服务器。例如试着你可以试下 clone 下 one-click.js 项目，直接双击（用浏览器打开）其中的 `example/index.html` 就可以运行。\r\n\r\nRepo 里有一句话概述了它的功能：\r\n\r\n> Use CommonJS modules directly in the browser with no build step and no web server.\r\n\r\n举个例子来说 ——\r\n\r\n假设在当前目录（`demo/`）现在，我们有三个“模块”文件：\r\n\r\n`demo/plus.js`：\r\n\r\n```JavaScript\r\n// plus.js\r\nmodule.exports = function plus(a, b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\n`demo/divide.js`：\r\n\r\n```JavaScript\r\n// divide.js\r\nmodule.exports = function divide(a, b) {\r\n    return a / b;\r\n}\r\n```\r\n\r\n与入口模块文件 `demo/main.js`：\r\n\r\n```JavaScript\r\n// main.js\r\nconst plus = require('./plus.js');\r\nconst divide = require('./divide.js');\r\nconsole.log(divide(12, add(1, 2)));\r\n// output: 4\r\n```\r\n\r\n常见用法是指定入口，用 webpack 编译成一个 bundle，然后浏览器引用。而 one-click.js 让你可以抛弃这些，只需要在 HTML 中这么用：\r\n\r\n```HTML\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>one click example</title>\r\n</head>\r\n<body>\r\n    <script type=\"text/javascript\" src=\"./one-click.js\" data-main=\"./main.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\n注意 `script` 标签的使用方式，其中的 `data-main` 就指定了入口文件。此时直接用浏览器打开这个本地 HTML 文件，就可以正常输出结果 7。\r\n\r\n## 2. 打包工具是如何工作的？\r\n\r\n上一节介绍了 one-click.js 的功能 —— 核心就是实现不需要打包/构建的前端模块化能力。\r\n\r\n在介绍其内部实现这之前，我们先来了解下打包工具都干了什么。俗话说，知己知彼，百战不殆。\r\n\r\n还是我们那三个 JavaScript 文件。\r\n\r\nplus.js：\r\n\r\n```JavaScript\r\n// plus.js\r\nmodule.exports = function plus(a, b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\ndivide.js：\r\n\r\n```JavaScript\r\n// divide.js\r\nmodule.exports = function divide(a, b) {\r\n    return a / b;\r\n}\r\n```\r\n\r\n与入口模块 main.js：\r\n\r\n```JavaScript\r\n// main.js\r\nconst plus = require('./plus.js');\r\nconst divide = require('./divide.js');\r\nconsole.log(divide(12, add(1, 2)));\r\n// output: 4\r\n```\r\n\r\n回忆一下，当我们使用 webpack 时，会指定入口（main.js）。webpack 会根据该入口打包出一个 bundle（例如 bundle.js）。最后我们在页面中引入处理好的 bundle.js 即可。这时的 bundle.js 除了源码，已经加了很多 webpack 的“私货”。\r\n\r\n简单理一理其中 webpack 涉及到的工作：\r\n\r\n1. **依赖分析**：首先，在打包时 webpack 会根据语法分析结果来获取模块的依赖关系。简单来说，在 CommonJS 中就是根据解析出的 require 语法来得到当前模块所依赖的子模块。\r\n2. **作用域隔离与变量注入**：对于每个模块文件，webpack 都会将其包裹在一个 function 中。这样既可以做到 `module`、`require` 等变量的注入，又可以隔离作用域，防止变量的全局污染。\r\n3. **提供模块运行时**：最后，为了 `require`、`exports` 的有效执行，还需要提供一套运行时代码，来实现模块的加载、执行、导出等功能。\r\n\r\n> 如果对以上的 2、3 项不太了解，可以从篇文章中了解 [webpack 的模块运行时设计](https://juejin.im/post/5b82ac82f265da431d0e6d25#heading-3)。\r\n\r\n## 3. 我们面对的挑战\r\n\r\n没有了构建工具，直接在浏览器中运行使用了 CommonJS 的模块，其实就是要想办法完成上面提到的三项工作：\r\n\r\n- 依赖分析\r\n- 作用域隔离与变量注入\r\n- 提供模块运行时\r\n\r\n解决这三个问题就是 one-click.js 的核心任务。下面我们来分别看看是如何解决的。\r\n\r\n### 3.1. 依赖分析\r\n\r\n这是个麻烦的问题。如果想要正确加载模块，必须准确知道模块间的依赖。例如上面提到的三个模块文件 —— `main.js` 依赖 `plus.js` 和 `divide.js`，所以在运行 `main.js` 中代码时，需要保证 `plus.js` 和 `divide.js` 都已经加载进浏览器环境。然而问题就在于，没有编译工具后，我们自然无法自动化的知道模块间的依赖关系。\r\n\r\n对于 [RequireJS](https://requirejs.org/) 这样的模块库来说，它是在代码中声明当前模块的依赖，然后使用异步加载加回调的方式。显然，CommonJS 规范是没有这样的异步 API 的。\r\n\r\n而 one-click.js 用了一个取巧但是有额外成本的方式来分析依赖 —— 加载两遍模块文件。在第一次加载模块文件时，为模块文件提供一个 mock 的 `require` 方法，每当模块调用该方法时，就可以在 require 中知道当前模块依赖哪些子模块了。\r\n\r\n```JavaScript\r\n// main.js\r\nconst plus = require('./plus.js');\r\nconst divide = require('./divide.js');\r\nconsole.log(minus(12, add(1, 2)));\r\n```\r\n\r\n例如上面的 `main.js`，我们可以提供一个类似下面的 `require` 方法：\r\n\r\n```JavaScript\r\nconst recordedFieldAccessesByRequireCall = {};\r\nconst require = function collect(modPath) {\r\n    recordedFieldAccessesByRequireCall[modPath] = true;\r\n    var script = document.createElement('script');\r\n    script.src = modPath;\r\n    document.body.appendChild(script);\r\n};\r\n```\r\n\r\n`main.js` 加载后，会做两件事：\r\n\r\n1. 记录当前模块中依赖的子模块；\r\n2. 加载子模块。\r\n\r\n这样，我们就可以在 `recordedFieldAccessesByRequireCall` 中记录当前模块的依赖情况；同时加载子模块。而对于子模块也可以有递归操作，直到不再有新的依赖出现。最后将各个模块的 `recordedFieldAccessesByRequireCall` 整合起来就是我们的依赖关系。\r\n\r\n此外，如果我们还想要知道 `main.js` 实际调用了子模块中的哪些方法，可以通过 `Proxy` 来返回一个代理对象，统计进一步的依赖情况：\r\n\r\n```JavaScript\r\nconst require = function collect(modPath) {\r\n    recordedFieldAccessesByRequireCall[modPath] = [];\r\n    var megaProxy = new Proxy(function(){}, {\r\n        get: function(target, prop, receiver) {\r\n            if(prop == Symbol.toPrimitive) {\r\n                return function() {0;};\r\n            }\r\n            return megaProxy;\r\n        }\r\n    });\r\n    var recordFieldAccess = new Proxy(function(){}, {\r\n        get: function(target, prop, receiver) {\r\n            window.recordedFieldAccessesByRequireCall[modPath].push(prop);\r\n            return megaProxy;\r\n        }\r\n    });\r\n    // …… 一些其他处理\r\n    return recordFieldAccess;\r\n};\r\n```\r\n\r\n以上的代码会在你获取被导入模块的属性时记录所使用的属性。\r\n\r\n上面所有模块的加载就是我们所说的“加载两遍”的第一遍，用于分析依赖关系。而第二遍就需要基于入口模块的依赖关系，“逆向”加载模块即可。例如 `main.js` 依赖 `plus.js` 和 `divide.js`，那么实际上加载的顺序是 `plus.js` -> `divide.js` -> `main.js`。\r\n\r\n值得一提的是，在第一次加载所有模块的过程中，这些模块执行基本都是会报错的（因为依赖的加载顺序都是错误的），我们会忽略执行的错误，只关注依赖关系的分析。当拿到依赖关系后，再使用正确的顺序重新加载一遍所有模块文件。one-click.js 中有更完备的实现，该方法名为 `scrapeModuleIdempotent`，具体[源码可以看这里](https://github.com/jordwalke/one-click.js/blob/8db5f181fe7dafa050d5789741fbe4b2c87ba779/one-click.js#L378-L505)。\r\n\r\n到这里你可能会发现：“这是一种浪费啊，每个文件都加载了两遍。”\r\n\r\n确实如此，这也是 one-click.js 的 [tradeoff](https://github.com/jordwalke/one-click.js#tradeoffs)：\r\n\r\n> In order to make this work offline, One Click needs to initialize your modules twice, once in the background upon page load, in order to map out the dependency graph, and then another time to actually perform the module loading.\r\n\r\n### 3.2. 作用域隔离\r\n\r\n我们知道，模块有一个很重要的特点 —— 模块间的作用域是隔离的。例如，对于如下普通的 JavaScript 脚本：\r\n\r\n```JavaScript\r\n// normal script.js\r\nvar foo = 123;\r\n```\r\n\r\n当其加载进浏览器时，`foo` 变量实际会变成一个全局变量，可以通过 `window.foo` 访问到，这也会带来全局污染，模块间的变量、方法都可能互相冲突与覆盖。\r\n\r\n在 NodeJS 环境下，由于使用 CommonJS 规范，同样像上面这样的模块文件被导入时， `foo` 变量的作用域只在源模块中，不会污染全局。而 NodeJS 在实现上其实就是[用一个 wrap function 包裹了模块内的代码](https://juejin.im/post/5b82ac82f265da431d0e6d25#heading-2)，我们都知道，function 会形成其自己的作用域，因此就实现了隔离。\r\n\r\nNodeJS 会在 `require` 时对源码文件进行包装，而 webpack 这类打包工具会在编译期对源码文件进行改写（也是类似的包装）。而 one-click.js 没有编译工具，那编译期改写肯定行不通了，那怎么办呢？下面来介绍两种常用方式：\r\n\r\n#### 3.2.1. JavaScript 的动态代码执行\r\n\r\n一种方式可以通过 `fetch` 请求获取 script 中文本内容，然后通过 `new Function` 或 `eval` 这样的方式来实现动态代码的执行。这里以 `fetch` + `new Function` 方式来做个介绍：\r\n\r\n还是上面的除法模块 `divide.js`，稍加改造下，源码如下：\r\n\r\n```JavaScript\r\n// 以脚本形式加载时，该变量将会变为 window.outerVar 的全局变量，造成污染\r\nvar outerVar = 123;\r\n\r\nmodule.exports = function (a, b) {\r\n    return a / b;\r\n}\r\n```\r\n\r\n现在我们来实现作用域屏蔽：\r\n\r\n```JavaScript\r\nconst modMap = {};\r\nfunction require(modPath) {\r\n    if (modMap[modPath]) {\r\n        return modMap[modPath].exports;\r\n    }\r\n}\r\n\r\nfetch('./divide.js')\r\n    .then(res => res.text())\r\n    .then(source => {\r\n        const mod = new Function('exports', 'require', 'module', source);\r\n        const modObj = {\r\n            id: 1,\r\n            filename: './divide.js',\r\n            parents: null,\r\n            children: [],\r\n            exports: {}\r\n        };\r\n\r\n        mod(modObj.exports, require, modObj);\r\n        modMap['./divide.js'] = modObj;\r\n        return;\r\n    })\r\n    .then(() => {\r\n        const divide = require('./divide.js')\r\n        console.log(divide(10, 2)); // 5\r\n        console.log(window.outerVar); // undefined\r\n    });\r\n```\r\n\r\n代码很简单，核心就是通过 `fetch` 获取到源码后，通过 `new Function` 将其构造在一个函数内，调用时向其“注入”一些模块运行时的变量。为了代码顺利运行，还提供了一个简单的 `require` 方法来实现模块引用。\r\n\r\n当然，上面这是一种解决方式，然而在 one-click.js 的目标下却行不通。因为 one-click.js 还有一个目标是能够在无服务器（offline）的情况下运行，所以 `fetch` 请求是无效的。\r\n\r\n那么 one-click.js 是如何处理的呢？下面我们就来了解下：\r\n\r\n#### 3.2.2. 另一种作用域隔离方式\r\n\r\n一般而言，隔离的需求与沙箱非常类似，而在前端创建一个沙箱有一种常用的方式，就是 iframe。下面为了方便起见，我们把用户实际使用的窗口叫作“主窗口”，而其中内嵌的 iframe 叫作“子窗口”。由于 iframe 天然的特性，每个子窗口都有自己的 `window` 对象，相互之间隔离，不会对主窗口进行污染，也不会相互污染。\r\n\r\n下面仍然以加载 divide.js 模块为例。首先我们构造一个 iframe 用于加载脚本：\r\n\r\n```JavaScript\r\nvar iframe = document.createElement(\"iframe\");\r\niframe.style = \"display:none !important\";\r\ndocument.body.appendChild(iframe);\r\nvar doc = iframe.contentWindow.document;\r\nvar htmlStr = `\r\n    <html><head><title></title></head><body>\r\n    <script src=\"./divide.js\"></script></body></html>\r\n`;\r\ndoc.open();\r\ndoc.write(htmlStr);\r\ndoc.close();\r\n```\r\n\r\n这样就可以在“隔离的作用域”中加载模块脚本了。但显然它还无法正常工作，所以下一步我们就要补全它的模块导入与导出功能。模块导出要解决的问题就是让主窗口能够访问子窗口中的模块对象。所以我们可以在子窗口的脚本加载运行完后，将其挂载到主窗口的变量上。\r\n\r\n修改以上代码：\r\n\r\n```JavaScript\r\n// ……省略重复代码\r\nvar htmlStr = `\r\n    <html><head><title></title></head><body>\r\n    <scrip>\r\n        window.require = parent.window.require;\r\n        window.exports = window.module.exports = undefined;\r\n    </script>\r\n    <script src=\"./divide.js\"></script>\r\n    <scrip>\r\n        if (window.module.exports !== undefined) {\r\n            parent.window.modObj['./divide.js'] = window.module.exports;\r\n        }\r\n    </script>\r\n    </body></html>\r\n`;\r\n// ……省略重复代码\r\n```\r\n\r\n核心就是通过像 `parent.window` 这样的方式实现主窗口与子窗口之间的“穿透”：\r\n\r\n- 将子窗口的对象挂载到主窗口上；\r\n- 同时支持子窗口调用主窗口中方法的作用。\r\n\r\n上面只是一个原理性的粗略实现，如果对更严谨的实现细节感兴趣可以看源码中的 [loadModuleForModuleData 方法](https://github.com/jordwalke/one-click.js/blob/8db5f181fe7dafa050d5789741fbe4b2c87ba779/one-click.js#L203-L281)。\r\n\r\n值得一提的是，在「3.1. 依赖分析」中提到先加载一遍所有模块来获取依赖关系，而这部分的加载也是放在 iframe 中进行的，也需要防止“污染”。\r\n\r\n### 3.3. 提供模块运行时\r\n\r\n模块的运行时一版包括了构造模块对象（module object）、存储模块对象以及提供一个模块导入方法（`require`）。模块运行时的各类实现一般都大同小异，这里需要注意的就是，如果隔离的方法使用 iframe，那么需要在主窗口与子窗口中传递一些运行时方法和对象。\r\n\r\n当然，细节上还可能会需要支持模块路径解析（resolve）、循环依赖的处理、错误处理等。由于这部分的实现和很多库类似，又或者不算特别核心，在这里就不详细介绍了。\r\n\r\n## 4. 总结\r\n\r\n最后归纳一下大致的运行流程：\r\n\r\n1. 首先从页面中拿到入口模块，在 one-click.js 中就是 `document.querySelector(\"script[data-main]\").dataset.main`；\r\n2. 在 iframe 中“顺藤摸瓜”加载模块，并在 `require` 方法中收集模块依赖，直到没有新的依赖出现；\r\n3. 收集完毕，此时就拿到了完整的依赖图；\r\n4. 根据依赖图，“逆向”加载相应模块文件，使用 iframe 隔离作用域，同时注意将主窗口中的模块运行时传给各个子窗口；\r\n5. 最后，当加载到入口脚本时，所有依赖准备就绪，直接执行即可。\r\n\r\n总的来说，由于没有了构建工具与服务器的帮助，所以要实现依赖分析与作用域隔离就成了困难。而 one-click.js 运用上面提到的技术手段解决了这些问题。\r\n\r\n那么，one-click.js 可以用在生产环境么？显然是[不行的](https://github.com/jordwalke/one-click.js#not-using)。\r\n\r\n> Do not use this in production. The only purpose of this utility is to make local development simpler.\r\n\r\n**所以注意了**，作者也说了，这个库的目的仅仅是方便本地开发。当然，其中一些技术手段作为学习资料，咱们也是可以了解学习一下的。感兴趣的小伙伴可以访问 [one-click.js 仓库](https://github.com/jordwalke/one-click.js)进一步了解。\r\n\r\n---\r\n\r\n好了，这期的「漫游 Github」就到这里了。本系列会不定期和大家一起看一看、聊一聊、学一学 github 上有趣的项目，不仅学习一些技术点，还可以了解作者的技术思考，欢迎感兴趣的小伙伴关注。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/71757685-7807ac00-2ed2-11ea-97e7-c93eec7b6017.png)\r\n\r\n---\r\n\r\n## 往期内容\r\n\r\n- [【漫游Github】quicklink 的实现原理与给前端的启发](https://juejin.im/post/5c21f8435188256d12597789)\r\n- [【漫游Github】如何提升JSON.stringify()的性能？](https://juejin.im/post/5cf61ed3e51d4555fd20a2f3)\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/32","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/32/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/32/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/32/events","html_url":"https://github.com/alienzhou/blog/issues/32","id":481087731,"node_id":"MDU6SXNzdWU0ODEwODc3MzE=","number":32,"title":" 【性能优化指南】带你全面掌握前端性能优化 🚀 ","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1392194871,"node_id":"MDU6TGFiZWwxMzkyMTk0ODcx","url":"https://api.github.com/repos/alienzhou/blog/labels/Performance","name":"Performance","color":"65ed99","default":false,"description":""},{"id":1159845015,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%B5%8F%E8%A7%88%E5%99%A8","name":"浏览器","color":"cfd3d7","default":false,"description":""},{"id":1298890220,"node_id":"MDU6TGFiZWwxMjk4ODkwMjIw","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%89%B9%E6%80%A7","name":"特性","color":"c2e0c6","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2019-08-15T10:19:26Z","updated_at":"2020-03-28T08:48:28Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"✨仓库地址：[fe-performance-journey](https://github.com/alienzhou/fe-performance-journey) ✨\r\n\r\n![](https://alienzhou.github.io/fe-performance-journey/assets/img/intro.4a36214c.jpg)\r\n\r\n## 前端需要性能优化么？\r\n\r\n性能优化一直以来都是前端工程领域中的一个重要部分。很多资料<sup>[1]</sup><sup>[2]</sup><sup>[3]</sup>表明，网站应用的性能优化对于提高用户留存、转化率等都有积极影响。可以理解为，提升你的网站性能，就是提升你的业务数据（甚至是业务收入）。\r\n\r\n性能优化广义上包含前端优化和后端优化。后端优化的关注点更多的时候是在增加资源利用率、降低资源成本以及提高稳定性上。相较于后端，前端的性能优化会更直接与用户的体验挂钩。从用户体验侧来说，前端服务 5s 的加载时间优化缩减 80%(1s) 与后端服务 50ms 的响应优化缩减 80%(10ms) 相比，用户的体验提升会更大。因此很多时候，与体验相关的性能的瓶颈会出现在前端。\r\n\r\n![](https://alienzhou.github.io/fe-performance-journey/assets/img/waterfall.cbaa0ead.jpg)\r\n\r\n## 如何学习前端性能优化？\r\n\r\n作为前端工程师，大家其实都具备一定的性能优化意识，同时也有自己的优化“武器库”，例如懒加载、资源合并、避免 reflow 等等。虽然大家对性能优化都有自己的思路，不过大多是分散在某几个点，较难形成一个完整的体系。业界也有很多优质的资料，例如[雅虎的性能优化 35 条](https://github.com/creeperyang/blog/issues/1)<sup>[4]</sup>，但是 **性能优化作为一个系统性工程**，大家想要系统性地去学习并不容易。\r\n\r\n从用户开始访问你的网站应用，到最终它在上面浏览信息、操作交互，其间经历了非常多的环节，每个环节都有可能出现性能问题，同时也是我们实现性能提升机会。所以，前端性能优化会要求你从整体维度来分析系统，甚至是业务。\r\n\r\n那么如何能够更有效地梳理与理解性能优化呢？回想到每每面试都会被问到：“从地址栏输入XXX到访问之间经历了什么？”其实我们也可以从这个视角来看待性能优化。\r\n\r\n从访问开始，用户可能会经历类似「查询缓存 -> 发送请求 -> 等待响应 -> 页面解析 -> 下载并处理各类静态资源 -> 运行时 -> 预加载（等待后续的请求）」这样一个不断往复的“旅程” —— 也就是我们的「性能优化之旅」。Web 应用在其中每一站都可能遇到性能问题，当然也会有对应的优化手段。\r\n\r\n所以在这次的「性能优化之旅」会沿着这条路径具体介绍每个环节中常见的性能问题以及优化技术。通过与 Web 应用的访问流程相结合，帮助大家全面理解与掌握前端的性能优化。\r\n\r\n下面是整体的大纲：\r\n\r\n![](https://alienzhou.github.io/fe-performance-journey/assets/img/overall.dcdd4140.svg)\r\n\r\n如果准备好了，咱们就可以出发了 ——\r\n\r\n## 旅途的行程路线👇\r\n\r\n目前内容已全部更新至 ✨ [fe-performance-journey](https://github.com/alienzhou/fe-performance-journey) ✨ 仓库中，陆续会将内容同步。如果希望尽快阅读相关内容，可以直接去该仓库中浏览文章。喜欢的朋友可以去仓库 star 一下。\r\n\r\n- 第一站 - 缓存\r\n- 第二站 - 发送请求\r\n- 第三站 - 服务端处理\r\n- 第四站 - 下载与解析页面\r\n- 第五站 - 页面静态资源\r\n  - JavaScript\r\n  - CSS\r\n  - 图片\r\n  - 字体\r\n  - 视频\r\n- 第六站 - 运行时\r\n- 第七站 - 预加载\r\n- 尾声\r\n- TODO:\r\n  - 性能指标\r\n  - 性能监控\r\n\r\n---\r\n\r\n## 参考资料\r\n\r\n1. [Driving user growth with performance improvements](https://medium.com/@Pinterest_Engineering/driving-user-growth-with-performance-improvements-cfc50dafadd7)\r\n1. [How Fast Should A Website Load in 2019?](https://www.hobo-web.co.uk/your-website-design-should-load-in-4-seconds/)\r\n1. [How long will you wait for a shopping website to load?](https://www.bbc.com/news/business-37100091)\r\n1. [Best Practices for Speeding Up Your Web Site (Yahoo)](https://github.com/creeperyang/blog/issues/1)\r\n1. [17 Things People Absolutely Hate About Your Website](https://blog.hubspot.com/blog/tabid/6307/bid/32307/15-things-people-absolutely-hate-about-your-website.aspx)\r\n1. [Why Performance Matters](https://developers.google.com/web/fundamentals/performance/why-performance-matters/)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/31","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/31/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/31/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/31/events","html_url":"https://github.com/alienzhou/blog/issues/31","id":452470481,"node_id":"MDU6SXNzdWU0NTI0NzA0ODE=","number":31,"title":"【漫游Github】如何提升JSON.stringify()的性能？","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845014,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE0","url":"https://api.github.com/repos/alienzhou/blog/labels/JavaScript","name":"JavaScript","color":"d73a4a","default":false,"description":""},{"id":1392194871,"node_id":"MDU6TGFiZWwxMzkyMTk0ODcx","url":"https://api.github.com/repos/alienzhou/blog/labels/Performance","name":"Performance","color":"65ed99","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2019-06-05T12:20:32Z","updated_at":"2020-01-04T01:16:28Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 1. 熟悉的`JSON.stringify()`\r\n\r\n在浏览器端或服务端，`JSON.stringify()`都是我们很常用的方法：\r\n\r\n- 将 JSON object 存储到 localStorage 中；\r\n- POST 请求中的 JSON body；\r\n- 处理响应体中的 JSON 形式的数据；\r\n- 甚至某些条件下，我们还会用它来实现一个简单的深拷贝；\r\n- ……\r\n\r\n在一些性能敏感的场合下（例如服务端处理大量并发），或面对大量 stringify 的操作时，我们会希望它的性能更好，速度更快。这也催生了一些优化的 stringify 方案/库，下图是它们与原生方法的性能对比：\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/6/5/16b25784d49d825a?w=1200&h=488&f=png&s=42368)\r\n\r\n绿色部分时原生`JSON.stringify()`，可见性能相较这些库都要低很多。那么，在大幅的性能提升背后的技术原理是什么呢？\r\n\r\n## 2. 比 `stringify` 更快的 `stringify`\r\n\r\n由于 JavaScript 是动态性很强的语言，所以对于一个 Object 类型的变量，其包含的键名、键值、键值类型最终只能在运行时确定。因此，执行`JSON.stringify()`时会有很多工作要做。在一无所知的情况下，我们想要大幅优化显然无能为力。\r\n\r\n那么如果我们知道这个 Object 中的键名、键值信息呢 —— 也就是知道它的结构信息，这会有帮助么？\r\n\r\n看个例子：\r\n\r\n下面这个 Object，\r\n\r\n```JavaScript\r\nconst obj = {\r\n    name: 'alienzhou',\r\n    status: 6,\r\n    working: true\r\n};\r\n```\r\n\r\n我们对它应用`JSON.stringify()`，得到结果为\r\n\r\n```JavaScript\r\nJSON.stringify(obj);\r\n// {\"name\":\"alienzhou\",\"status\":6,\"working\":true}\r\n```\r\n\r\n现在如果我们知道这个`obj`的结构是固定的：\r\n\r\n- 键名不变\r\n- 键值的类型一定\r\n\r\n那么其实，我可以创建一个“定制化”的 stringify 方法\r\n\r\n```JavaScript\r\nfunction myStringify(o) {\r\n    return (\r\n        '{\"name\":\"'\r\n        + o.name\r\n        + '\",\"status\":'\r\n        + o.status\r\n        + ',\"isWorking\":'\r\n        + o.working\r\n        + '}'\r\n    );\r\n}\r\n```\r\n\r\n看看我们的`myStringify`方法的输出：\r\n\r\n```JavaScript\r\nmyStringify({\r\n    name: 'alienzhou',\r\n    status: 6,\r\n    working: true\r\n});\r\n// {\"name\":\"alienzhou\",\"status\":6,\"isWorking\":true}\r\n\r\nmyStringify({\r\n    name: 'mengshou',\r\n    status: 3,\r\n    working: false\r\n});\r\n// {\"name\":\"mengshou\",\"status\":3,\"isWorking\":false}\r\n```\r\n\r\n可以得到正确的结果，但只用到了类型转换和字符串拼接，所以“定制化”方法可以让“stringify”更快。\r\n\r\n总结来看，如何得到比 `stringify` 更快的 `stringify` 方法呢？\r\n\r\n1. 需要先确定对象的结构信息；\r\n2. 根据其结构信息，为该种结构的对象创建“定制化”的`stringify`方法，其内部实际是通过字符串拼接生成结果的；\r\n3. 最后，使用该“定制化”的方法来 stringify 对象即可。\r\n\r\n这也是大多数 stringify 加速库的套路，转化为代码就是类似：\r\n\r\n```JavaScript\r\nimport faster from 'some_library_faster_stringify';\r\n\r\n// 1. 通过相应规则，定义你的对象结构\r\nconst theObjectScheme = {\r\n    // ……\r\n};\r\n\r\n// 2. 根据结构，得到一个定制化的方法\r\nconst stringify = faster(theObjectScheme);\r\n\r\n// 3. 调用方法，快速 stringify\r\nconst target = {\r\n    // ……\r\n};\r\nstringify(target);\r\n```\r\n\r\n## 3. 如何生成“定制化”的方法\r\n\r\n根据上面的分析，核心功能在于，**根据其结构信息，为该类对象创建“定制化”的stringify方法，其内部实际是简单的属性访问与字符串拼接。**\r\n\r\n为了了解具体的实现方式，下面我以两个实现上略有差异的开源库为例来简单介绍一下。\r\n\r\n### 3.1. fast-json-stringify\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/6/4/16b21d1399c2e90b?w=2004&h=96&f=png&s=73286)\r\n\r\n下图是根据 [fast-json-stringify](https://github.com/fastify/fast-json-stringify#benchmarks) 提供的 benchmark 结果，整理出来的性能对比。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/6/4/16b21db215453a98?w=872&h=434&f=png&s=33293)\r\n\r\n可以看到，在大多数场景下具备2-5倍的性能提升。\r\n\r\n#### 3.1.1. scheme 的定义方式\r\n\r\nfast-json-stringify 使用了 [JSON Schema Validation ](http://json-schema.org/latest/json-schema-validation.html) 来定义（JSON）对象的数据格式。其 scheme 定义的结构本身也是 JSON 格式的，例如对象\r\n\r\n```JavaScript\r\n{\r\n    name: 'alienzhou',\r\n    status: 6,\r\n    working: true\r\n}\r\n```\r\n\r\n对应的 scheme 就是：\r\n\r\n```JavaScript\r\n{\r\n    title: 'Example Schema',\r\n    type: 'object',\r\n    properties: {\r\n        name: {\r\n            type: 'string'\r\n        },\r\n        status: {\r\n            type: 'integer'\r\n        },\r\n        working: {\r\n            type: 'boolean'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n其 scheme 定义规则丰富，具体使用可以参考 [Ajv](https://ajv.js.org/) 这个 JSON 校验库。\r\n\r\n#### 3.1.2. stringify 方法的生成\r\n\r\nfast-json-stringify 会根据刚才定义的 scheme，拼接生成出实际的函数代码字符串，然后使用 [Function 构造函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)在运行时动态生成对应的 stringify 函数。\r\n\r\n在代码生成上，首先它会注入预先定义好的各类工具方法，这一部分不同的 scheme 都是一样的：\r\n\r\n```JavaScript\r\nvar code = `\r\n    'use strict'\r\n  `\r\n\r\n  code += `\r\n    ${$asString.toString()}\r\n    ${$asStringNullable.toString()}\r\n    ${$asStringSmall.toString()}\r\n    ${$asNumber.toString()}\r\n    ${$asNumberNullable.toString()}\r\n    ${$asIntegerNullable.toString()}\r\n    ${$asNull.toString()}\r\n    ${$asBoolean.toString()}\r\n    ${$asBooleanNullable.toString()}\r\n  `\r\n```\r\n\r\n其次，就会根据 scheme 定义的具体内容生成 stringify 函数的具体代码。而生成的方式也比较简单：通过遍历 scheme。\r\n\r\n遍历 scheme 时，根据定义的类型，在对应代码处插入相应的工具函数用于键值转换。例如上面例子中`name`这个属性：\r\n\r\n```JavaScript\r\nvar accessor = key.indexOf('[') === 0 ? sanitizeKey(key) : `['${sanitizeKey(key)}']`\r\nswitch (type) {\r\n    case 'null':\r\n        code += `\r\n            json += $asNull()\r\n        `\r\n        break\r\n    case 'string':\r\n        code += nullable ? `json += obj${accessor} === null ? null : $asString(obj${accessor})` : `json += $asString(obj${accessor})`\r\n        break\r\n    case 'integer':\r\n        code += nullable ? `json += obj${accessor} === null ? null : $asInteger(obj${accessor})` : `json += $asInteger(obj${accessor})`\r\n        break\r\n    ……\r\n```\r\n\r\n上面代码中的`code`变量保存的就是最后生成的函数体的代码串。由于在 scheme 定义中，`name`为`string`类型，且不为空，所以会在`code`中添加如下一段代码字符串：\r\n\r\n```JavaScript\r\n\"json += $asString(obj['name'])\"\r\n```\r\n\r\n> 由于还需要处理数组、及联对象等复杂情况，实际的代码省略了很多。\r\n\r\n然后，生成的完整的`code`字符串大致如下：\r\n\r\n```JavaScript\r\nfunction $asString(str) {\r\n    // ……\r\n}\r\nfunction $asStringNullable(str) {\r\n    // ……\r\n}\r\nfunction $asStringSmall(str) {\r\n    // ……\r\n}\r\nfunction $asNumber(i) {\r\n    // ……\r\n}\r\nfunction $asNumberNullable(i) {\r\n    // ……\r\n}\r\n/* 以上是一系列通用的键值转换方法 */\r\n\r\n/* $main 就是 stringify 的主体函数 */\r\nfunction $main(input) {\r\n    var obj = typeof input.toJSON === 'function'\r\n        ? input.toJSON()\r\n        : input\r\n\r\n    var json = '{'\r\n    var addComma = false\r\n    if (obj['name'] !== undefined) {\r\n        if (addComma) {\r\n            json += ','\r\n        }\r\n        addComma = true\r\n        json += '\"name\":'\r\n        json += $asString(obj['name'])\r\n    }\r\n\r\n    // …… 其他属性(status、working)的拼接\r\n\r\n    json += '}'\r\n    return json\r\n}\r\n\r\nreturn $main\r\n```\r\n\r\n最后，将`code`字符串传入 Function 构造函数来创建相应的 stringify 函数。\r\n\r\n```JavaScript\r\n// dependencies 主要用于处理包含 anyOf 与 if 语法的情况\r\ndependenciesName.push(code)\r\nreturn (Function.apply(null, dependenciesName).apply(null, dependencies))\r\n```\r\n\r\n### 3.2. slow-json-stringify\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/6/4/16b223db88e935e6?w=2004&h=92&f=png&s=66851)\r\n\r\n[slow-json-stringify](https://github.com/lucagez/slow-json-stringify) 虽然名字叫 \"slow\"，但其实是一个 \"fast\" 的 stringify 库（命名很调皮）。\r\n\r\n> The slowest stringifier in the known universe. Just kidding, it's the fastest (:\r\n\r\n它的实现比前面提到的 fast-json-stringify 更轻量级，思路也很巧妙。同时它[在很多场景下效率会比 fast-json-stringify 更快](https://github.com/lucagez/slow-json-stringify/blob/master/benchmark.md)。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/6/5/16b25784d49d825a?w=1200&h=488&f=png&s=42368)\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/6/5/16b25793da834834?w=1092&h=396&f=png&s=29644)\r\n\r\n#### 3.2.1. scheme 的定义方式\r\n\r\nslow-json-stringify 的 scheme 定义更自然与简单，主要就是将键值替换为类型描述。还是上面这个对象的例子，scheme 会变为\r\n\r\n```JavaScript\r\n{\r\n    name: 'string',\r\n    status: 'number',\r\n    working: 'boolean'\r\n}\r\n```\r\n\r\n确实非常直观。\r\n\r\n#### 3.2.2. stringify 方法的生成\r\n\r\n不知道你注意到没有\r\n\r\n```JavaScript\r\n// scheme\r\n{\r\n    name: 'string',\r\n    status: 'number',\r\n    working: 'boolean'\r\n}\r\n\r\n// 目标对象\r\n{\r\n    name: 'alienzhou',\r\n    status: 6,\r\n    working: true\r\n}\r\n```\r\n\r\nscheme 和原对象的结构是不是很像？\r\n\r\n这种 scheme 的巧妙之处在于，这样定义之后，我们可以先把 scheme `JSON.stringify`一下，然后“扣去”所有类型值，最后等着我们的就是把实际的值直接填充到 scheme 对应的类型声明处。\r\n\r\n具体如何操作呢？\r\n\r\n首先，可以直接对 scheme 调用`JSON.stringify()`来生成基础模版，同时借用`JSON.stringify()`的第二个参数来作为遍历方法收集属性的访问路径：\r\n\r\n```JavaScript\r\nlet map = {};\r\nconst str = JSON.stringify(schema, (prop, value) => {\r\n    const isArray = Array.isArray(value);\r\n    if (typeof value !== 'object' || isArray) {\r\n        if (isArray) {\r\n            const current = value[0];\r\n            arrais.set(prop, current);\r\n        }\r\n\r\n        _validator(value);\r\n\r\n        map[prop] = _deepPath(schema, prop);\r\n        props += `\"${prop}\"|`;\r\n    }\r\n    return value;\r\n});\r\n```\r\n\r\n此时，`map` 里收集所有属性的访问路径。同时生成的`props`可以拼接为匹配相应类型字符还的正则表达式，例如我们这个例子里的正则表达式为`/name|status|working\"(string|number|boolean|undef)\"|\\\\[(.*?)\\\\]/`。\r\n\r\n然后，根据正则表达式来顺序匹配这些属性，替换掉属性类型的字符串，换成统一的占位字符串`\"__par__\"`，并基于`\"__par__\"`拆分字符串：\r\n\r\n\r\n```JavaScript\r\nconst queue = [];\r\nconst chunks = str\r\n    .replace(regex, (type) => {\r\n      switch (type) {\r\n        case '\"string\"':\r\n        case '\"undefined\"':\r\n          return '\"__par__\"';\r\n        case '\"number\"':\r\n        case '\"boolean\"':\r\n        case '[\"array-simple\"]':\r\n        case '[null]':\r\n          return '__par__';\r\n        default:\r\n          const prop = type.match(/(?<=\\\").+?(?=\\\")/)[0];\r\n          queue.push(prop);\r\n          return type;\r\n      }\r\n    })\r\n    .split('__par__');\r\n```\r\n\r\n这样你就会得到`chunks`和`props`两个数组。`chunks`里包含了被分割的 JSON 字符串。以例子来说，两个数组分别如下\r\n\r\n```JavaScript\r\n// chunks\r\n[\r\n    '{\"name\":\"',\r\n    '\",\"status\":\"',\r\n    '\",\"working\":\"',\r\n    '\"}'\r\n]\r\n\r\n// props\r\n[\r\n    'name',\r\n    'status',\r\n    'working'\r\n]\r\n```\r\n\r\n最后，由于 map 中保存了属性名与访问路径的映射，因此可以根据 prop 访问到对象中某个属性的值，循环遍历数组，将其与对应的 chunks 拼接即可。\r\n\r\n从代码量和实现方式来看，这个方案会更轻便与巧妙，同时也不需要通过 Function、eval 等方式动态生成或执行函数。\r\n\r\n## 4. 总结\r\n\r\n虽然不同库的实现有差异，但从整体思路上来说，实现高性能 stringify 的方式都是一样的：\r\n\r\n1. 开发者定义 Object 的 JSON scheme；\r\n2. stringify 库根据 scheme 生成对应的模版方法，模版方法里会对属性与值进行字符串拼接（显然，属性访问与字符串拼接的效率要高多了）；\r\n3. 最后开发者调用返回的方法来 stringify Object 即可。\r\n\r\n归根到底，它本质上是通过静态的结构信息将优化与分析前置了。\r\n\r\n## Tips\r\n\r\n最后，还是想提一下\r\n\r\n- 所有的 benchmark 只能作为一个参考，具体是否有性能提升、提升多少还是建议你在实际的业务中测试；\r\n- fast-json-stringify 中使用到了 Function 构造函数，因此建议不要将用户输入直接用作 scheme，以防一些安全问题。\r\n\r\n---\r\n\r\n好了，这期的「漫游 Github」就到这里了。本系列会不定期和大家一起看一看、聊一聊、学一学 github 上有趣的项目，不仅学习一些技术点，还可以了解作者的技术思考，欢迎感兴趣的小伙伴关注。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/71757685-7807ac00-2ed2-11ea-97e7-c93eec7b6017.png)\r\n\r\n---","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/30","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/30/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/30/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/30/events","html_url":"https://github.com/alienzhou/blog/issues/30","id":446369405,"node_id":"MDU6SXNzdWU0NDYzNjk0MDU=","number":30,"title":"如何在零JS代码情况下实现一个实时聊天功能❓","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845018,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE4","url":"https://api.github.com/repos/alienzhou/blog/labels/CSS","name":"CSS","color":"7057ff","default":false,"description":""},{"id":1159855196,"node_id":"MDU6TGFiZWwxMTU5ODU1MTk2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%9C%8D%E5%8A%A1%E7%AB%AF","name":"服务端","color":"0bbaae","default":false,"description":""},{"id":1159845015,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%B5%8F%E8%A7%88%E5%99%A8","name":"浏览器","color":"cfd3d7","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2019-05-21T00:52:44Z","updated_at":"2019-05-21T00:52:44Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 引言\r\n\r\n前段时间在 github 上看到了一个很“trick”的项目：用纯 CSS（即不使用 JavaScript）实现一个聊天应用 —— [css-only-chat](https://github.com/kkuchta/css-only-chat)。即下图所示效果。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/5/20/16ad56d29a8af1c6?w=1503&h=870&f=gif&s=5194924)\r\n\r\n在我们的印象里，实现一个简单的聊天应用（消息发送与多页面同步）并不困难 —— 这是在我们有 JavaScript 的帮助下。而如果让你只能使用 CSS，不能有前端的 JavaScript 代码，那你能够实现么？\r\n\r\n> 原版是用 Ruby 写的后端。可能大家对 Ruby 不太了解，所以我按照原作者思路，用 NodeJS 实现了一版 [css-only-chat-node](https://github.com/alienzhou/css-only-chat-node)，对大家来说可能会更易读些。\r\n\r\n## 1. 我们要解决什么问题\r\n\r\n首先强调一下，服务端的代码肯定还是需要写的，而且这部分显然不能是 CSS。所以这里的“纯 CSS”主要指在浏览器端只使用 CSS。\r\n\r\n回忆一下，如果使用 JavaScript 来实现上图中展示的聊天功能，有哪些问题需要处理呢？\r\n\r\n- 首先，需要添加按钮的`click`事件监听，包括字符按钮的点击与发送按钮的点击；\r\n- 其次，点击相应按钮后，要将信息通过 Ajax 的方式发送到后端服务；\r\n- 再者，要实现实时的消息展示，一般会建立一个 WebSocket 连接；\r\n- 最后，对于后端同步来的消息，我们会在浏览器端操作 DOM API 来改变 DOM 内容，展示消息记录。\r\n\r\n涉及到 JavaScript 的操作主要就是上面四个了。但是，现在我们只能使用 CSS，那对于上面这几个操作，可以用什么方式实现呢？\r\n\r\n## 2. Trick Time\r\n\r\n### 2.1. 解决“点击监听”的问题\r\n\r\n使用 JavaScript 的话一行代码可以搞定：\r\n\r\n```JavaScript\r\ndocument.getElementById('btn').addEventListener('click', function () {\r\n    // ……\r\n});\r\n```\r\n\r\n使用 CSS 的话，其实有个伪类可以帮我们，即`:active`。它可以选择激活的元素，而当我们点击某个元素时，它就会处于激活状态。\r\n\r\n所以，对于上面动图中的26个字母（再加上 send 按钮），可以分配不同的`classname`，然后设置伪类选择器，这样就可以在点击该字母对应的按钮时触发命中某个 CSS 规则。例如可以对字符“a”设置如下规则用于“捕获”点击：\r\n\r\n```CSS\r\n.btn_a:active {\r\n    /* …… */ \r\n}\r\n```\r\n\r\n### 2.2. 发送请求\r\n\r\n如果有 JavaScript 的帮助，发送请求只需要用个 XHR 即可，很方便。而对于 CSS，如果要想发一个请求的话有什么办法么？\r\n\r\n可以使用`background-image`属性，将它指定为某个 URL，这样前端就会向服务器发起一个背景图片的请求。之所以可以使用`background-image`属性还因为：浏览器只有在该 CSS 选择器规则被实际应用到 DOM 元素后才会实际发起`background-image`的请求。例如下面这个规则：\r\n\r\n```CSS\r\n.btn_a:active {\r\n    background-image: url('/keys/a');\r\n}\r\n```\r\n\r\n只有在字符“a”被点击后，浏览器才会向服务器请求`/keys/a`这张“图片”。而在服务器端，通过判断 URL 可以知道前端点击了哪个字符。例如，对于按钮“b”会有如下规则：\r\n\r\n```CSS\r\n.btn_b:active {\r\n    background-image: url('/keys/b');\r\n}\r\n```\r\n\r\n这样就相当于实现了在 URL（`/keys/a`与`/keys/b`） 中“传参”。 \r\n\r\n### 2.3. 实时消息展示\r\n\r\n实时的消息展示，核心会用到一种叫“服务器推”的技术。其中比较常见方式有：\r\n\r\n- 使用 JavaScript 来和服务端建立 WebSocket 连接\r\n- 使用 JavaScript 创建定时器，定时发送请求轮询\r\n- 使用 JavaScript 和服务端配合来实现长轮询\r\n\r\n但这些方法都无法规避 JavaScript，显然不符合咱们的要求。其实还有一种方式，我在[《各类“服务器推”技术原理与实例》](https://juejin.im/post/5b135b78f265da6e420eab7d)中也有提到，那就是基于 iframe 的长连接流（stream）模式。\r\n\r\n这里我们主要是借鉴了“长连接流”这种模式。让我们的页面永远处于一个未加载完成的状态。但是，由于请求头中包含`Transfer-Encoding: chunked`，它会告诉浏览器，虽然页面没有返回结束，但你可以开始渲染页面了。正是由于该请求的响应永远不会结束，所以我们可以不断向其中写入新的内容，来更新页面展示。\r\n\r\n实现起来也非常简单。`http.ServerResponse`类本身就是继承自`Stream`的，所以只要在需要更新页面内容时调用`.write()`方法即可。例如下面这段代码，可以每隔2s在页面上动态添加 \"hello\" 字符串而不需要任何浏览器端的配合（也就不需要写 JavaScript 代码了）：\r\n\r\n```JavaScript\r\nconst http = require('http');\r\nhttp.createServer((req, res) => {\r\n    res.setHeader('connection', 'keep-alive');\r\n    res.setHeader('content-type', 'text/html; charset=utf-8');\r\n    res.statusCode = 200;\r\n    res.write('I will update by myself');\r\n\r\n    setInterval(() => res.write('<br>hello'), 2000);\r\n}).listen(8085);\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/5/20/16ad547da08e7d73?w=1077&h=534&f=gif&s=150336)\r\n\r\n### 2.4. 改变页面信息\r\n\r\n在上一节我们已经可以通过 Stream 的方式，不借助 JavaScript 即可动态改变页面内容了。但是如果你细心会发现，这种方式只能不断“append”内容。而在我们的例子中，看起来更像是能够动态改变某个 DOM 中的文本，例如随着点击不同按钮，“Current Message”后面的文本会不断变化。\r\n\r\n这里其实也有个很“trick”的方式。下图这个部分（我们姑且叫它 ChatPanel 吧）\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/5/20/16ad543f357344b1?w=1300&h=330&f=png&s=93410)\r\n\r\n其实我们每次调用`res.write()`时都会返回一个全新的 ChatPanel 的 HTML 片段。于此同时，还会附带一个`<style>`元素，将之前的 ChatPanel 设为`display: none`。所以看起来像是更新了原来的 ChatPanel 的内容，但其实是 append 了一个新的，同时隐藏之前的 ChatPanel。\r\n\r\n### 2.5. 点击重复的按钮\r\n\r\n到目前为止，基本的方案都有了，但还有一个重要的问题：\r\n\r\n在 CSS 规则中的`background-image`只会在第一次应用到元素时发起请求，之后就不会再向服务器请求了。也就是说，用\r\n\r\n```CSS\r\n.btn_a:active {\r\n    background-image: url('/keys/a');\r\n}\r\n```\r\n\r\n这种规则，“a” 这个按钮点过一次之后，下次再点击就毫无反应了 —— 即后端收不到请求了。\r\n\r\n要解决这个问题有一个方法。可以在每次返回的新的 ChatPanel（ChatPanel 是啥咱们在上一节中提到了，如果忘了可以回去看下）里，为每个字符按钮都应用一套新的样式规则，并设置新的背景图 URL。例如我们第一次点击了“h”之后，返回的 ChatPanel 里的按钮“a”的`classname`会该成`btn_h_a`，对应的 CSS 规则改为：\r\n\r\n```CSS\r\n.btn_h_a:active {\r\n    background-image: url('/keys/h_a');\r\n}\r\n```\r\n\r\n再次点击“i”之后，ChatPanel 里对应的按钮的样式规则改为：\r\n\r\n```CSS\r\n.btn_hi_a:active {\r\n    background-image: url('/keys/hi_a');\r\n}\r\n```\r\n\r\n### 2.6. 存储\r\n\r\n为了能够保存未发送的内容（点击 send 按钮之前的输入内容），以及同步历史消息，需要有个地方存储用户输入。同时我们还会为每个连接设定一个唯一的用户 ID。在原版的 css-only-chat 中使用了 Redis。我在 css-only-chat-node 中为了简便，直接存储在了运行时的内存变量中了。\r\n\r\n## 3. 最后\r\n\r\n也许有朋友会问，这个 DEMO 有什么实用价值么？可以发展成一个可用的聊天工具么？\r\n\r\n好吧，其实我觉得没有太大用。但是里面涉及到的一些“知识点”到是了解下也无妨。我们每天面对那么多无趣的需求，偶尔看看这种“有意思”的项目也算是放松一下吧。\r\n\r\n最后，如果想看具体的运行效果，或者想了解代码的细节，可以看这里：\r\n\r\n- [css-only-chat-node](https://github.com/alienzhou/css-only-chat-node)：由于原版是 Ruby 写的，所以实现了一个 NodeJS 版的便于大家查看\r\n- [css-only-chat](https://github.com/kkuchta/css-only-chat)：css-only-chat 的原版仓库，使用 Ruby 实现\r\n\r\nJust have fun! 😜","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/29","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/29/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/29/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/29/events","html_url":"https://github.com/alienzhou/blog/issues/29","id":445055951,"node_id":"MDU6SXNzdWU0NDUwNTU5NTE=","number":29,"title":"🛠如何快速开发一个自己的项目脚手架？","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""},{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2019-05-16T16:42:00Z","updated_at":"2019-05-16T16:42:00Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 引言\r\n\r\n下面是一个使用脚手架来初始化项目的典型例子。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/5/16/16ac081750971790?w=1312&h=533&f=gif&s=1477981)\r\n\r\n随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是`create-react-app`和`vue-cli`，它们可以帮助我们初始化配置、生成项目结构、自动安装依赖，最后我们一行指令即可运行项目开始开发，或者进行项目构建（build）。\r\n\r\n这些脚手架提供的都是普遍意义上的最佳实践，但是我在开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：\r\n\r\n- 通过调整插件与配置实现 Webpack 打包性能优化后\r\n- 删除脚手架构建出来的部分功能\r\n- 项目架构调整\r\n- 融合公司开发工具\r\n- ……\r\n\r\n总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。\r\n\r\n## 1. 脚手架怎么工作？\r\n\r\n功能丰富程度不同的脚手架，复杂程度自然也不太一样。但是总体来说，脚手架的工作大体都会包含几个步骤：\r\n\r\n- 初始化，一般在这个时候会进行环境的初始化，做一些前置的检查\r\n- 用户输入，例如用 vue-cli 的时候，它会“问”你很多配置选项\r\n- 生成配置文件\r\n- 生成项目结构，这是候可能会使用一个项目模版\r\n- 安装依赖\r\n- 清理、校验等收尾工作\r\n\r\n此外，你还需要处理命令行行为等。往往我们只是想轻量级、快速得创建一个特定场景的脚手架（不用想vue-cli那么完备）。而对于想要快速创建一个脚手架，其实我们不用完全从零开始。[Yeoman](https://yeoman.io/) 就是一个可以帮我们快速创建脚手架的工具。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/5/16/16ac137b8509c628?w=2296&h=854&f=png&s=377965)\r\n\r\n可能很多同学都不太了解，那么先简单介绍一下 Yeoman 是什么，又是如何帮我们来简化脚手架搭建的。\r\n\r\n首先，Yeoman 可以简单理解为是一个脚手架的运行框架，它定义了一个脚手架在运行过程中所要经历的各个阶段（例如我们上面说的，可能会先读取用户输入，然后生成项目文件，最后安装依赖），我们所需要的就是在生命周期的对应阶段，填充对应的操作代码即可。而我们填充代码的地方，在 Yeoman 中叫做 generator，物如其名，Yeoman 通过调用某个 generator 即可生成（generate）对应的项目。\r\n\r\n如果你还不是特别清楚它们之间的关系，那么可以举个小例子：\r\n\r\n将脚手架开发类比为前端组件开发，Yeoman 的角色就像是 React，是一个框架，尤其是定义了组件的生命周期函数；而 generator 类似于你写的一个 React 业务组件，根据 React 的规则在各个生命周期中填代码即可。\r\n\r\n[Yeoman 内置的“生命周期”方法执行顺序如下：](https://yeoman.io/authoring/running-context.html#the-run-loop)\r\n\r\n1. initializing\r\n2. prompting\r\n3. default\r\n4. writing\r\n5. conflicts\r\n6. install\r\n7. end\r\n\r\n其中 default 阶段会执行你自定义地各种方法。\r\n\r\n同时，Yeoman 还集成了脚手架开发中常用的各类工具，像是文件操作、模版填充、终端上的用户交互功能，命令行等，并且封装成了简单易用的方法。\r\n\r\n通过这两点，Yeoman 可以帮我们大大规范与简化脚手架的开发。\r\n\r\n## 2. 开发一个自己的脚手架\r\n\r\n了解了一些脚手架的工作方式与 Yeoman 的基本概念，咱们就可以来创建一个属于自己的脚手架。作为例子，这个脚手架的功能很简单，它会为我们创建一个最简版的基于 Webpack 的前端项目。最终脚手架使用效果如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/5/16/16ac081750971790?w=1312&h=533&f=gif&s=1477981)\r\n\r\n### 2.1. 准备一个项目模版\r\n\r\n脚手架是帮助我们快速生成一套既定的项目架构、文件、配置，而最常见的做法的就是先写好一套项目框架模版，等到脚手架要生成项目时，则将这套模版拷贝到目标目录下。这里其实会有两个小点需要关注。\r\n\r\n第一个是模版内变量的填充。\r\n\r\n在模版中的某些文件内容可能会需要生成时动态替换，例如根据用户在终端中输入的内容，动态填充`package.json`中的`name`值。而 Yeoman 内置了 [ejs](https://github.com/mde/ejs) 作为模版引擎，可以直接使用。\r\n\r\n第二个就是模版的放置位置。\r\n\r\n一种是直接放在本地，也就是直接放到 generator 中，跟随 generator 一起下载，每次安装都是本地拷贝，速度很快，但是项目模版自身的更新升级比较困难，需要提示用户升级 generator。\r\n\r\n另一种则是将模版文件放到某个服务器上，每次使用脚手架初始化时通过某个地址动态下载，想要更新升级模版会很方便，通常会选择托管在 github 上。\r\n\r\n关于第二个模版放置究竟是选择在本地好，还是远端好，其实还是依据你个人的业务场景而定，在不同的场景的限制的需求不同，我之前既写过模版放在本地的脚手架（即和脚手架一起通过 npm 安装），也写过托管在 git 仓库上的这种方式。\r\n\r\n回到我们「创建一个最简版的基于 Webpack 的前端项目」的目标，我准备了一个[项目模版](https://github.com/alienzhou/webpack-kickoff-template)，之后就会用它来作为脚手架生成的项目内容。\r\n\r\n### 2.2. 创建 generator（yeoman-generator）\r\n\r\n创建 Yeoman 的 generator 需要遵循它的规则。\r\n\r\n首先是 generator 命名规则。需要以`generator`打头，横线连接。例如你想创建一个名为 webpack-kickoff 的 generator，包名需要取成 `generator-webpack-kickoff`。\r\n\r\n这样，当你通过\r\n\r\n```bash\r\nnpm i -g yo\r\n```\r\n\r\n安装完 Yeoman 的 CLI 后，就可以通过`yo`命令来使用 generator 来启动脚手架：\r\n\r\n```\r\nyo webpack-kickoff\r\n```\r\n\r\n这里的 webpack-kickoff 就是包名里`generator-`后面的内容，Yeoman 会按这个规则去全局找相匹配的包。\r\n\r\n其次，依据 Yeoman 的规范，默认情况下你需要在项目（即 generator）的`generators/app/`目录下创建`index.js`，在其中写入你的脚手架工作流程。当然，也可以通过[修改配置来扩展或改变这个规则](https://yeoman.io/authoring/index.html#folder-tree)。\r\n\r\n此外，你创建的 generator 类需要继承 yeoman-generator。所以我们会在`generators/app/index.js`中写如下代码：\r\n\r\n```JavaScript\r\nconst Generator = require('yeoman-generator');\r\nclass WebpackKickoffGenerator extends Generator {\r\n    constructor(params, opts) {\r\n        super(params, opts);\r\n    }\r\n}\r\nmodule.exports = WebpackKickoffGenerator;\r\n```\r\n\r\n还记得之前提到的“生命周期”方法么？包括 initializing、prompting、default、writing、conflicts、install 和 end。除了`default`，其他都代表了 Generator 中的一个同名方法，你需要的就是在子类中重写后所需的对应方法。`default`阶段则会执行用户定义的类方法。\r\n\r\n例如，你想在初始化时打印下版本信息，可以这么做：\r\n\r\n```JavaScript\r\nconst Generator = require('yeoman-generator');\r\nclass WebpackKickoffGenerator extends Generator {\r\n    constructor(params, opts) {\r\n        super(params, opts);\r\n    }\r\n    \r\n    initializing() {\r\n        const version = require('../../package.json').version;\r\n        this.log(version);\r\n    }\r\n}\r\nmodule.exports = WebpackKickoffGenerator;\r\n```\r\n\r\n可见，剩下的工作就是在 WebpackKickoffGenerator 类中填充各种方法的实现细节了。\r\n\r\n### 2.3. 处理用户交互\r\n\r\n脚手架工作中一般都会有一些用户自定义的内容，例如创建的项目目录名，或者是否启用某个配置等。这些交互一般都是通过交互式的终端来实现的，例如下面这个功能。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/5/16/16ac080688a52242?w=810&h=227&f=png&s=30134)\r\n\r\n可以使用 [Inquirer.js](https://github.com/SBoudrias/Inquirer.js) 来实现。而 Yeoman 已经帮我们集成好了，直接在 generator 里调用 `this.prompt` 即可。\r\n\r\n在用户交互部分的需求也比较简单，只需要询问用户所需创建的项目目录名即可，随后也会作为项目名。按照 Yeoman 的流程规范，我们将该部分代码写在 `prompting` 方法中：\r\n\r\n```JavaScript\r\nclass WebpackKickoffGenerator extends Generator {\r\n    // ……\r\n    prompting() {\r\n        const done = this.async();\r\n\r\n        const opts = [{\r\n            type: 'input',\r\n            name: 'dirName',\r\n            message: 'Please enter the directory name for your project：',\r\n            default: 'webpack-app',\r\n            validate: dirName => {\r\n                if (dirName.length < 1) {\r\n                    return '⚠️  directory name must not be null！';\r\n                }\r\n                return true;\r\n            }\r\n        }];\r\n\r\n        return this.prompt(opts).then(({dirName}) => {\r\n            this.dirName = dirName;\r\n            done();\r\n        });\r\n    }\r\n    // ……\r\n}\r\n```\r\n\r\n注意，由于用户交互是一个“异步”的行为，为了让后续生命周期方法在“异步”完成后再继续执行，需要调用`this.async()`方法来通知方法为异步方法，避免顺序执行完同步代码后直接调用下一阶段的生命周期方法。调用后会返回一个函数，执行函数表明该阶段完成。\r\n\r\n### 2.4. 下载模版\r\n\r\n正如2.1.中所述，我们选择将模版托管在 [github](https://github.com/alienzhou/webpack-kickoff-template) 上，因此在生成具体项目代码前，需要将相应的文件下载下来。可以使用 [download-git-repo](https://github.com/flipxfx/download-git-repo) 来快速实现。\r\n\r\n```JavaScript\r\nclass WebpackKickoffGenerator extends Generator {\r\n    // ……\r\n    _downloadTemplate() {\r\n        return new Promise((resolve, reject) => {\r\n            const dirPath = this.destinationPath(this.dirName, '.tmp');\r\n            download('alienzhou/webpack-kickoff-template', dirPath, err => {\r\n                if (err) {\r\n                    reject(err);\r\n                    return;\r\n                }\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n    // ……\r\n}\r\n```\r\n\r\n这里我们使用了`this.destinationPath()`方法，该方法主要用于获取路径。不传参时返回当前命令行运行的目录；如果收到多个参数，则会进行路径的拼接。\r\n\r\n此外，如果你细心的话，会发现`_downloadTemplate()`方法带了一个下划线前缀。这是 Yeoman 中的一个约定：Yeoman 执行顺序中有个`default`阶段，该阶段包含了所有用户自定义的类方法。但是，如果某些方法你不希望被 Yeoman 的脚手架流程直接调用，而是作为工具方法提供给其他类方法，则可以添加一个下划线前缀。对于这种命名的方法，则会在`default`阶段被忽略。\r\n\r\n### 2.5. 模版文件拷贝\r\n\r\n项目模版下载完毕后，下面就可以将相关的目录、文件拷贝到目标文件夹中。这些都可以在`writing`阶段操作。此时需要遍历模版中的所有目录，将所有文件进行模版填充与拷贝。遍历方式如下：\r\n\r\n```JavaScript\r\nclass WebpackKickoffGenerator extends Generator {\r\n    // ……\r\n    _walk(filePath, templateRoot) {\r\n        if (fs.statSync(filePath).isDirectory()) {\r\n            fs.readdirSync(filePath).forEach(name => {\r\n                this._walk(path.resolve(filePath, name), templateRoot);\r\n            });\r\n            return;\r\n        }\r\n\r\n        const relativePath = path.relative(templateRoot, filePath);\r\n        const destination = this.destinationPath(this.dirName, relativePath);\r\n        this.fs.copyTpl(filePath, destination, {\r\n            dirName: this.dirName\r\n        });\r\n    }\r\n    // ……\r\n}\r\n```\r\n\r\n这里使用了`this.fs.copyTpl()`方法，它支持文件拷贝，同时还可以指定相应的模版参数，此外，如果出现重名覆盖情况会在控制台自动输出相应信息。\r\n\r\n最后，把下载与拷贝整合起来即可完成`writing`阶段。\r\n\r\n```JavaScript\r\nclass WebpackKickoffGenerator extends Generator {\r\n    // ……\r\n    writing() {\r\n        const done = this.async();\r\n        this._downloadTemplate()\r\n            .then(() => {\r\n                const templateRoot = this.destinationPath(this.dirName, '.tmp');\r\n                this._walk(templateRoot, templateRoot);\r\n                fs.removeSync(templateRoot);\r\n                done();\r\n            })\r\n            .catch(err => {\r\n                this.env.error(err);\r\n            });\r\n    }\r\n    // ……\r\n}\r\n```\r\n\r\n### 2.6. 依赖安装\r\n\r\n到目前，脚手架已经可以帮我们把项目开发所需的配置、目录结构、依赖清单都准备好了。这时候可以进一步帮开发人员将依赖安装完毕，这样脚手架创建项目完成后，开发人员就可以直接开发了。\r\n\r\nYeoman 也提供了`this.npmInstall()`来方法来实现 npm 包的安装：\r\n\r\n```JavaScript\r\nclass WebpackKickoffGenerator extends Generator {\r\n    // ……\r\n    install() {\r\n        this.npmInstall('', {}, {\r\n            cwd: this.destinationPath(this.dirName)\r\n        });\r\n    }\r\n    // ……\r\n}\r\n```\r\n\r\n到这里，脚手架的核心功能就完成了。已经可以使用咱们的这个 generator 来快速创建项目了。很简单吧~\r\n\r\n> 完整的代码可以参考 [generator-webpack-kickoff](https://github.com/alienzhou/generator-webpack-kickoff)。\r\n\r\n## 3. 使用脚手架 🚀\r\n\r\n使用该脚手架会同时需要 Yeoman 与上述咱们刚创建的 yeoman-generator。当然，有一个前提，Yeoman 与这个 generator 都需要全局安装。全局安装 Yeoman 没啥有问题（`npm install -g yo`），处理 generator-webpack-kickoff 的话可能有几种方式：\r\n\r\n1. 直接发布到 npm，然后正常全局安装\r\n2. 直接手动拷贝到全局 node_modules\r\n3. 使用`npm link`将某个目录链接到全局\r\n\r\n依据2.2.节的内容，咱们的 generator 名称为 generator-webpack-kickoff。由于我的包已经发到 npm 上了，所以要使用该脚手架可以运行如下指令：\r\n\r\n```bash\r\n# 安装一次即可\r\nnpm i -g yo\r\nnpm i -g generator-webpack-kickoff\r\n\r\n# 启动脚手架\r\nyo webpack-kickoff\r\n```\r\n\r\n## 4. 优化\r\n\r\n从上文这个例子可以看出，实现一个脚手架非常简单。例子虽小，但也包含了脚手架开发的主要部分。当然，这篇文章为了简化，省略了一些“优化”功能。例如\r\n\r\n- 项目目录的重名检测，生成项目时，检查是否目录已存在，并提示警告\r\n- 项目模版的缓存。虽然我们使用 github 托管方式，但也可以考虑不必每次都重新下载，可以放一份本地缓存，然后每天或每周更新；\r\n- CLI 的优化。[完整版](https://github.com/alienzhou/generator-webpack-kickoff)里还会包含一些更丰富的 CLI 使用，例如我们在动图中看到的 loading 效果、头尾显示的信息面板等。这些工具包括\r\n    - [ora](https://github.com/sindresorhus/ora)，用于创建 spinner，也就是上面所说的 loading 效果\r\n    - [chalk](https://github.com/chalk/chalk)，用于打印彩色的信息\r\n    - [update-notifier](https://github.com/yeoman/update-notifier)，用于检查包的线上版本与本地版本\r\n    - [beeper](https://github.com/sindresorhus/beeper)，可以“哔”一下你，例如出错的时候\r\n    - [boxen](https://github.com/sindresorhus/boxen)，创建头尾的那个小“面板”\r\n- 版本检查。上面提到可以用 [update-notifier](https://github.com/yeoman/update-notifier) 来检查版本。所以可以在 initializing 阶段进行版本检查，提示用户更新脚手架。\r\n\r\n## 最后\r\n\r\n本文通过一个简单的例子来告诉大家如何使用 Yeoman 快速创建脚手架。要了解更多 yeoman-generator 的开发与使用，可以参考[社区里大家写的各类 generator](keywords:yeoman-generator)。目前在 npm 上有超过 8000 个 yeoman-generator，也许就会有你的菜。\r\n\r\n> 文中完成的代码请查看 [generator-webpack-kickoff](https://github.com/alienzhou/generator-webpack-kickoff)。","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/28","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/28/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/28/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/28/events","html_url":"https://github.com/alienzhou/blog/issues/28","id":436120642,"node_id":"MDU6SXNzdWU0MzYxMjA2NDI=","number":28,"title":"✨如何实现一个通用的“划词高亮”在线笔记功能？✨🖍️","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845014,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE0","url":"https://api.github.com/repos/alienzhou/blog/labels/JavaScript","name":"JavaScript","color":"d73a4a","default":false,"description":""},{"id":1159845015,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%B5%8F%E8%A7%88%E5%99%A8","name":"浏览器","color":"cfd3d7","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":8,"created_at":"2019-04-23T10:45:18Z","updated_at":"2019-10-30T01:50:06Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 1. 什么是“划词高亮”？\r\n\r\n有些同学可能不太清楚“划词高亮”是指什么，下面就是一个典型的“划词高亮”：\r\n\r\n[![](http://upload-images.jianshu.io/upload_images/6476654-54773175bfd4fa3f?imageMogr2/auto-orient/strip)](https://alienzhou.github.io/web-highlighter/)\r\n\r\n上图的示例网站可以[点击这里访问](https://alienzhou.github.io/web-highlighter/)。用户选择一段文本（即划词），即会自动将这段选取的文本添加高亮背景，用户可以很方便地为网页添加在线笔记。\r\n\r\n笔者前段时间为线上业务实现了一个与内容结构非耦合的文本高亮笔记功能。非耦合是指**不需要为高亮功能建立特殊的页面 DOM 结构，而高亮功能对业务近乎透明**。该功能核心部分具有较强的通用性与移植性，故拿出来和大家分享交流一下。\r\n\r\n> 本文具体的核心代码已封装成独立库 [web-highlighter](https://github.com/alienzhou/web-highlighter)，阅读中如有疑问可参考其中代码↓↓。\r\n> [![image](http://upload-images.jianshu.io/upload_images/6476654-0036b39ea5538bfd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://github.com/alienzhou/web-highlighter)\r\n\r\n## 2. 实现“划词高亮”需要解决哪些问题？\r\n\r\n实现一个“划词高亮”的在线笔记功能需要解决的核心问题有两个：\r\n\r\n- 加高亮背景。即如何根据用户在网页上的选取，为相应的文本添加高亮背景；\r\n- 高亮区域的持久化与还原。即如何保存用户高亮信息，并在下次浏览时准确还原，否则下次打开页面用户高亮的信息就丢失了。\r\n\r\n一般来说，划词高亮的业务需求方主要是针对自己产出的内容，你可以比较容易对内容在网页上的排版、HTML 标签等方面进行控制。这种情况下，处理高亮需求会更方便一些，毕竟自己可以根据高亮需求调整现有内容的 HTML。\r\n\r\n而笔者面对的情况是，页面 HTML 排版结构复杂，且无法根据高亮需求来推动业务改动 HTML。这也催生出了对解决方案更通用化的要求，目标就是：**针对任意内容均可“划词高亮”并支持后续访问时还原高亮状态，而不用去关心内容的组织结构**。\r\n\r\n下面就来具体说说，如何解决上面的两个核心问题。\r\n\r\n## 3. 如何“加高亮背景”？\r\n\r\n根据动图演示我们可以知道，用户选择某一段文本（下文称为“用户选区”）后，我们会给这段文本加一个高亮背景。\r\n\r\n![image](http://upload-images.jianshu.io/upload_images/6476654-e8b5bea0afc8d56c?imageMogr2/auto-orient/strip)\r\n\r\n例如用户选择了上图中的文本（即蓝色部分）。为其加高亮的基本思路如下：\r\n\r\n1. 获取选中的文本节点：通过用户选择的区域信息，获取所有被选中的所有文本节点；\r\n2. 为文本节点添加背景色：给这些文本节点包裹一层新的元素，该元素具有指定的背景颜色。\r\n\r\n### 3.1. 如何获取选中的文本节点？\r\n\r\n#### 1）Selection API\r\n\r\n需要基于浏览器为我们提供的 [Selection API](https://developer.mozilla.org/en-US/docs/Web/API/Selection_API) 。它的[兼容性](https://caniuse.com/#search=selection)还不错。如果要支持更低版本的浏览器则需要用 polyfill。\r\n\r\n![image](http://upload-images.jianshu.io/upload_images/6476654-72543d1892c702c8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\nSelection API 可以返回一系列关于用户选区的信息。那么是不是可以通过它直接获取选取中的所有 DOM 元素呢？\r\n\r\n很遗憾并不能。但好在它可以返回选区的首尾节点信息：\r\n\r\n```JavaScript\r\nconst range = window.getSelection().getRangeAt(0);\r\nconst start = {\r\n    node: range.startContainer,\r\n    offset: range.startOffset\r\n};\r\nconst end = {\r\n    node: range.endContainer,\r\n    offset: range.endOffset\r\n};\r\n```\r\n\r\n`Range` 对象包含了选区的开始与结束信息，其中包括节点（node）与文本偏移量（offset）。节点信息不用多说，这里解释一下 offset 是指什么：例如，标签`<p>这是一段文本的示例</p>`，用户选取的部分是“一段文本”这四个字，这时首尾的 node 均为 p 元素内的文本节点（Text Node），而 startOffset 和 endOffset 分别为 2 和 6。\r\n\r\n#### 2）首尾文本节点拆分\r\n\r\n理解了 offset 的概念后，自然就发现有个问题需要解决。由于用户选区（selection）可能只包含一个文本节点的一部分（即 offset 不为 0），所以我们最后得到的用户选区所包含的节点里，也只希望有首尾文本节点的这“一部分”。对此，我们可以使用 [`.splitText()`](https://developer.mozilla.org/en-US/docs/Web/API/Text/splitText) 拆分文本节点：\r\n\r\n```JavaScript\r\n// 首节点\r\nif (curNode === $startNode) {\r\n    if (curNode.nodeType === 3) {\r\n        curNode.splitText(startOffset);\r\n        const node = curNode.nextSibling;\r\n        selectedNodes.push(node);\r\n    }\r\n}\r\n\r\n// 尾节点\r\nif (curNode === $endNode) {\r\n    if (curNode.nodeType === 3) {\r\n        const node = curNode;\r\n        node.splitText(endOffset);\r\n        selectedNodes.push(node);\r\n    }\r\n}\r\n```\r\n\r\n以上代码会依据 offset 对文本节点进行拆分。对于开始节点，只需要收集它的后半部分；而对于结束节点则是前半部分。\r\n\r\n#### 3）遍历 DOM 树\r\n\r\n到目前为止，我们准确找到了首尾节点，所以下一步就是找出“中间”所有的文本节点。这就需要遍历 DOM 树。\r\n\r\n“中间”加上引号是因为，在视觉上这些节点是位于首尾之间的，但由于 DOM 不是线性结构而是树形结构，所以这个“中间”换成程序语言，就是指深度优先遍历时，位于首尾两节点之间的所有文本节点。DFS 的方法有很多，可以递归，也可以用栈+循环，这里就不赘述了。\r\n\r\n需要提一下的是，由于我们是要为文本节点添加高亮背景，因此在遍历时只会收集文本节点。\r\n\r\n```JavaScript\r\nif (curNode.nodeType === 3) {\r\n    selectedNodes.push(curNode);\r\n}\r\n```\r\n\r\n### 3.2. 如何为文本节点添加背景色？\r\n\r\n这一步本身并不困难。在上一步的基础上，我们已经选出了所有被用户选中的 文本节点（包括拆分后的首尾节点）。对此，一个最直接的方法就是为其“包裹上”一个带背景样式的元素。\r\n\r\n具体的，我们可以给每个文本节点外加上一个 class 为 `highlight` 的 `<span>` 元素；而背景样式则通过 CSS `.highlight` 选择器设置。\r\n\r\n```JavaScript\r\n// 使用上一步中封装的方法获取选区内的文本节点\r\nconst nodes = getSelectedNodes(start, end);\r\n\r\nnodes.forEach(node => {\r\n    const wrap = document.createElement('span');\r\n    wrap.setAttribute('class', 'highlight');\r\n    wrap.appendChild(node.cloneNode(false));\r\n    node.parentNode.replaceChild(wrap);\r\n});\r\n```\r\n\r\n```CSS\r\n.highlight {\r\n    background: #ff9;\r\n}\r\n```\r\n\r\n这样就可以给被选中的文字添加一个“永久”的高亮背景了。\r\n\r\n#### p.s. 选区的重合问题\r\n\r\n然而，文本高亮里还有一个比较棘手的需求 —— 高亮区域的重合。举个例子，最开始的演示图（下图）里，第一个高亮区域和第二个高亮区域之间存在重叠部分，即“本区域高”四个字。\r\n\r\n![image](http://upload-images.jianshu.io/upload_images/6476654-3599aaf4218cd4c9?imageMogr2/auto-orient/strip)\r\n\r\n这个问题目前来看似乎还不是问题，但在结合下面要提到的一些功能与需求时，就会变成非常麻烦，甚至无法正常运行（一些开源库这块处理也不尽如人意，这也是没有选择它们的一个原因）。这里简单提一下，具体的情况我会放到后续对应的地方再详细说。\r\n\r\n## 4. 如何实现高亮选区的持久化与还原？\r\n\r\n到目前我们已经可以给选中的文本添加高亮背景了。但还有一个大问题：\r\n\r\n想象一下，用户辛辛苦苦划了很多重点（高亮），开心地退出页面后，下次访问时发现这些都不能保存时，该有多么得沮丧。因此，如果只是在页面上做“一次性”的文本高亮，那它的使用价值会大大降低。这也就促使我们的“划词高亮”功能要能够保存（持久化）这些高亮选区并正确还原。\r\n\r\n> 持久化高亮选区的核心是找到一种合适的 DOM 节点序列化方法。\r\n\r\n通过第三部分可以知道，当确定了首尾节点与文本偏移（offset）信息后，即可为其间文本节点添加背景色。其中，offset 是数值类型，要在服务器保存它自然没有问题；但是 DOM 节点不同，在浏览器中保存它只需要赋值给一个变量，但想在后端保存所谓的 DOM 则不那么直接了。\r\n\r\n### 4.1 序列化 DOM 节点标识\r\n\r\n所以这里的核心点就是找到一种方法，能够定位 DOM 节点，同时可以被保存成普通的 JSON Object，用以传给后端保存，这个过程在本文中被称为 DOM 标识 的“序列化”。而下次用户访问时，又可以从后端取回，然后“反序列化”为对应的 DOM 节点。\r\n\r\n有几种常见的方式来标识 DOM 节点：\r\n\r\n- 使用 xPath\r\n- 使用 CSS Selector 语法\r\n- 使用 tagName + index\r\n\r\n这里选择了使用第三种方式来快速实现。需要注意一点，我们通过 Selection API 取到的首尾节点一般是文本节点，而这里要记录的 tagName 和 index 都是该文本节点的父元素节点（Element Node）的，而 childIndex 表示该文本节点是其父亲的第几个儿子：\r\n\r\n```JavaScript\r\nfunction serialize(textNode, root = document) {\r\n    const node = textNode.parentElement;\r\n    let childIndex = -1;\r\n    for (let i = 0; i < node.childNodes.length; i++) {\r\n        if (textNode === node.childNodes[i]) {\r\n            childIndex = i;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    const tagName = node.tagName;\r\n    const list = root.getElementsByTagName(tagName);\r\n    for (let index = 0; index < list.length; index++) {\r\n        if (node === list[index]) {\r\n            return {tagName, index, childIndex};\r\n        }\r\n    }\r\n    return {tagName, index: -1, childIndex};\r\n}\r\n```\r\n\r\n通过该方法返回的信息，再加上 offset 信息，即定位选取的起始位置，同时也完全可发送给后端进行保存了。\r\n\r\n### 4.2 反序列化 DOM 节点\r\n\r\n基于上一节的序列化方法，从后端获取到数据后，可以很容易反序列化为 DOM 节点：\r\n\r\n```JavaScript\r\nfunction deSerialize(meta, root = document) {\r\n    const {tagName, index, childIndex} = meta;\r\n    const parent = root.getElementsByTagName(tagName)[index];\r\n    return parent.childNodes[childIndex];\r\n}\r\n```\r\n\r\n至此，我们大体已经解决了两个核心问题，这似乎已经是一个可用版本了。但**其实不然**，根据实践经验，如果仅仅是上面这些处理，往往是无法应对实际需求的，存在一些“致命问题”。\r\n\r\n但不用灰心，下面会具体来说说所谓的“致命问题”是什么，而又是如何解决并实现一个线上业务可用的通用“划词高亮”功能的。\r\n\r\n### 5. 如何实现一个生产环境可用的“划词高亮”？\r\n\r\n#### 1）上面的方案有什么问题？\r\n\r\n首先来看看上面的方案会有什么问题。\r\n\r\n当我们需要高亮文本时，会为文本节点包裹`span`元素，这就改动了页面的 DOM 结构。它可能会导致后续高亮的首尾节点与其 offset 信息其实是基于被改动后的 DOM 结构的。带来的结果有两个：\r\n\r\n- 下次访问时，程序必须按上次用户高亮的顺序还原。\r\n- 用户不能随意取消（删除）高亮区域，只能按添加顺序从后往前删。\r\n\r\n否则，就会有部分的高亮选区在还原时无法定位到正确的元素。\r\n\r\n文字可能不好理解，下面我举个例子来直观解释下这个问题。\r\n\r\n```HTML\r\n<p>\r\n    非常高兴今天能够在这里和大家分享一下文本高亮（在线笔记）的实现方式。\r\n</p>\r\n```\r\n\r\n对于上面这段 HTML，用户分别按顺序高亮了两个部分：“高兴”和“文本高亮”。那么按照上面的实现方式，这段 HTML 变成了下面这样：\r\n\r\n```HTML\r\n<p>\r\n    非常\r\n    <span class=\"highlight\">高兴</span>\r\n    今天能够在这里和大家分享一下\r\n    <span class=\"highlight\">文本高亮</span>\r\n    （在线笔记）的实现方式。\r\n</p>\r\n```\r\n\r\n对应的两个序列化数据分别为：\r\n\r\n```JavaScript\r\n// “高兴”两个字被高亮时获取的序列化信息\r\n{\r\n    start: {\r\n        tagName: 'p',\r\n        index: 0,\r\n        childIndex: 0,\r\n        offset: 2\r\n    },\r\n    end: {\r\n        tagName: 'p',\r\n        index: 0,\r\n        childIndex: 0,\r\n        offset: 4\r\n    }\r\n}\r\n```\r\n\r\n```JavaScript\r\n// “文本高亮”四个字被高亮时获取的序列化信息。\r\n// 这时候由于p下面已经存在了一个高亮信息（即“高兴”）。\r\n// 所以其内部 HTML 结构已被修改，直观来说就是 childNodes 改变了。\r\n// 进而，childIndex属性由于前一个 span 元素的加入，变为了 2。\r\n{\r\n    start: {\r\n        tagName: 'p',\r\n        index: 0,\r\n        childIndex: 2,\r\n        offset: 14\r\n    },\r\n    end: {\r\n        tagName: 'p',\r\n        index: 0,\r\n        childIndex: 2,\r\n        offset: 18\r\n    }\r\n}\r\n```\r\n\r\n可以看到，“文本高亮”这四个字的首尾节点的 `childIndex` 都被记为 2，这是由于前一个高亮区域改变了`<p>`元素下的DOM结构。如果此时“高兴”选区的高亮被用户取消，那么下次再访问页面就无法还原高亮了 —— “高兴”选区的高亮被取消了，`<p>`下自然就不会出现第三个 childNode，那么 childIndex 为 2 就找不到对应的节点了。这就导致存储的数据在还原高亮选区时出现问题。\r\n\r\n此外，还记得在第三部分末尾提到的高亮选取重合问题么？支持选取重合很容易出现如下的包裹元素嵌套情况：\r\n\r\n```HTML\r\n<p>\r\n    非常\r\n    <span class=\"highlight\">高兴</span>\r\n    今天能够在这里和大家分享一下\r\n    <span class=\"highlight\">\r\n        文本\r\n        <span class=\"highlight\">高亮</span>\r\n    </span>\r\n    （在线笔记）的实现方式。\r\n</p>\r\n```\r\n\r\n这也使得某个文本区域经过多次高亮、取消高亮后，会出现与原 HTML 页面不同的复杂嵌套结构。可以预见，当我们使用 xpath 或 CSS selector 作为 DOM 标识时，上面提到的问题也会出现，同时也使其他需求的实现更加复杂。\r\n\r\n到这里可以提一下其他开源库或产品是如何处理选区重合问题的：\r\n\r\n- 开源库 [Rangy](https://github.com/timdown/rangy) 有一个 Highlighter 模块可以实现文本高亮，但其对于选区重合的情况是将两个选区直接合并了，这是不合符我们业务需求的。\r\n- 付费产品 [Diigo](https://chrome.google.com/webstore/detail/pnhplgjpclknigjpccbcnmicgcieojbh) 直接不允许选区的重合。\r\n- Medium.com 是支持选区重合的，体验非常不错，这也是我们产品的目标。但它页面的内容区结构相较我面对的情况会更简单与更可控。\r\n\r\n所以如何解决这些问题呢？\r\n\r\n#### 2）另一种序列化 / 反序列化方式\r\n\r\n我会对第四部分提到的序列化方式进行改进。仍然记录文本节点的父节点 tagName 与 index，但不再记录文本节点在 childNodes 中的 index 与 offset，而是记录开始（结束）位置在整个父元素节点中的文本偏移量。\r\n\r\n例如下面这段 HTML：\r\n\r\n```HTML\r\n<p>\r\n    非常\r\n    <span class=\"highlight\">高兴</span>\r\n    今天能够在这里和大家分享一下\r\n    <span class=\"highlight\">文本高亮</span>\r\n    （在线笔记）的实现方式。\r\n</p>\r\n```\r\n\r\n对于“文本高亮”这个高亮选区，之前用于标识文本起始位置的信息为`childIndex = 2, offset = 14`。而现在变为`offset = 18`（从`<p>`元素下第一个文本“非”开始计算，经过18个字符后是“文”）。可以看出，这样表示的优点是，不管`<p>`内部原有的文本节点被`<span>`（包裹）节点如何分割，都不会影响高亮选区还原时的节点定位。\r\n\r\n据此，在序列化时，我们需要一个方法来将文本节点内偏移量“翻译”为其对应的父节点内部的总体文本偏移量：\r\n\r\n```JavaScript\r\nfunction getTextPreOffset(root, text) {\r\n    const nodeStack = [root];\r\n    let curNode = null;\r\n    let offset = 0;\r\n    while (curNode = nodeStack.pop()) {\r\n        const children = curNode.childNodes;\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            nodeStack.push(children[i]);\r\n        }\r\n\r\n        if (curNode.nodeType === 3 && curNode !== text) {\r\n            offset += curNode.textContent.length;\r\n        }\r\n        else if (curNode.nodeType === 3) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return offset;\r\n}\r\n```\r\n\r\n而还原高亮选区时，需要一个对应的逆过程：\r\n\r\n```JavaScript\r\nfunction getTextChildByOffset(parent, offset) {\r\n    const nodeStack = [parent];\r\n    let curNode = null;\r\n    let curOffset = 0;\r\n    let startOffset = 0;\r\n    while (curNode = nodeStack.pop()) {\r\n        const children = curNode.childNodes;\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            nodeStack.push(children[i]);\r\n        }\r\n        if (curNode.nodeType === 3) {\r\n            startOffset = offset - curOffset;\r\n            curOffset += curNode.textContent.length;\r\n            if (curOffset >= offset) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (!curNode) {\r\n        curNode = parent;\r\n    }\r\n    return {node: curNode, offset: startOffset};\r\n}\r\n```\r\n\r\n#### 3）支持高亮选区的重合\r\n\r\n重合的高亮选区带来的一个问题就是高亮包裹元素的嵌套，从而使得 DOM 结构会有较复杂的变动，增加了其他功能（交互）实现与问题排查的复杂度。因此，我在 3.2. 节提到的包裹高亮元素时，会再进行一些稍复杂的处理（尤其是重合选区），以保证尽量复用已有的包裹元素，避免元素的嵌套。\r\n\r\n在处理时，将需要包裹的各个文本片段（Text Node）分为三类情况：\r\n\r\n1. 完全未被包裹，则直接包裹该部分。\r\n2. 属于被包裹过的文本节点的一部分，则使用`.splitText()`将其拆分。\r\n3. 是一段完全被包裹的文本段，不需要对节点进行处理。\r\n\r\n于此同时，为每个选区生成唯一 ID，将该段文本几点多对应的 ID、以及其由于选区重合所涉及到的其他 ID，都附加包裹元素上。因此像上面的第三种情况，不需要变更 DOM 结构，只用更新包裹元素两类 ID 所对应的 dataset 属性即可。\r\n\r\n## 6. 其他问题\r\n\r\n解决以上的一些问题后，“文本划词高亮”就基本可用了。还剩下一些“小修补”，简单提一下。\r\n\r\n### 6.1. 高亮选区的交互事件，例如 click、hover\r\n\r\n首先，可以为每个高亮选区生成一个唯一 ID，然后在该选区内所有的包裹元素上记录该 ID 信息，例如用`data-highlight-id`属性。而对于选取重合的部分可以在`data-highlight-extra-id`属性中记录重合的其他选区的 ID。\r\n\r\n而监听到包裹元素的 click、hover 后，则触发 highlighter 的相应事件，并带上高亮 ID。\r\n\r\n### 6.2. 取消高亮（高亮背景的删除）\r\n\r\n由于在包裹时支持选区重合（对应会有上面提到的三种情况需要处理），因此，在删除选取高亮时，也会有三种情况需要分别处理：\r\n\r\n- 直接删除包裹元素。即不存在选区重合。\r\n- 更新`data-highlight-id`属性和`data-highlight-extra-id`属性。即删除的高亮 ID 与 `data-highlight-id` 相同。\r\n- 只更新`data-highlight-extra-id`属性。即删除的高亮 ID 只在 `data-highlight-extra-id` 中。\r\n\r\n### 6.3. 对于前端生成的动态页面怎么办？\r\n\r\n不难发现，这种非耦合的文本高亮功能很依赖于页面的 DOM 结构，需要保证做高亮时的 DOM 结构和还原时的一致，否则无法正确还原出选区的起始节点位置。据此，对“划词”高亮最友好的应该是纯后端渲染的页面，在`onload`监听中触发高亮选区还原的方法即可。但目前越来越多的页面（或页面的一部分）是前端动态生成的，针对这个问题该怎么处理呢？\r\n\r\n我在实际工作中也遇到了类似问题 —— 页面的很多区域是 ajax 请求后前端渲染的。我的处理方式包括如下：\r\n\r\n- 隔离变化范围。将上述代码中的“根节点”从`documentElement`换为另一个更具体的容器元素。例如我面对的业务会在 id 为 `article-container` 的`<div>`内加载动态内容，那么我就会指定这个 `article-container` 为“根节点”。这样可以最大程度防止外部的 DOM 变动影响到高亮位置的定位，尤其是页面改版。\r\n- 确定高亮选区的还原时机。由于内容可能是动态生成，所以需要等到该部分的 DOM 渲染完成后再调用还原方法。如果有暴露的监听事件可以在监听内处理；或者通过 MutationObserver 监听标志性元素来判断该部分是否加载完成。\r\n- 记录业务内容信息，应对内容区改版。内容区的 DOM 结构更改算是“毁灭性打击”。如何确实有该类情况，可以尝试让业务内容展示方将段落信息等具体的内容信息绑定在 DOM 元素上，而我在高亮时取出这些信息来冗余存储，改版后可以通过这些内容信息“刷”一遍存储的数据。\r\n\r\n### 6.4. 其他\r\n\r\n篇幅问题，还有其他细节的问题就不在这篇文章里分享了。详细内容可以参考 [web-highlighter](https://github.com/alienzhou/web-highlighter) 这个仓库里的实现。\r\n\r\n## 7. 总结\r\n\r\n本文先从“划词高亮”功能的两个核心问题（如何高亮用户选区的文本、如何将高亮选区还原）切入，基于 Selection API、深度优先遍历和 DOM 节点标识的序列化这些手段实现了“划词高亮”的核心功能。然而，该方案仍然存在一些实际问题，因此在第 5 部分进一步给出了相应的解决方案。\r\n\r\n基于实际开发的经验，我发现解决上述几个“划词高亮”核心问题的代码具有一定通用性，因此把核心部分的源码封装成了独立的库 [web-highlighter](https://github.com/alienzhou/web-highlighter)，托管在 github，也可以通过 npm 安装。\r\n\r\n[![image](http://upload-images.jianshu.io/upload_images/6476654-65f0a1e101a5d925?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://github.com/alienzhou/web-highlighter)\r\n\r\n其已服务于线上产品业务，基本的高亮功能一行代码即可开启：\r\n\r\n```JavaScript\r\n(new Highlighter()).run();\r\n```\r\n\r\n兼容IE 10/11、Edge、Firefox 52+、Chrome 15+、Safari 5.1+、Opera 15+。\r\n\r\n感兴趣的小伙伴可以 star 一下。感谢支持，欢迎交流 😊\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/27","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/27/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/27/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/27/events","html_url":"https://github.com/alienzhou/blog/issues/27","id":427659557,"node_id":"MDU6SXNzdWU0Mjc2NTk1NTc=","number":27,"title":"前端跨页面通信，你知道哪些方法？","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845015,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%B5%8F%E8%A7%88%E5%99%A8","name":"浏览器","color":"cfd3d7","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2019-04-01T11:45:29Z","updated_at":"2020-03-27T05:09:53Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 引言\r\n\r\n在浏览器中，我们可以同时打开多个Tab页，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab间共享。然而有些时候，我们希望能在这些“独立”的Tab页面之间同步页面的数据、信息或状态。\r\n\r\n正如下面这个例子：我在列表页点击“收藏”后，对应的详情页按钮会自动更新为“已收藏”状态；类似的，在详情页点击“收藏”后，列表页中按钮也会更新。\r\n\r\n![跨页面通信实例](https://user-gold-cdn.xitu.io/2019/4/1/169d767c01990c37?w=1364&h=876&f=gif&s=2542093)\r\n\r\n这就是我们所说的前端跨页面通信。\r\n\r\n你知道哪些跨页面通信的方式呢？如果不清楚，下面我就带大家来看看七种跨页面通信的方式。\r\n\r\n---\r\n\r\n## 一、同源页面间的跨页面通信\r\n\r\n> 以下各种方式的 [在线 Demo 可以戳这里 >>](https://alienzhou.github.io/cross-tab-communication/)\r\n\r\n浏览器的[同源策略](https://en.wikipedia.org/wiki/Same-origin_policy)在下述的一些跨页面通信方法中依然存在限制。因此，我们先来看看，在满足同源策略的情况下，都有哪些技术可以用来实现跨页面通信。\r\n\r\n### 1. BroadCast Channel\r\n\r\n[BroadCast Channel](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel) 可以帮我们创建一个用于广播的通信频道。当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到。它的API和用法都非常简单。\r\n\r\n下面的方式就可以创建一个标识为`AlienZHOU`的频道：\r\n\r\n```JavaScript\r\nconst bc = new BroadcastChannel('AlienZHOU');\r\n```\r\n\r\n各个页面可以通过`onmessage`来监听被广播的消息：\r\n\r\n```JavaScript\r\nbc.onmessage = function (e) {\r\n    const data = e.data;\r\n    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;\r\n    console.log('[BroadcastChannel] receive message:', text);\r\n};\r\n```\r\n\r\n要发送消息时只需要调用实例上的`postMessage`方法即可：\r\n\r\n```JavaScript\r\nbc.postMessage(mydata);\r\n```\r\n\r\n> Broadcast Channel 的具体的使用方式可以看这篇[《【3分钟速览】前端广播式通信：Broadcast Channel》](https://github.com/alienzhou/blog/issues/26)。\r\n\r\n### 2. Service Worker\r\n\r\n[Service Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。\r\n\r\n> Service Worker 也是 PWA 中的核心技术之一，由于本文重点不在 PWA ，因此如果想进一步了解 Service Worker，可以阅读我之前的文章[【PWA学习与实践】(3) 让你的WebApp离线可用](https://github.com/alienzhou/blog/issues/4)。\r\n\r\n首先，需要在页面注册 Service Worker：\r\n\r\n```JavaScript\r\n/* 页面逻辑 */\r\nnavigator.serviceWorker.register('../util.sw.js').then(function () {\r\n    console.log('Service Worker 注册成功');\r\n});\r\n```\r\n\r\n其中`../util.sw.js`是对应的 Service Worker 脚本。Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站：\r\n\r\n```JavaScript\r\n/* ../util.sw.js Service Worker 逻辑 */\r\nself.addEventListener('message', function (e) {\r\n    console.log('service worker receive message', e.data);\r\n    e.waitUntil(\r\n        self.clients.matchAll().then(function (clients) {\r\n            if (!clients || clients.length === 0) {\r\n                return;\r\n            }\r\n            clients.forEach(function (client) {\r\n                client.postMessage(e.data);\r\n            });\r\n        })\r\n    );\r\n});\r\n```\r\n\r\n我们在 Service Worker 中监听了`message`事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过`self.clients.matchAll()`获取当前注册了该 Service Worker 的所有页面，通过调用每个client（即页面）的`postMessage`方法，向页面发送消息。这样就把从一处（某个Tab页面）收到的消息通知给了其他页面。\r\n\r\n处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息：\r\n\r\n```JavaScript\r\n/* 页面逻辑 */\r\nnavigator.serviceWorker.addEventListener('message', function (e) {\r\n    const data = e.data;\r\n    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;\r\n    console.log('[Service Worker] receive message:', text);\r\n});\r\n```\r\n\r\n最后，当需要同步消息时，可以调用 Service Worker 的`postMessage`方法：\r\n\r\n```JavaScript\r\n/* 页面逻辑 */\r\nnavigator.serviceWorker.controller.postMessage(mydata);\r\n```\r\n\r\n### 3. LocalStorage\r\n\r\nLocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但[`StorageEvent`](https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent)这个与它相关的事件有些同学可能会比较陌生。\r\n\r\n当 LocalStorage 变化时，会触发`storage`事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听`storage`事件即可收到通知。\r\n\r\n```JavaScript\r\nwindow.addEventListener('storage', function (e) {\r\n    if (e.key === 'ctc-msg') {\r\n        const data = JSON.parse(e.newValue);\r\n        const text = '[receive] ' + data.msg + ' —— tab ' + data.from;\r\n        console.log('[Storage I] receive message:', text);\r\n    }\r\n});\r\n```\r\n\r\n在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的`setItem`方法即可：\r\n\r\n```JavaScript\r\nmydata.st = +(new Date);\r\nwindow.localStorage.setItem('ctc-msg', JSON.stringify(mydata));\r\n```\r\n\r\n注意，这里有一个细节：我们在mydata上添加了一个取当前毫秒时间戳的`.st`属性。这是因为，`storage`事件只有在值真正改变时才会触发。举个例子：\r\n\r\n```\r\nwindow.localStorage.setItem('test', '123');\r\nwindow.localStorage.setItem('test', '123');\r\n```\r\n\r\n由于第二次的值`'123'`与第一次的值相同，所以以上的代码只会在第一次`setItem`时触发`storage`事件。因此我们通过设置`st`来保证每次调用时一定会触发`storage`事件。\r\n\r\n### 小憩一下\r\n\r\n上面我们看到了三种实现跨页面通信的方式，不论是建立广播频道的 Broadcast Channel，还是使用 Service Worker 的消息中转站，抑或是些 tricky 的`storage`事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。\r\n\r\n> 在上面的例子中，这个“中央站”可以是一个 BroadCast Channel 实例、一个 Service Worker 或是 LocalStorage。\r\n\r\n下面我们会看到另外两种跨页面通信方式，我把它称为“共享存储+轮询模式”。\r\n\r\n---\r\n\r\n### 4. Shared Worker\r\n\r\n[Shared Worker](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker) 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。\r\n\r\nShared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：\r\n\r\n让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过`postMessage`传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：\r\n\r\n首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：\r\n\r\n```JavaScript\r\n// 构造函数的第二个参数是 Shared Worker 名称，也可以留空\r\nconst sharedWorker = new SharedWorker('../util.shared.js', 'ctc');\r\n```\r\n\r\n然后，在该 Shared Worker 中支持 get 与 post 形式的消息：\r\n\r\n```JavaScript\r\n/* ../util.shared.js: Shared Worker 代码 */\r\nlet data = null;\r\nself.addEventListener('connect', function (e) {\r\n    const port = e.ports[0];\r\n    port.addEventListener('message', function (event) {\r\n        // get 指令则返回存储的消息数据\r\n        if (event.data.get) {\r\n            data && port.postMessage(data);\r\n        }\r\n        // 非 get 指令则存储该消息数据\r\n        else {\r\n            data = event.data;\r\n        }\r\n    });\r\n    port.start();\r\n});\r\n```\r\n\r\n之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：\r\n\r\n```JavaScript\r\n// 定时轮询，发送 get 指令的消息\r\nsetInterval(function () {\r\n    sharedWorker.port.postMessage({get: true});\r\n}, 1000);\r\n\r\n// 监听 get 消息的返回数据\r\nsharedWorker.port.addEventListener('message', (e) => {\r\n    const data = e.data;\r\n    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;\r\n    console.log('[Shared Worker] receive message:', text);\r\n}, false);\r\nsharedWorker.port.start();\r\n```\r\n\r\n最后，当要跨页面通信时，只需给 Shared Worker `postMessage`即可：\r\n\r\n```JavaScript\r\nsharedWorker.port.postMessage(mydata);\r\n```\r\n\r\n> 注意，如果使用`addEventListener`来添加 Shared Worker 的消息监听，需要显式调用`MessagePort.start`方法，即上文中的`sharedWorker.port.start()`；如果使用`onmessage`绑定监听则不需要。\r\n\r\n### 5. IndexedDB\r\n\r\n除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) 或 cookie。\r\n\r\n> 鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。\r\n\r\n其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。\r\n\r\n- 打开数据库连接：\r\n\r\n```JavaScript\r\nfunction openStore() {\r\n    const storeName = 'ctc_aleinzhou';\r\n    return new Promise(function (resolve, reject) {\r\n        if (!('indexedDB' in window)) {\r\n            return reject('don\\'t support indexedDB');\r\n        }\r\n        const request = indexedDB.open('CTC_DB', 1);\r\n        request.onerror = reject;\r\n        request.onsuccess =  e => resolve(e.target.result);\r\n        request.onupgradeneeded = function (e) {\r\n            const db = e.srcElement.result;\r\n            if (e.oldVersion === 0 && !db.objectStoreNames.contains(storeName)) {\r\n                const store = db.createObjectStore(storeName, {keyPath: 'tag'});\r\n                store.createIndex(storeName + 'Index', 'tag', {unique: false});\r\n            }\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n- 存储数据\r\n\r\n```JavaScript\r\nfunction saveData(db, data) {\r\n    return new Promise(function (resolve, reject) {\r\n        const STORE_NAME = 'ctc_aleinzhou';\r\n        const tx = db.transaction(STORE_NAME, 'readwrite');\r\n        const store = tx.objectStore(STORE_NAME);\r\n        const request = store.put({tag: 'ctc_data', data});\r\n        request.onsuccess = () => resolve(db);\r\n        request.onerror = reject;\r\n    });\r\n}\r\n```\r\n\r\n- 查询/读取数据\r\n\r\n```JavaScript\r\nfunction query(db) {\r\n    const STORE_NAME = 'ctc_aleinzhou';\r\n    return new Promise(function (resolve, reject) {\r\n        try {\r\n            const tx = db.transaction(STORE_NAME, 'readonly');\r\n            const store = tx.objectStore(STORE_NAME);\r\n            const dbRequest = store.get('ctc_data');\r\n            dbRequest.onsuccess = e => resolve(e.target.result);\r\n            dbRequest.onerror = reject;\r\n        }\r\n        catch (err) {\r\n            reject(err);\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n剩下的工作就非常简单了。首先打开数据连接，并初始化数据：\r\n\r\n```JavaScript\r\nopenStore().then(db => saveData(db, null))\r\n```\r\n\r\n对于消息读取，可以在连接与初始化后轮询：\r\n\r\n```JavaScript\r\nopenStore().then(db => saveData(db, null)).then(function (db) {\r\n    setInterval(function () {\r\n        query(db).then(function (res) {\r\n            if (!res || !res.data) {\r\n                return;\r\n            }\r\n            const data = res.data;\r\n            const text = '[receive] ' + data.msg + ' —— tab ' + data.from;\r\n            console.log('[Storage I] receive message:', text);\r\n        });\r\n    }, 1000);\r\n});\r\n```\r\n\r\n最后，要发送消息时，只需向 IndexedDB 存储数据即可：\r\n\r\n```JavaScript\r\nopenStore().then(db => saveData(db, null)).then(function (db) {\r\n    // …… 省略上面的轮询代码\r\n    // 触发 saveData 的方法可以放在用户操作的事件监听内\r\n    saveData(db, mydata);\r\n});\r\n```\r\n\r\n### 小憩一下\r\n\r\n在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有监听模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。\r\n\r\n例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听`visibilitychange`这样的事件，来做一次信息同步即可。\r\n\r\n下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。\r\n\r\n---\r\n\r\n### 6. window.open + window.opener\r\n\r\n当我们使用`window.open`打开页面时，方法会返回一个被打开页面`window`的引用。而在未显示指定`noopener`时，被打开的页面可以通过`window.opener`获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。\r\n\r\n首先，我们把`window.open`打开的页面的`window`对象收集起来：\r\n\r\n```JavaScript\r\nlet childWins = [];\r\ndocument.getElementById('btn').addEventListener('click', function () {\r\n    const win = window.open('./some/sample');\r\n    childWins.push(win);\r\n});\r\n```\r\n\r\n然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面：\r\n\r\n```JavaScript\r\n// 过滤掉已经关闭的窗口\r\nchildWins = childWins.filter(w => !w.closed);\r\nif (childWins.length > 0) {\r\n    mydata.fromOpenner = false;\r\n    childWins.forEach(w => w.postMessage(mydata));\r\n}\r\nif (window.opener && !window.opener.closed) {\r\n    mydata.fromOpenner = true;\r\n    window.opener.postMessage(mydata);\r\n}\r\n```\r\n\r\n注意，我这里先用`.closed`属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。\r\n\r\n此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）:\r\n\r\n> 需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化）\r\n\r\n```JavaScript\r\nwindow.addEventListener('message', function (e) {\r\n    const data = e.data;\r\n    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;\r\n    console.log('[Cross-document Messaging] receive message:', text);\r\n    // 避免消息回传\r\n    if (window.opener && !window.opener.closed && data.fromOpenner) {\r\n        window.opener.postMessage(data);\r\n    }\r\n    // 过滤掉已经关闭的窗口\r\n    childWins = childWins.filter(w => !w.closed);\r\n    // 避免消息回传\r\n    if (childWins && !data.fromOpenner) {\r\n        childWins.forEach(w => w.postMessage(data));\r\n    }\r\n});\r\n```\r\n\r\n这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。\r\n\r\n### 小憩一下\r\n\r\n显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的`window.open`打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。\r\n\r\n除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端。\r\n\r\n关于 WebSocket 与其他“服务器推”技术，不了解的同学可以阅读这篇[《各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）》](https://juejin.im/post/5b135b78f265da6e420eab7d)\r\n\r\n此外，我还针对以上各种方式写了一个 [在线演示的 Demo >>](https://alienzhou.github.io/cross-tab-communication/)\r\n\r\n\r\n![Demo页面](https://user-gold-cdn.xitu.io/2019/4/1/169d8701f85f9f33?w=1917&h=850&f=gif&s=1480792)\r\n\r\n\r\n## 二、非同源页面之间的通信\r\n\r\n上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？\r\n\r\n要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定`origin`来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：`http://sample.com/bridge.html`），而这些 iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。\r\n\r\n页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理：\r\n\r\n```JavaScript\r\n/* 业务页面代码 */\r\nwindow.addEventListener('message', function (e) {\r\n    // …… do something\r\n});\r\n```\r\n\r\n然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息：\r\n\r\n```JavaScript\r\n/* 业务页面代码 */\r\nwindow.frames[0].window.postMessage(mydata, '*');\r\n```\r\n\r\n其中为了简便此处将`postMessage`的第二个参数设为了`'*'`，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel：\r\n\r\n```JavaScript\r\n/* iframe 内代码 */\r\nconst bc = new BroadcastChannel('AlienZHOU');\r\n// 收到来自页面的消息后，在 iframe 间进行广播\r\nwindow.addEventListener('message', function (e) {\r\n    bc.postMessage(e.data);\r\n});    \r\n```\r\n\r\n其他 iframe 收到通知后，则会将该消息同步给所属的页面：\r\n\r\n```JavaScript\r\n/* iframe 内代码 */\r\n// 对于收到的（iframe）广播消息，通知给所属的业务页面\r\nbc.onmessage = function (e) {\r\n    window.parent.postMessage(e.data, '*');\r\n};\r\n```\r\n\r\n下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/3/31/169d468988a6ba8f?w=568&h=277&f=png&s=32299)\r\n\r\n其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。\r\n\r\n---\r\n\r\n## 总结\r\n\r\n今天和大家分享了一下跨页面通信的各种方式。\r\n\r\n对于同源页面，常见的方式包括：\r\n\r\n- 广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent\r\n- 共享存储模式：Shared Worker / IndexedDB / cookie\r\n- 口口相传模式：window.open + window.opener\r\n- 基于服务端：Websocket / Comet / SSE 等\r\n\r\n而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。\r\n\r\n本文在分享的同时，也是为了抛转引玉。如果你有什么其他想法，欢迎一起讨论，提出你的见解和想法~\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/26","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/26/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/26/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/26/events","html_url":"https://github.com/alienzhou/blog/issues/26","id":427657608,"node_id":"MDU6SXNzdWU0Mjc2NTc2MDg=","number":26,"title":"【3分钟速览】前端广播式通信：Broadcast Channel","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845015,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%B5%8F%E8%A7%88%E5%99%A8","name":"浏览器","color":"cfd3d7","default":false,"description":""},{"id":1298890220,"node_id":"MDU6TGFiZWwxMjk4ODkwMjIw","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%89%B9%E6%80%A7","name":"特性","color":"c2e0c6","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2019-04-01T11:40:23Z","updated_at":"2019-07-24T04:06:19Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## Broadcast Channel 是什么？\r\n\r\n在前端，我们经常会用`postMessage`来实现页面间的通信，但这种方式更像是点对点的通信。对于一些需要广播（让所有页面知道）的消息，用`postMessage`不是非常自然。Broadcast Channel 就是用来弥补这个缺陷的。\r\n\r\n顾名思义，Broadcast Channel 会创建一个所有同源页面都可以共享的（广播）频道，因此其中某一个页面发送的消息可以被其他页面监听到。\r\n\r\n下面就来速览一下它的使用方法。\r\n\r\n## 如何使用？\r\n\r\nBroadcast Channel 的 API 非常简单易用。\r\n\r\n### 创建\r\n\r\n首先我们会使用构造函数创建一个实例：\r\n\r\n```JavaScript\r\nconst bc = new BroadcastChannel('alienzhou');\r\n```\r\n\r\n可以接受一个`DOMString`作为 name，用以标识这个 channel。在其他页面，可以通过传入相同的 name 来使用同一个广播频道。用 MDN 上的话来解释就是：\r\n\r\n> There is one single channel with this name for all browsing contexts with the same origin.\r\n\r\n该 name 值可以通过实例的`.name`属性获得\r\n\r\n```JavaScript\r\nconsole.log(bc.name);\r\n// alienzhou\r\n```\r\n\r\n### 监听消息\r\n\r\nBroadcast Channel 创建完成后，就可以在页面监听广播的消息：\r\n\r\n```JavaScript\r\nbc.onmessage = function(e) {\r\n    console.log('receive:', e.data);\r\n};\r\n```\r\n\r\n对于错误也可以绑定监听：\r\n\r\n```JavaScript\r\nbc.onmessageerror = function(e) {\r\n    console.warn('error:', e);\r\n};\r\n```\r\n\r\n> 除了为`.onmessage`赋值这种方式，也可以使用`addEventListener`来添加`'message'`监听。\r\n\r\n### 发送消息\r\n\r\nBroadcast Channel 实例也有一个对应的`postMessage`用于发送消息：\r\n\r\n```JavaScript\r\nbc.postMessage('hello')\r\n```\r\n\r\n### 关闭\r\n\r\n可以看到，上述短短几行代码就可以实现多个页面间的广播通信，非常方便。而有时我们希望取消当前页面的广播监听：\r\n- 一种方式是取消或者修改相应的`'message'`事件监听\r\n- 另一种简单的方式就是使用 Broadcast Channel 实例为我们提供的`close`方法。\r\n\r\n```JavaScript\r\nbc.close();\r\n```\r\n\r\n两者是有区别的：\r\n\r\n取消`'message'`监听只是让页面不对广播消息进行响应，Broadcast Channel 仍然存在；而调用`close`方法这会切断与 Broadcast Channel 的连接，浏览器才能够尝试回收该对象，因为此时浏览器才会知道用户已经不需要使用广播频道了。\r\n\r\n在关闭后调用`postMessage`会出现如下报错\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/4/1/169d80b1620cdac9?w=2100&h=74&f=png&s=71151)\r\n\r\n如果之后又再需要广播，则可以重新创建一个相同 name 的 Broadcast Channel。\r\n\r\n## Demo 效果\r\n\r\n[可以戳这里查看在线 Demo >>](https://alienzhou.github.io/broadcast-channel/)\r\n\r\n下面是 Broadcast Channel Demo 的演示效果：\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/4/1/169d8452cef80241?w=1435&h=875&f=gif&s=523961)\r\n\r\n## 兼容性如何？\r\n\r\nBroadcast Channel 是一个非常好用的多页面消息同步 API，然而兼容性却**不是很乐观**。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/4/1/169d80efd65b5401?w=2544&h=1186&f=png&s=584864)\r\n\r\n> 好在我们还有些其他方案可以作为补充（或者作为polyfill），其他的前端跨页面通信可以参考我的另一篇文章[《前端跨页面通信的方法》](https://github.com/alienzhou/blog/issues/27)。","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/25","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/25/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/25/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/25/events","html_url":"https://github.com/alienzhou/blog/issues/25","id":394016721,"node_id":"MDU6SXNzdWUzOTQwMTY3MjE=","number":25,"title":"【漫游Github】quicklink：实现原理与给前端的启发","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845014,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE0","url":"https://api.github.com/repos/alienzhou/blog/labels/JavaScript","name":"JavaScript","color":"d73a4a","default":false,"description":""},{"id":1159845015,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%B5%8F%E8%A7%88%E5%99%A8","name":"浏览器","color":"cfd3d7","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-25T12:45:07Z","updated_at":"2020-01-04T01:18:21Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"近来，GoogleChromeLabs 推出了 [quicklink](https://github.com/GoogleChromeLabs/quicklink)，用以实现链接资源的预加载（prefetch）。本文在介绍其实现思路的基础上，会进一步探讨在预加载方面前端工程师还可以做什么。\r\n\r\n## 1. quicklink 是什么的？\r\n\r\nquicklink 是一个通过预加载资源来提升后续方案速度的轻量级工具库。旨在提升浏览过程中，用户访问后续页面时的加载速度。\r\n\r\n当我们提到性能优化，往往都会着眼于对当前用户访问的这个页面，如何通过压缩资源大小、删减不必要资源、加快页面解析渲染等方式提升用户的访问速度；而 quicklink 用了另一种思路：我预先帮你加载（获取）你接下来最可能要用的资源，这样之后的真正使用到该资源（链接）时就会感觉非常顺畅。\r\n\r\n照着这个思路，我们需要解决的问题就是如何预先帮用户加载资源呢？这里其实涉及到两个问题：\r\n\r\n- 如何去预加载一个指定资源？（预加载的方式）\r\n- 如何确定某个资源是否要加载？（预加载的策略）\r\n\r\n下面就结合 quicklink 源码来看看如何解决这两个问题。\r\n\r\n> 注：下文提到的“预加载”/“预获取”均指 prefetch\r\n\r\n## 2. quicklink 实现原理\r\n\r\n## 2.1. 如何去预加载一个指定资源？\r\n\r\n首先要解决的是，通过什么方式来实现资源的预加载。即预加载的方式。\r\n\r\n我们这里的预加载对应的英文是 prefetch。提到 prefetch 自然会想到使用浏览器的 Resource Hints，通过提示浏览器做一些“预操作”（例如 DNS 解析、资源下载等）来加快后续的访问。\r\n\r\n> 如果对 prefetch 与 Resource Hints 不熟悉，可以看看这篇[《使用Resource Hint提升页面加载性能与体验》](https://juejin.im/post/5b4b66f0f265da0f9155feb6#heading-4)。\r\n\r\n只需要下面这样一行代码就可以实现浏览器的资源预加载。是不是非常美妙？\r\n\r\n```\r\n<link rel=\"prefetch\" href=\"/my.little.script.js\" as=\"script\">\r\n```\r\n\r\n因此，要预加载一个资源可以通过下面四行代码：\r\n\r\n```JavaScript\r\nconst link = document.createElement(`link`);\r\nlink.rel = `prefetch`;\r\nlink.href = url;\r\ndocument.head.appendChild(link);\r\n```\r\n\r\n然而，我们不得不面对兼容性的问题，在低版本 IE 与移动端是重灾区。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/12/25/167e4b2371f81ea0?w=1270&h=484&f=png&s=320597)\r\n\r\n美梦破灭。既然如此，我们就需要一个类似 prefetch shim 的方式：在不支持 Resource Hints 的浏览器中，使用其他方式来预加载资源。对此，我们可以利用浏览器自身的缓存策略，“实实在在”预先请求这个资源，这也形成了一种资源的“预获取”。而这最方便的就是通过 XHR：\r\n\r\n```JavaScript\r\nconst req = new XMLHttpRequest();\r\nreq.open(`GET`, url, req.withCredentials=true);\r\nreq.send();\r\n```\r\n\r\n这样 shim 也完成了。最后，如何检测浏览器是否支持 prefetch 呢？\r\n\r\n我们可以通过 `link` 元素上 relList 属性的 `support` 方法来检查对 prefetch 的支持情况：\r\n\r\n```JavaScript\r\nconst link = document.createElement('link');\r\nlink.relList || {}).supports && link.relList.supports('prefetch');\r\n```\r\n\r\n结合这三个段代码，就形成了一个简易的 prefetcher：**判断是否支持 Resource Hints 中的 prefetch，支持则使用它，否则回退使用 XHR 加载**。\r\n\r\n值得一提的是，使用 Resource Hints 与使用 XHR 来预加载资源还是有一些重要差异的。[草案中](https://www.w3.org/TR/resource-hints/#x1-introduction)也提到了一些（主要是与性能以及与浏览器其他行为之间的冲突）。其中还有一点就是，Resource Hints 中的 prefetch 是否执行，完全是由浏览器决定的，草案里有句话非常明显 —— the user agent *SHOULD* fetch。因此，所有 prefetch 的资源并不一定会真正被 prefetch。相较之下，XHR 的方式“成功率”则更高。这点在 [Netflix 实施的性能优化案例](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9#1b0c)中也提到了。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/12/25/167e4b291f960c09?w=1600&h=967&f=png&s=393698)\r\n\r\n> 题外话：quicklink 中使用 fetch API  实现高优先级资源的加载。这是因为浏览器中会为所有的请求都设置一个优先级，高优请求会被优先执行；目前，`fetch` 在 Chrome 中属于高优先级，在 Safari 中属于中等优先级。\r\n\r\n\r\n## 2.2. 如何确定某个资源是否要预加载？\r\n\r\n有了资源预加载的方式，那么接下来就需要一个预加载的策略了。\r\n\r\n这其实是个见仁见智的问题。例如直接给你一个链接 `https://my.test.com/somelink`，在没有任何背景信息的情况下，恐怕你完全不知道是否需要预加载它。那对于这个问题，quicklink 是怎么解决的呢？或者说，quicklink 是通过什么策略来进行预加载的呢？\r\n\r\nquicklink 用了一个比较直观的策略：只对处于视口内的资源进行预加载。这一点也比较好理解，网络上大多的资源加载、页面跳转都伴随着用户点击这类行为，而它要是不在你的视野内，你也就无从点击了。这一定程度上算是个必要条件。\r\n\r\n这么一来，我们所要解决的问题就是，如果判断一个链接是否处于可视区域内？\r\n\r\n以前，对于这种问题，我们做的就是监听 `scroll` 事件，然后判断某元素的位置，从而来“得知”元素是否进入了视区。传统的图片懒加载库 [lazysize](https://github.com/aFarkas/lazysizes) 等也是用这种策略。\r\n\r\n```JavaScript\r\ndocument.addEventListener('scroll', function () {\r\n    // ……判断元素位置\r\n});\r\n```\r\n\r\n> 注：目前 lazysize 也有了基于 IntersectionObserver 的实现\r\n\r\n当然，需要特别注意滚动监听的性能，例如使用截流、避免强制同步布局、 `passive: true` 等方式缓解性能问题。\r\n\r\n不过现在我们有了一个新的方式来实现这一功能 —— `IntersectionObserver`：\r\n\r\n```JavaScript\r\nconst observer = new IntersectionObserver(entries => {\r\n  entries.forEach(entry => {\r\n    if (entry.isIntersecting) {\r\n      const link = entry.target;\r\n      // 预加载链接\r\n    }\r\n  });\r\n});\r\n\r\n// 对所有 a 标签添加观察者\r\nArray.from(options.el.querySelectorAll('a'), link => {\r\n    observer.observe(link);\r\n});\r\n```\r\n\r\n`IntersectionObserver` 会创建一个观察者，专门用来观察与通知元素进出视口的情况。如上述代码所示，`IntersectionObserver` 可以观察所有 `a` 元素的位置情况（主要是进入视野）。\r\n\r\n> 对 `IntersectionObserver` 不了解的同学可以参考 [Google 的 `IntersectionObserver` 介绍文章](https://developers.google.com/web/updates/2016/04/intersectionobserver)。\r\n\r\n但是如下图所示， `IntersectionObserver` 存在兼容性问题，因此要在不兼容的浏览器中使用 quicklink，会需要一个 [polyfill](https://github.com/w3c/IntersectionObserver)。\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/12/25/167e54a6cc93bde4?w=2542&h=1068&f=png&s=680398)\r\n\r\n目前，我们已经把 quicklink 的两大部分（预加载的方式和预加载的策略）的原理和简单实现讲完了。整个 quicklink 非常简洁，这些基本就是 quicklink 的核心。剩下的就是一些参数检查、额外的规则特性等。\r\n\r\n> 题外话：为了进一步保证性能，quicklink 使用 `requestIdleCallback` 在空闲时间查询页面 `a` 标签并挂载观察者。对 `requestIdleCallback` 不了解的同学可以看看 [Google 的这篇文章](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)。\r\n\r\n\r\n## 3. 到此为止？不，我们还能做更多\r\n\r\n到这里，quicklink 的实现就基本讲完了。仔细回想一下，quicklink 其实提供了我们一种通过“预加载”来实现性能优化的思路（粗略来说像是用流量换体验）。这种方式我在前面也提到了，其实可以分为两个部分：\r\n\r\n- 如何去预加载一个指定资源？（预加载的方式）\r\n- 如何确定某个资源是否要加载？（预加载的策略）\r\n\r\n其实两部分似乎都有可以作为的地方。例如如何保证 prefetcher（资源预加载器）的成功率能更高，以及目前使用的回退方案 XHR 其实在预加载无法缓存的资源时所受的限制等。\r\n\r\n此外，我们在这里还可以来聊一聊策略这块。\r\n\r\n由于 quicklink 是一个业务无关的轻量级功能库，所以它采用了一个简单但一定程度上有效的策略：预加载视野内的链接资源。然而在实际生产中，我们面对的是更复杂的环境，更复杂的业务，反而会需要更精准的预加载判断。因此，我们完全可以从 quicklink 中剥离出 prefetcher 来作为一个预加载器；而在策略部分使用自己的实现，例如：\r\n\r\n- 结合访问日志、打点记录的更精准的预加载。例如，我们可以通过访问日志、打点记录，根据 refer 来判断，从 A 页面来的 B、C、D 页面的比例，从而设置一个阈值，超过该阈值则认为访问 A 页面的用户接下来更容易访问它，从而对其预加载。\r\n\r\n- 结合用户行为数据来进行个性化的预加载。例如我们有一个阅读类或商品展示类站点，从用户行为发现，当该链接暴露在该用户视野内 XX 秒（用户阅读内容 XX 秒）后点击率达到 XX%。而不是简单的一刀切或进入视野就预加载。\r\n\r\n- 后置非必要资源，精简某类落地页。落地页就是要让新用户尽快“落地”，为此我们可以像 [Netflix](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9#1b0c) 介绍的那样，在宣贯页/登录页精简加载内容，而预加载后续主站的主包（主资源）。例如有些站点的首页大多偏静态，可以用原生 JavaScript 加 内联关键 CSS 的方式，加快加载，用户访问后再预加载 React、Vue 等一系列主站资源。\r\n\r\n- 等等。\r\n\r\n上面这些场景只是抛砖引玉，相信大家还会有更多更好的场景可以来助力我们的前端应用“起飞”。此外，我们完全可以借助一些构建工具、数据采集与分析平台来实现策略的自动提取与注入，优化整个预加载的流程。\r\n\r\n## 写在最后\r\n\r\n预加载、Resource Hints等由来已久。quicklink 通过提出了一种可行的方案让它又进入了大家的视野，给我们展现了性能优化的另一面。希望大家通过了解 quicklink 的实现，也能有自己的想法与启发。\r\n\r\n相信随着浏览器的不断进化，标准的不断前行，前端工程师对极致体验与性能要求的不断提高，我们的产品将会越来越好。\r\n\r\n---\r\n\r\n好了，这期的「漫游 Github」就到这里了。本系列会不定期和大家一起看一看、聊一聊、学一学 github 上有趣的项目，不仅学习一些技术点，还可以了解作者的技术思考，欢迎感兴趣的小伙伴关注。\r\n\r\n![image](https://user-images.githubusercontent.com/9822789/71757685-7807ac00-2ed2-11ea-97e7-c93eec7b6017.png)\r\n\r\n---","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/24","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/24/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/24/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/24/events","html_url":"https://github.com/alienzhou/blog/issues/24","id":390668810,"node_id":"MDU6SXNzdWUzOTA2Njg4MTA=","number":24,"title":"【性能优化实践】优化打包策略提升页面加载速度","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845015,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%B5%8F%E8%A7%88%E5%99%A8","name":"浏览器","color":"cfd3d7","default":false,"description":""},{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T13:01:20Z","updated_at":"2018-12-13T13:01:20Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## TL;DR\r\n- 可以考虑基于HTTP Cache来定义打包维度，将Cache周期相同的script尽量打包在一起，最大限度利用Cache；\r\n- 合并零散的小脚本，避免触发浏览器并发请求限制后，资源请求串行，TTFB叠加等待时间；\r\n- 注意打包后的资源依赖与资源引入顺序。\r\n\r\n## 1. 引言\r\n性能优化涵盖的范围非常之广，其中包含的知识也非常繁杂。从加载性能到渲染性能、运行时性能，每个点都有非常多可以学习与实践的知识。\r\n\r\n优化问题包含方方面面，优化手段也依场景和具体问题而定。因此，本文并不是一个泛而全的概览文章，而是以之前的一次对于业务产品的简单优化（主要是DOMContentLoaded时间）为例，介绍了如何使用Chrome Dev Tools来分析问题，使用一些策略来缩短DOMContentLoaded的时间，提高加载速度。\r\n\r\n## 2. DOMContentLoaded事件\r\nW3C将页面加载分为了许多阶段， DOMContentLoaded（以下简称DCL）类似的有一些 DOM readState ，它们都会标识页面的加载状态与所处的阶段。我们接触最多的也就是 readState 中的 interactive、complete（或load事件）以及DCL事件\r\n\r\n简单了解一下它们。浏览器会基于HTML内容来构建DOM，并基于CSS构建CSSOM。两者构建完成后，会合并为Render Tree。当DOM构建完毕后， `document.readyState` 状态会变为 `interactive` 。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632dfee442ac44d?w=626&h=155&f=png&s=17201)\r\n\r\nRender Tree构建完成就会进入到我们非常熟悉的 Layout –>> Paint –>> Composite 管道。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632dff994a5f163?w=1093&h=167&f=png&s=95395)\r\n\r\n但是当页面包含Javascript时，这个过程会有些区别。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632dfffc7d10f7c?w=626&h=155&f=png&s=20221)\r\n\r\n根据[HTML5 spec](https://www.w3.org/TR/html5/syntax.html#the-end)，由于在Javascript中可以访问DOM，因此当浏览器解析页面遇到Javascript后会阻塞 DOM 的解析；于此同时，为避免CSS与Javascript之间的竞态，CSSOM的构建会阻塞 Javascript 脚本的执行。不过有一个例外，如果将脚本设置为async，会有一个区别，DCL的触发不需要等待async的脚本被执行。\r\n\r\n也就是：\r\n\r\n- 当浏览器完成对于document的解析（parse）时，文档状态就会被标记为 `interactive` 。即 \"DOM tree is ready\"。\r\n- 当所有普通（既不是defer也不是async）与defer的脚本被执行，并且已经没有任何阻塞脚本的样式时，浏览器就会触发 `DOMContentLoaded` 事件。即 \"CSSOM is ready\"。\r\n\r\n或者将上面的部分精简一下：\r\n\r\n> DOM construction can’t proceed until JavaScript is executed, and JavaScript can’t proceed until CSSOM is available. [[1]](https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/)\r\n\r\n## 3. 排查问题\r\n下面就可以通过Chrome Dev Tools来分析问题。为了内容精简，以下截图取了在slow 3G 无缓存模式下的访问情况，为了保持和线上环境类似（还原浏览器的同源最大请求并发），在本地搭建对应的服务器放置静态资源。wifi情况下，各个时间点大致等比缩短8~9倍。\r\n\r\n首先看一个整体的waterfall\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632e14e43c51ffb?w=958&h=797&f=png&s=260832)\r\n\r\n在最下面可以看到 DCL 为 17.00s（slow 3G）。\r\n\r\n> p.s. 页面load时间也很长。主要因为业务膨胀后，页面包含过多资源，没有使用一些懒加载与异步渲染技术，这部分也存在很多优化空间，但由于篇幅不在本文中讨论内。\r\n\r\n页面里有一个很明显的请求block了DCL —— common.js。那么common.js是什么呢？它其实就是项目中一些通用脚本文件的打包合并。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632e19f6b41592b?w=959&h=772&f=png&s=165591)\r\n\r\n由于common.js为同步脚本，因此等到它其下载并执行完毕后，才会触发DCL。而与此对应的，其他各个脚本的时间线与其有很大差距。具体来看common.js的Timing pharse，耗时11.44s，其中download花费 7.12s。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632e19f6b55068a?w=390&h=276&f=png&s=28765)\r\n\r\n## 4. 分析诊断\r\n\r\ndownload过长最直接的原因就是文件太大。common.js的打包合并包含了下面的内容\r\n\r\n```javascript\r\n'pkg/common.js': [\r\n    'static/js/bridge.js', // 业务基础库\r\n    'static/js/zepto.min.js', // 第三方库\r\n    'static/js/zepto.touch.min.js', // 第三方库\r\n    'static/js/bluebird.core.min.js', // 第三方库\r\n    'static/js/link.interceptor.js', // 业务基础库\r\n    'static/js/global.js', // 业务基础库\r\n    'static/js/felog.js', // 业务基础库\r\n    'widget/utils/*.js' // 业务工具组件\r\n]\r\n```\r\n\r\n这里，我们发现这么打包会存在下面几个问题：\r\n\r\n### 4.1. 文件大小\r\n\r\ndownload过长最直接的原因：文件过大。\r\n\r\n将这些资源全部打包在一起导致common.js较大，原文件161KB，gzip 之后为52.5KB，单点阻塞了关键渲染路径。你也可以在 audits 中的Critical Request Chains部分发现common.js是瓶颈。\r\n\r\n### 4.2. HTTP Cache\r\n\r\nzepto/bluebird这种第三方库属于非常稳定的资源，几乎不会改动。虽然代码量较多，但是通过HTTP Cache可以有效避免重复下载。同时，上线新版后，为了避免一些文件走 HTTP Cache，我们会给静态资源加上 md5。\r\n\r\n然而，当这些稳定的第三方库与一些其他文件打包后，会因为该打包中某些文件的局部变动导致合并打包后的hash变化而缓存失效。\r\n\r\n例如，其中bridge.js与/utils/*.js容易随着版本上线迭代，迭代后打包导致common的hash变化，HTTP Cache失效，zepto/bluebird等较大的资源虽然未更改，但由于打包在了一起，仍需要重新下载。每次上线新版本后，一些加载的性能数据表现都会显著下降，其中一部分原因在于此。\r\n\r\n## 5. 实施优化手段\r\n\r\n结合上面分析的问题，可以进行一些简单而有效的优化。\r\n\r\n### 5.1. 拆包\r\n\r\n考虑将文件的打包合并按照文件的更新频率进行划分。这样既可以有效缩减common.js的大小，也可以基于不同类型的资源，更好利用HTTP Cache。\r\n\r\n例如：\r\n\r\n- 将基本不会变动的文件打包为 lib.js，主要为一些第三方库，这类文件几乎不会改动，非常稳定。\r\n\r\n- 将项目依赖的最基础js打包为common.js，例如本文中的global.js、link.interceptor.js，项目中的所有部分都需要它们，同时也是项目特有的，相较上一部分的lib会有一定量的开发与改动，但是更新间隔可能会有几个版本。\r\n\r\n- 将项目中变动较为频繁的工具库打包为util.js，理论上其中工具由于不作为基础运行的依赖，是可以异步加载的。这部分代码是三者之中变动最为频繁的。\r\n\r\n```\r\n'pkg/util.js': [\r\n    'widget/utils/*.js'\r\n],\r\n'pkg/common.js': [\r\n    'static/js/link.interceptor.js',\r\n    'static/js/global.js',\r\n    'static/js/felog.js'\r\n],\r\n'pkg/lib.js': [\r\n    'static/js/zepto.min.js',\r\n    'static/js/zepto.touch.min.js',\r\n    'static/js/bluebird.core.min.js'\r\n]\r\n```\r\n\r\n### 5.2 Quene Delay\r\n\r\n但是在拆分后DCL时间几乎没有减少。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632e8c6138105fa?w=792&h=799&f=jpeg&s=343283)\r\n\r\n这里就不得不提到打包的初衷之一：减少并发。我们将common.js拆分为三个部分后，触碰到了同域TCP连接数限制，图中的这四个资源被chrome放入了队列（图中白色长条）。\r\n\r\n> Queueing. The browser queues requests when:\r\n> \r\n> - There are higher priority requests.\r\n> - There are already six TCP (Chrome) connections open for this origin, which is the limit. Applies to HTTP/1.0 and HTTP/1.1 only.\r\n> - The browser is briefly allocating space in the disk cache\r\n\r\n我们打包合并资源一定程度上也是为了减少TCP round trip，同时尽量规避同域下的请求并发数量限制。因此在common.js拆分时，也要注意不宜分得过细，否则过犹不及，忘了初衷。\r\n\r\n从network waterfall中也很容易发现，大部分资源由于size较小，其下载时间其实非常短，耗时主要是在TTFB（Time To First Byte），可以粗略理解为在等待服务器返回数据（图中表现出来就是绿色较多）。所以除了打包项目依赖的lib.js/common.js/util.js外，还可以考虑将部分依赖的组件脚本进行打包合并，\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632e66b1ad70b03?w=649&h=89&f=png&s=24700)\r\n\r\n像上图中这四个脚本的耗时都在在TTFB上，而且在同一个CDN上，可以通过打包减小不必要的并发。将首屏依赖的关键组件进行打包：\r\n\r\n```javascript\r\n'pkg/util.js': [\r\n    'widget/utils/*.js'\r\n],\r\n'pkg/common.js': [\r\n    'static/js/bridge.js',\r\n    'static/js/link.interceptor.js',\r\n    'static/js/global.js',\r\n    'static/js/felog.js'\r\n],\r\n'pkg/lib.js': [\r\n    'static/js/zepto.min.js',\r\n    'static/js/zepto.touch.min.js',\r\n    'static/js/bluebird.core.min.js'\r\n],\r\n'pkg/homewgt.js': [\r\n    'widget/home/**.js',\r\n    'widget/player/*.js',\r\n]\r\n```\r\n\r\n优化后的DCL变为了11.20s。\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632e66b1b179577?w=962&h=799&f=png&s=152035)\r\n\r\n### 5.3 资源引入顺序\r\n注意，一些打包工具会自动分析文件依赖关系，文件打包后会同时替换资源路径。例如：在HTML中，引用了 `static/js/zepto.min.js` 和 `static/js/bluebird.core.min.js` 两个资源，在打包后构建工具会将HTML中的引用自动替换为 `lib.js` 。因此需要注意打包后的资源加载顺序。\r\n\r\n例如，原HTML中的资源顺序\r\n\r\n```HTML\r\n<script type=\"text/javascript\" src=\"//your.cdn.com/static/js/bridge.js\"></script>\r\n<script type=\"text/javascript\" src=\"//your.cdn.com/static/js/zepto.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"//your.cdn.com/static/js/bluebird.core.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"//your.cdn.com/static/js/global.js\"></script>\r\n```\r\n\r\n其中 `global.js` 依赖于 `zepto.min.js`，这个在目前看来没有问题。但是由于打包合并，构建工具会自动替换脚本文件名。由于 `bridge.js` 的位置，在打包后`common.js`的引入顺序先于`lib.js`。这就导致 `global.js` 先于 `zepto.min.js` 引入与执行，出现错误。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632ea590a6e0088?w=957&h=97&f=jpeg&s=159271)\r\n\r\n对此，在不影响原有依赖的情况下，可以调整脚本顺序\r\n\r\n```HTML\r\n<script type=\"text/javascript\" src=\"//your.cdn.com/static/js/zepto.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"//your.cdn.com/static/js/bluebird.core.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"//your.cdn.com/static/js/bridge.js\"></script>\r\n<script type=\"text/javascript\" src=\"//your.cdn.com/static/js/global.js\"></script>\r\n```\r\n\r\n输出的结果如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632ea869bad3777?w=959&h=95&f=jpeg&s=161405)\r\n\r\n## 6. 验证效果\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632eaf0bcf7c7b5?w=791&h=798&f=jpeg&s=328293)\r\n\r\n最终在无缓存的slow 3G下DCL时间11.19s，相比最初的17.00s，降低34%。（wifi情况下降比例相同，时间大致同比为1/8~1/9，接近1s）。同时，相较于之前，一些静态资源能够更好地去利用HTTP Cache，节省带宽，降低每次新版上线后用户访问站点的静态资源下载量。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/5/1632e66b434d09f4?w=1662&h=901&f=jpeg&s=336048)\r\n\r\n## 7. 写在最后\r\n需要指出，性能优化也许有一些“基本准则”，但绝对没有银弹。无论是多么“基础与通用”的优化手段，亦或是多么“复杂而有针对性”的优化手段，都是在解决特定的具体问题。因此，解决性能问题往往都是从实际出发，通过“排查问题 --> 分析诊断 --> 实施优化 --> 验证效果”这样一条不断循环的路径来开展的。\r\n\r\n同时，提升性能的其中一个目的就是更好的用户体验。用户体验往往是一个宽泛的概念，涉及方方面面。相对应的，性能优化也不能只死盯着某个“指标”，更应该理解其背后对产品与用户的意义。从问题出发，拿数据量化，找解决方案。\r\n\r\n在实际环境下，面对有限的资源和各种限制，创造最大的价值。性能优化更是如此。\r\n\r\n\r\n## 参考资料\r\n\r\n- [HTML5 spec: parse HTML (the end)](https://www.w3.org/TR/html5/syntax.html#the-end)\r\n- [HTML5 spec: current-document-readiness](https://www.w3.org/TR/html5/dom.html#current-document-readiness)\r\n- [Deciphering the Critical Rendering Path](https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/)\r\n- [Network Analysis Reference](https://developers.google.com/web/tools/chrome-devtools/network-performance/reference)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/23","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/23/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/23/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/23/events","html_url":"https://github.com/alienzhou/blog/issues/23","id":390660035,"node_id":"MDU6SXNzdWUzOTA2NjAwMzU=","number":23,"title":"Gulp.js实践详解__基于Gulp的多页面应用实践指南","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T12:37:20Z","updated_at":"2018-12-13T12:54:54Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"![](http://upload-images.jianshu.io/upload_images/6476654-d582b5c044741c44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n## 1. 什么是多页应用\r\n相信很多人都知道单页面应用SPA（single page web application），那么与其相对的就是多页面应用，或者说是这种更为传统的站点——通过后端路由控制，访问不同url会由服务器吐出不同的页面与页面资源。由于SEO等一些因素，这种多页面的应用（或者说是站点更合适）如今仍然是一种非常重要的形式。\r\n\r\n由于近期的项目形态就是这样的，而在项目中最后选择使用了gulp作为自动化工具，但是网上的各类相关博文都比较零碎，不够系统；同时在实际应用中尤其是多页面站点中遇到的一些问题也没有特别好的实践，因此，将项目中遇到的问题和解决方案整理了一下。\r\n\r\n同时，借着项目中碰到的问题，也读了gulp及其一些相关库的源码，之后也会考虑写一些短文来进行交流。\r\n\r\n## 2. 什么是Gulp\r\n\r\n相信大家对Gulp应该不会太陌生，用一句Gulp官方的话来说：\r\n\r\n> Gulp就是基于流的前端自动化构建工具\r\n\r\n如果你完全不了解gulp，建议可以先简单浏览一下[gulp的官网](https://gulpjs.com/)\r\n\r\n> gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。\r\n\r\n开发者可以在文件读取与输出中进行相应的操作与处理，从而使输出的文件满足生产要求，实现自动化。其核心部分主要有两块：vinyl与vinyl-fs组成的基于文件的一种objectMode流及其相关操作，以及orchestrator这个任务以来与控制系统（但是gulp4.0好像已经舍弃了它）。当然，本文不会来介绍这两部分的原理或者实现（这部分内容会放在之后的文章里），而是聚焦于其实际的项目应用。\r\n\r\n## 3. 在多页应用开发中，我们要解决什么问题\r\n首先，在项目开发中，我们肯定会遇到各种依赖关系的管理。然而如果不用一些前端的依赖管理框架，浏览器是无法原生支持各种模块化规范的，而自动化工具的一大目标就是实现它们（或者说让你开发起来感觉像是实现了）。\r\n\r\n![项目开发时的各种依赖关系](http://upload-images.jianshu.io/upload_images/6476654-c78145e9df14fa47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n上图就是我们需要面对的繁杂的依赖关系。不像单页（SPA）应用中所有的JavaScript模块都会打包为一个文件（当然可能会有一些代码拆分之类的工作，但其本质上还是将整个站点的路由等页面控制的逻辑前置到了浏览器端）；与之对应的，多页面应用则可以说是一种更为传统，通过后端路由来进行页面的跳转。\r\n\r\n因此与单页应用最大的不同就在于，其打包出的文件决不能是一个单一的文件（一个JavaScript文件和一个CSS文件）。页面可能会包含一些公共部分，但每个页面至少需要对应一个独立的JavaScript与一个独立的CSS文件。因此，在各种复杂的处理后，对于多页面应用，我们需要做的就是显现下图的效果。\r\n\r\n![image.png](http://upload-images.jianshu.io/upload_images/6476654-071fe32a56dc9b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n其次，在管理模块化依赖之外，我们可能需要预处理一些文件。例如：将less文件编译为css文件，通过babel来使我们的es6代码能运行在不支持es6的浏览器等等。\r\n\r\n此外，类似在单页应用中遇到的问题，我们在多页面的情况下也会要处理。例如替换HTML中的环境变量，处理CSS中的雪碧图，甚至规避一些代码检查等等。\r\n\r\n最终，我们要将这些处理后的内容发布到运行目录中，实现自动化流程。\r\n\r\n## 4. 如何用Gulp来解决这些问题（workflow）\r\n如果细细梳理上一节所谈及的各项目标与工作，可以发现，这是一个紧密相接的工作流程（workflow），这一节会详细讲解各个工作流程。\r\n### 4.1. JS部分\r\n首先，我们来看一下JavaScript部分的工作流程：\r\n\r\n\r\n![JavaScript部分处理流程](http://upload-images.jianshu.io/upload_images/6476654-a512d598d147d565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n#### 4.1.1. 模块化打包\r\n\r\n项目使用browserify来实现CommonJS。如果用过browserify，应该不会对下面这段代码感到陌生：\r\n```javascript\r\nbrowserify({\r\n  entries: $your_entry_arr,\r\n  cache: {},\r\n  packageCache: {},\r\n  plugin: $your_plugin_arr\r\n});\r\n```\r\n通过设置一个（或一些）入口文件，可以将入口文件打包为一个文件。但是，在多页面应用中，最重要的有点就是，各个页面会有自己的JavaScript脚本文件。在项目开发时，在每个HTML页面中引入一个该页面特有的JavaScript脚本。例如页面list.html中通过`<script src=\"../js/list.js\"></script>`引入脚本。而该脚本使用CommonJS规范进行模块化。\r\n\r\n```javascript\r\n// ../js/list.js\r\nconst button = require('./common/button');\r\n// 一些button的操作\r\nbutton.render('#button');\r\n// ……\r\n```\r\n因此，需要针对不同的页面，打包出多份的JavaScript文件。首先使用`node-glob`获取每个页面的入口文件，其中`SRC_JS_PATH`为JavaScript源码的路径\r\n\r\n```javascript\r\n/**\r\n * 获取js入口文件路径组\r\n * @return {Array} 文件路径数组\r\n */\r\nconst getEntryJsFiles = () => (\r\n    glob.sync(`${SRC_JS_PATH}/**/*.js`, {\r\n        ignore: [`${SRC_JS_PATH}/*.dist.js`, `${SRC_JS_PATH}/*.mod.js`]\r\n    })\r\n);\r\n```\r\n然后，对每个入口文件创建其对应的bundle对象并返回，以便于在每个bundle对象上进行后续的js任务处理\r\n```javascript\r\nlet files = getEntryJsFiles();\r\n\r\n// 遍历所有入口文件，生成browserify对象\r\nbundleTasks = files.map(ele => ({\r\n  bundle: browserify({\r\n  entries: [ele],\r\n  cache: {},\r\n  packageCache: {},\r\n  plugin: [watchify]\r\n  }),\r\n  filename: ele\r\n}));\r\n```\r\n这样，我们就得到了一个`bundleTasks`，里面保存了所有页面对应的各自的入口文件的bundle对象与文件名。下面我们就会对每个bundle对象都应用上面流程图中的工序进行处理。我们先保留这个`bundleTasks`数组，来讲讲其他的工作流程。\r\n\r\n#### 4.1.2. 路径修正\r\n由于使用`node-glob`进行匹配，所以匹配到的路径不单单包含文件名，可能还会包含某些目录名。例如，可能想要匹配`list.js`，但是由于工作路径等原因，实际输出的路径名为`./page/list.js`。那么不进行处理会有什么问题呢？\r\n\r\n如果直接使用`gulp.dest`进行输出，默认会带上匹配出来的路径里面的所有片段，也就是说，我们可能只希望在dist目录下生成一个list.js文件，但实际上会生成一个page目录，目录里包含list.js文件。这就不符合我们的需求了。因此，使用`gulp-rename`进行路径调整（当然，`gulp-rename`也可以重命名文件）。\r\n\r\n在这里，还要推荐一个gulp工具：`gulp-load-plugins`。它可以自动帮我们加载`gulp-`开头的各类gulp插件。因此，可以很方面得进行路径调整。\r\n```javascript\r\n.pipe(plugins.rename({\r\n  dirname: ''\r\n}))\r\n```\r\n我们需要将该步处理置于打包操作之后。这里有一个需要注意的地方，由于bundle的stream是一个普通模式的stream，而gulp（vinyl）的stream则是一个objectMode的stream，因此需要一些转化与处理。这里就用到了`vinyl-source-stream`与`vinyl-buffer`两个库：\r\n```javascript\r\nconst source = require('vinyl-source-stream');\r\nconst buffer = require('vinyl-buffer');\r\nconst plugins = require('gulp-load-plugins')();\r\n\r\nbundle\r\n  .pipe(source(filename))\r\n  .pipe(buffer())\r\n  .pipe(plugins.rename({ // 修正路径名称\r\n    dirname: ''\r\n  }))\r\n```\r\n\r\n#### 4.1.3. 转码\r\n虽然部分浏览器对于es6语法已经有了较好的原生支持，但是为了能更好得保证es6代码在浏览器端的正常运行，还是推荐使用babel这样的工具来使得生产环境下的代码具有很好的浏览器兼容性（转为es5）。而在gulp中只需使用`gulp-babel`插件就可以很方便地实现，只需简单几行代码：\r\n```javascript\r\n.pipe(plugins.babel({\r\n  presets: ['env']\r\n}))\r\n```\r\n我们将该步操作置于第二步中的pipe之后。\r\n```javascript\r\nconst source = require('vinyl-source-stream');\r\nconst buffer = require('vinyl-buffer');\r\nconst plugins = require('gulp-load-plugins')();\r\n\r\nbundle\r\n  .pipe(source(filename))\r\n  .pipe(buffer())\r\n  .pipe(plugins.rename({\r\n    dirname: ''\r\n  }))\r\n  .pipe(plugins.babel({ // babel\r\n    presets: ['env']\r\n  }))\r\n```\r\n\r\n#### 4.1.4. 禁用代码检查\r\n由于项目的一些特殊原因，需要将开发时的源码和发布的生产环境代码一同上传到线上代码库，同时需要通过jslint的一些代码检查。但是发布后的代码很多时候是不符合代码规范的，因此，需要通过添加一些注释来取消对部分发布后代码的检查。\r\n\r\n这个插件也非常简单，通过判断文件类型，为文件头部加入特定的注释文本即可：\r\n```javascript\r\nconst through = require('through2');\r\nconst gutil = require('gulp-util');\r\nconst path = require('path');\r\nconst DIS_LINTER = {\r\n    html: '<!-- htmlcs-disable -->',\r\n    css: '/* csshint-disable */',\r\n    js: '/*eslint-disable */'\r\n};\r\n\r\nconst dislint = preText => {\r\n  let js = new Buffer(`${DIS_LINTER['js']}\\n`);\r\n  let css = new Buffer(`${DIS_LINTER['css']}\\n`);\r\n  let html = new Buffer(`${DIS_LINTER['html']}\\n`);\r\n  let buf = {\r\n    html,\r\n    css,\r\n    js\r\n  };\r\n\r\n  return through.obj((chunk, enc, cb) => {\r\n    let ext = '';\r\n    try {\r\n      ext = path.extname(chunk.path);\r\n    }\r\n    catch (err) {\r\n      console.log(err);\r\n    }\r\n    ext = ext.length > 0 ? ext.slice(1) : 'js';\r\n\r\n    // gutil.log(gutil.colors.magenta('[Disable Linter]'), chunk.path);\r\n    let preBuf = preText && preText.length > 0 ? new Buffer(preText) : buf[ext];\r\n    if (chunk.isNull()) {\r\n      cb(null, chunk);\r\n    }\r\n    if (chunk.isBuffer()) {\r\n      chunk.contents = Buffer.concat([preBuf, chunk.contents]);\r\n    }\r\n    if (chunk.isStream()) {\r\n      let stream = through();\r\n      stream.write(preBuf);\r\n      chunk.contents = chunk.contents.pipe(stream);\r\n    }\r\n    cb(null, chunk);\r\n  });\r\n};\r\n\r\nmodule.exports = dislint;\r\n```\r\n\r\n使用该插件：\r\n\r\n```javascript\r\nconst source = require('vinyl-source-stream');\r\nconst buffer = require('vinyl-buffer');\r\nconst plugins = require('gulp-load-plugins')();\r\nconst dislint = require('./dislint');\r\n\r\nbundle\r\n  .pipe(source(filename))\r\n  .pipe(buffer())\r\n  .pipe(plugins.rename({\r\n    dirname: ''\r\n  }))\r\n  .pipe(plugins.babel({\r\n    presets: ['env']\r\n  }))\r\n  .pipe(dislint()) // 取消代码检查\r\n```\r\n\r\n#### 4.1.5. 添加md5戳并输出\r\n为了防止用户浏览器缓存影响资源更新，可以通过添加md5戳的方式，来改变文件名称。这里用到了`gulp-md5Plus`这个插件。\r\n\r\n此外，在开发阶段，我们可以通过禁用浏览器缓存保证获取最新的资源，因此，在开发阶段可以禁用生成md5的功能。要根据不同的环境进行不同的操作，可以使用环境变量进行执行。`gulp-util`提供了这一功能。`gulp-util`是gulp可以看做是一个gulp的常用功能工具箱，里面包含了log、类型判断等一系列功能。\r\n\r\n这里，我们会在非生产环境下，使用`gutil.noop()`作为一个不进行任务处理的stream导出；而在生产环境下使用`gulp-md5Plus`来实现md5。最后，将处理后的文件输出到指定的发布目录：\r\n```javascript\r\nconst source = require('vinyl-source-stream');\r\nconst buffer = require('vinyl-buffer');\r\nconst plugins = require('gulp-load-plugins')();\r\nconst dislint = require('./dislint');\r\nconst gutil = require('gulp-util');\r\n\r\nbundle\r\n  .pipe(source(filename))\r\n  .pipe(buffer())\r\n  .pipe(plugins.rename({\r\n    dirname: ''\r\n  }))\r\n  .pipe(plugins.babel({\r\n    presets: ['env']\r\n  }))\r\n  .pipe(dislint())\r\n  .pipe(gutil.env.env === 'production' ? plugins.md5Plus(5, `${DIST_HTML_PATH}/**/*.html`) : gutil.noop())  // md5\r\n  .pipe(gulp.dest(DIST_JS_PATH)) // 发布文件\r\n```\r\n\r\n#### 4.1.6. 错误处理\r\n由于gulp是基于stream的操作，因此使用try…catch…语法显然是无法处理抛出的异常；取而代之就需要监听stream上的error事件。但是，在代码里，我们总不能在每个`.pipe()`后加上`.on('error', function(){}})`这样的代码吧，那也太臃肿了。\r\n\r\n为了解决这个问题，就可以使用`gulp-plumber`插件。只需要在stream的最前面加上它，就可以了。\r\n```javascript\r\nbundle\r\n  .pipe(plugins.plumber(err => {\r\n    log(red(`[${err.plugin}]`), red(err.message));\r\n  }))\r\n  .pipe(source(filename))\r\n  .pipe(buffer())\r\n  .pipe(plugins.rename({\r\n    dirname: ''\r\n  }))\r\n  .pipe(plugins.babel({\r\n    presets: ['env']\r\n  }))\r\n  .pipe(dislint())\r\n  .pipe(gutil.env.env === 'production' ? plugins.md5Plus(5, `${DIST_HTML_PATH}/**/*.html`) : gutil.noop())  // md5\r\n  .pipe(gulp.dest(DIST_JS_PATH)) // 发布文件\r\n```\r\n\r\n#### 4.1.7. 封装任务\r\n可以看到，上面的一系列任务是每个入口js文件都会经历的，因此，我们将“路径修正-->转码-->禁用代码检查-->md5-->输出”这个流程封装为一个叫做jsTask的任务，并应用在每个bundle上。\r\n\r\n```javascript\r\n/**\r\n * js任务流，具体包括：\r\n * 模块打包 --> 路径修正(重命名) --> babel --> 取消代码检查 --> md5(production状态) --> 产出\r\n * @param {Object} bundle 各入口文件的browserify对象\r\n * @param {string} filename 入口文件名\r\n * @return {stream} stream 对象\r\n */\r\nconst jsTask = ({bundle, filename}) => (\r\n    bundle.bundle((err, buf) => {\r\n        if (err) {\r\n            // 浏览器提示\r\n            browserSync.notify(`[Browserify Error] ${err.message}`, 10000);\r\n            log(red('[Browserify Error]'), red(err.message));\r\n        }\r\n    })\r\n    .pipe(plugins.plumber(err => {\r\n        log(red(`[${err.plugin}]`), red(err.message));\r\n    }))\r\n    .pipe(source(filename))\r\n    .pipe(buffer())\r\n    .pipe(plugins.rename({\r\n        dirname: ''\r\n    }))\r\n    .pipe(plugins.babel({\r\n        presets: ['env']\r\n    }))\r\n    .pipe(dislint())\r\n    .pipe(gutil.env.env === 'production' ? plugins.md5Plus(5, `${DIST_HTML_PATH}/**/*.html`) : gutil.noop())\r\n    .pipe(gulp.dest(DIST_JS_PATH))\r\n);\r\n```\r\n`jsTask`会包装并返回整个js任务的流。基于以上代码，我们可以定义一个`dist:js`任务来发布js代码：\r\n\r\n```javascript\r\n/**\r\n * 获取js入口文件路径组\r\n * @return {Array} 文件路径数组\r\n */\r\nconst getEntryJsFiles = () => (\r\n  glob.sync(`${SRC_JS_PATH}/**/*.js`, {\r\n    ignore: [`${SRC_JS_PATH}/*.dist.js`, `${SRC_JS_PATH}/*.mod.js`]\r\n  })\r\n);\r\n\r\n// [发布]js代码，其中会进行js相关工作流程\r\ngulp.task('dist:js', cb => {\r\n  let files = getEntryJsFiles();\r\n\r\n  // 遍历所有入口文件，生成browserify对象\r\n  bundleTasks = files.map(ele => ({\r\n    bundle: browserify({\r\n      entries: [ele],\r\n      cache: {},\r\n      packageCache: {},\r\n      plugin: [watchify]\r\n    }),\r\n    filename: ele\r\n  }));\r\n\r\n  // 映射与合并js流\r\n  let streams = bundleTasks.map(jsTask);\r\n  return es.merge(streams);\r\n});\r\n\r\n// [删除]发布目录下的js文件\r\ngulp.task('del:js', () => del.sync([`${DIST_JS_PATH}/*`]));\r\n```\r\n#### 4.1.8. 自动刷新浏览器\r\n前端开发需要频繁修改并希望能看到浏览器中展现的情况，因此，解放你的F5显然很有必要。在项目里，可以使用`browserSync`来做到这一点。\r\n\r\n`browserSync`可以在代码更新时自动刷新浏览器，同时还可以向浏览器推送消息进行展示。使用`browserSync`，可以建立相应的gulp任务，在第一次执行gulp时启动browserSync，并创建reload:browser任务，这样在需要的时候就能方便得触发浏览器刷新。\r\n```javascript\r\nconst browserSync = require('browser-sync').create();\r\n\r\n// [启动]browserSync\r\ngulp.task('start:browserSync', () => browserSync.init({\r\n  proxy: '192.168.11.23',\r\n  notify: true\r\n}));\r\n\r\n// 刷新浏览器\r\ngulp.task('reload:browser', cb => {\r\n  browserSync.reload();\r\n  cb();\r\n});\r\n```\r\n\r\n#### 4.1.9. 增量发布\r\n上面介绍了对于一个js入口文件的整套工作流。然而在实际开发中，我们在修改了某一个文件之后，并不需要将所有的代码全量再发布一遍，如果能每次只增量得发布与修改相关的js代码，会在开发体验与效率上有较大的提升。\r\n\r\n同时，结合`browserSync`可以让你的开发效率极大获得提升。为此，我们需要`watchify`来进行文件监听，并将其作为`browserify`的插件，实现文件的增量打包编译。通过监听每个bundle的update事件，可以在文件更新时重新打包并处理发布，最后到stream触发end事件（处理完成）时刷新浏览器。\r\n\r\n```javascript\r\n/**\r\n * 监听各个browserify对象的update事件\r\n * 在模块更新时按需打包\r\n * @param {Object} bundle 各入口文件的browserify对象\r\n * @param {string} filename 入口文件名\r\n */\r\nconst addBundleTaskListeners = ({bundle, filename}) => {\r\n  bundle.on('update', () => {\r\n    log(blue('[Browserify Update]'), filename);\r\n    let sm = jsTask({bundle, filename});\r\n    // 打包完成后刷新浏览器（错误不刷新，保留notify）\r\n    sm.on('end', () => runSequence('reload:browser'));\r\n  });\r\n};\r\n\r\n// [监听]为所有入口文件对应的browserify对象添加update监听\r\ngulp.task('watch:js', () => {\r\n  bundleTasks.forEach(item => {\r\n    addBundleTaskListeners(item);\r\n  });\r\n});\r\n```\r\n\r\n### 4.2. HTML部分\r\n\r\n![HTML部分处理流程](http://upload-images.jianshu.io/upload_images/6476654-826361fea7518d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\nHTML部分主要包括两个工作：文件内变量的替换与文件路径的修正。\r\n\r\n#### 4.2.1. 替换文件内变量\r\n在开发中，经常会有类似这样的需求：\r\n- 在开发环境下，我们会引用一些开发机上的静态资源；然而在生产环境中，则需要替换成线上的CDN地址。\r\n- 协同开发下，不同的开发人员可能会使用不同的资源路径。\r\n- 为每个HTML设置title内容，其中一部分为统一文字，例如：我的主页——贡献列表、我的主页——个人设置…尤其在开发中，“我的主页”可能突然要被换成“个人中心”之类的…\r\n- HTML中其他不常更改但可能需要各处统一的部分…\r\n\r\n上面这些需求我们当然可以通过手工替换的方式开解决，它们本身并无太多技术含量，但很浪费开发人员的精力，并且还可能因为粗心大意产生错误或遗漏。因此如果能在gulp中自动替换这些变量，必然会节省很多麻烦。\r\n\r\n参考一些其他工具或脚手架里的功能，我们的目标效果是：在项目根目录下定义这些变量（例如在.env或.env.local文件中）\r\n```\r\n$ONE_CDN$=http://cp01-test.XXXX.com\r\n$ONE_TITLE$=我的主页\r\n```\r\n然后在HTML中直接使用\r\n\r\n```xml\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n    <title>$ONE_TITLE$——贡献列表</title>\r\n    <link rel=\"shortcut icon\" href=\"/img/icon.png\" />\r\n\r\n    <script src=\"$ONE_CDN$/vendors/bower_components/jquery/dist/jquery.min.js\"></script>\r\n    <script src=\"$ONE_CDN$/vendors/bower_components/bootstrap/dist/js/bootstrap.min.js\"></script>\r\n    <script src=\"$ONE_CDN$/js/app.min.js\"></script>\r\n    <link href=\"$ONE_CDN$/vendors/bower_components/animate.css/animate.min.css\" rel=\"stylesheet\">\r\n    <link href=\"$ONE_CDN$/vendors/bower_components/bootstrap/dist/js/bootstrap.min.css\" rel=\"stylesheet\">\r\n    ……\r\n</head>\r\n```\r\n\r\n下面，就要需要一个方法能够读取出.env和.env.local文件中的所有变量（默认先使用.env.local，可以理解为.env.local会覆盖.env中的同名变量）\r\n\r\n```javascript\r\n/**\r\n * trim\r\n * @param {string} str 待处理字符串\r\n * @return {string} 处理后的字符串\r\n */\r\nconst trim = str => str.replace(/(^\\s*)|(\\s*$)/g, '');\r\n\r\n/**\r\n * 获取文件中的环境变量\r\n * @return {Object} 环境变量map\r\n */\r\nconst getEnv = () => {\r\n    let prepare = ['.env.local', '.env'];\r\n    let env = {};\r\n\r\n    /**\r\n     * 检查.env中变量名是否合法\r\n     * 全部使用大写字母，用_连接，第一个单词为ONE，首尾使用$\r\n     * @param {string} key 待检查的变量名\r\n     * @return {boolean} 检查结果，合法true，非法false\r\n     */\r\n    function envCheck(key) {\r\n        return /^\\$ONE(_[A-Z]+)+\\$$/.test(key);\r\n    }\r\n\r\n    /**\r\n     * 读取文件中的变量\r\n     * @param {string} filename 配置文件\r\n     * @return {Object} 配置变量\r\n     */\r\n    function readEnvFile(filename) {\r\n        let env = {};\r\n        try {\r\n            let filepath = path.resolve('.', filename);\r\n            if (fs.existsSync(filepath) && fs.statSync(filepath).isFile()) {\r\n                fs.readFileSync(filepath, 'utf-8')\r\n                    .split(/\\r?\\n/)\r\n                    .filter(ele => ele !== '')\r\n                    .forEach(ele => {\r\n                        let pairs = ele.split('=');\r\n                        let key = trim(pairs[0]);\r\n                        let value = trim(pairs[1]);\r\n                        if (envCheck(key)) {\r\n                            env[key] = value;\r\n                        }\r\n                        else {\r\n                            log(red('[env]'), `无效的变量名: ${key}`, 'tip: 全部使用大写字母，用_连接，第一个单词为ONE，首尾使用$');\r\n                        }\r\n                    });\r\n            }\r\n        }\r\n        catch (err) {\r\n            log(red('[env]'), '读取env变量出错', err);\r\n        }\r\n        finally {\r\n            return env;\r\n        }\r\n    }\r\n\r\n    let envArr = [{}];\r\n    // 优先寻找本地配置.env.local\r\n    while (prepare.length) {\r\n        // 生产环境下优先使用.env\r\n        let filename = gutil.env.env === 'production' ? prepare.shift() : prepare.pop();\r\n        envArr.push(readEnvFile(filename));\r\n    }\r\n\r\n    return Object.assign.apply(null, envArr);\r\n};\r\n```\r\n\r\n`getEnv()`方法可以读取所有定义的环境变量，并保存为一个键值对形式的对象，键名是变量名，值则是变量的值\r\n\r\n```javascript\r\n// getEnv()\r\n{\r\n  'ONE_CDN': 'http://cp01-test.XXXX.com',\r\n  'ONE_TITLE': '我的主页'\r\n}\r\n```\r\n\r\n由于要替换文件内容，我们可以使用`event-stream`库来进行stream的操作。使用其中的`.replace()`方法来替换文件内容，代码片段如下：\r\n\r\n```javascript\r\nconst es = require('event-stream');\r\n\r\nlet pipe = fs.createReadStream(sourceFile);\r\n\r\n// 添加管道，替换.env中的环境变量\r\nfor (let k in envMap) {\r\n  pipe = pipe.pipe(es.replace(k, envMap[k]));\r\n}\r\n```\r\n\r\n#### 4.4.2. 修正文件路径\r\n类似JavaScript中的文件路径修正操作，在HTML中同样使用`gulp-rename`来实现，路径修正部分代码片段如下：\r\n```javascript\r\n// 路径格式化正则\r\nlet reg = new RegExp(`^${path.relative('.', SRC_HTML_PATH)}`);\r\n\r\nreturn (\r\n  pipe.pipe(source(sourceFile))\r\n    .pipe(dislint())\r\n    .pipe(plugins.rename(p => {\r\n      // 格式化目标路径\r\n      p.dirname = p.dirname.replace(reg, '');\r\n    }))\r\n    .pipe(gulp.dest(DIST_HTML_PATH))\r\n);\r\n```\r\n\r\n#### 4.2.3. 封装任务\r\n将变量替换与文件路径修正两部分代码封装为一个任务函数`htmlTask`\r\n\r\n```javascript\r\n/**\r\n * html发布任务\r\n * @param {string} sourceFile 需要发布的目标html文件\r\n * @return {stream} 文件流\r\n */\r\nconst htmlTask = sourceFile => {\r\n  let pipe = fs.createReadStream(sourceFile);\r\n\r\n  // 添加管道，替换.env中的环境变量\r\n  for (let k in envMap) {\r\n    pipe = pipe.pipe(es.replace(k, envMap[k]));\r\n  }\r\n\r\n  // 路径格式化正则\r\n  let reg = new RegExp(`^${path.relative('.', SRC_HTML_PATH)}`);\r\n\r\n  return (\r\n    pipe.pipe(source(sourceFile))\r\n      .pipe(dislint())\r\n      .pipe(plugins.rename(p => {\r\n        // 格式化目标路径\r\n        p.dirname = p.dirname.replace(reg, '');\r\n      }))\r\n      .pipe(gulp.dest(DIST_HTML_PATH))\r\n  );\r\n};\r\n```\r\n在此基础上，创建一个gulp任务用于HTML文件的发布\r\n```javascript\r\n// [发布]html页面\r\ngulp.task('dist:html', () => {\r\n  let files = glob.sync(`${SRC_HTML_PATH}/**/*.html`);\r\n  let streams = files.map(htmlTask);\r\n  return es.merge(streams);\r\n});\r\n```\r\n同时，还需要把已有的文件删除，这里用到了`del`这个包\r\n```javascript\r\nconst del = require('del');\r\n\r\n// [删除]发布目录额下的html文件\r\ngulp.task('del:html', () => del.sync([`${DIST_HTML_PATH}/*`]));\r\n```\r\n\r\n### 4.3. CSS部分\r\n\r\n![CSS部分处理流程](http://upload-images.jianshu.io/upload_images/6476654-ff7268e61e149d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\nCSS部分的处理流程中大部分与之前的操作大同小异，其中最主要的区别是在CSS中使用到`gulp-less`插件与`gulp-minify-css`插件分别对less文件进行预处理与压缩\r\n```javascript\r\ngulp.src(`${SRC_CSS_PATH}/**/*.less`) //多个文件以数组形式传入\r\n  .pipe(less())\r\n  .pipe(minifyCss())\r\n  .pipe(gulp.dest('dist/css')); \r\n```\r\n\r\n最终CSS部分的处理任务如下：\r\n```javascript\r\n// [删除]发布目录下的css文件\r\ngulp.task('del:css', () => del.sync([`${DIST_CSS_PATH}/*`]));\r\n\r\n// [发布]css文件\r\ngulp.task('dist:css', function () {\r\n  gulp.src(`${SRC_CSS_PATH}/**/*.less`) \r\n    .pipe(plugins.rename({\r\n        dirname: ''\r\n    }))\r\n    .pipe(less())\r\n    .pipe(minifyCss())\r\n    .pipe(gulp.dest('dist/css')); \r\n});\r\n```\r\n\r\n## 4.4. 组合与管理这些任务\r\n我们定义上面一系列的任务，但最终的目标是将这些任务组合起来，让他们变成一条指令（或某几条指令）。为了更好得组织任务依赖，控制任务流程，我们使用`run-sequence`来控制这些任务的执行。\r\n\r\n最常见的，首先是在开发时，希望输入`gulp`就可以进入开发模式，能够监听变化并自动刷新浏览器。\r\n\r\n```javascript\r\n// [监听]为所有入口文件对应的browserify对象添加update监听\r\ngulp.task('watch:js', () => {\r\n  bundleTasks.forEach(item => {\r\n    addBundleTaskListeners(item);\r\n  });\r\n});\r\n\r\n// [监听]更新CSS\r\ngulp.task('watch:css', () => {\r\n  gulp.watch(['!**/gulpfile.js', 'src/**/*.css'], () => {\r\n    runSequence(\r\n      'del:css',\r\n      'dist:css',\r\n      'reload:browser'\r\n    );\r\n  });\r\n  cb();\r\n});\r\n\r\n// [启动]browserSync\r\ngulp.task('start:browserSync', () => browserSync.init({\r\n  proxy: '192.168.11.23',\r\n  notify: true\r\n}));\r\n\r\n// 刷新浏览器\r\ngulp.task('reload:browser', cb => {\r\n  browserSync.reload();\r\n  cb();\r\n});\r\n\r\n// [监听]html文件变化\r\ngulp.task('watch:html', cb => {\r\n  // 监听html变化，全量发布新html\r\n  gulp.watch(['!**/gulpfile.js', 'src/**/*.html'], () => {\r\n    runSequence(\r\n      'del:html',\r\n       'dist:html',\r\n      'reload:browser'\r\n    );\r\n  });\r\n  cb();\r\n});\r\n\r\n// 发布模式\r\n// build任务，进行项目资源发布\r\ngulp.task('build', cb => {\r\n  runSequence(\r\n    ['del:html', 'del:js'],\r\n    'dist:html',\r\n    'dist:js',\r\n    cb\r\n  );\r\n});\r\n\r\n// 开发模式\r\n// 执行发布，并进行监听\r\ngulp.task('default', cb => {\r\n  runSequence(\r\n    'build',\r\n    'start:browserSync',\r\n    ['watch:js', 'watch:html', 'watch:css'],\r\n    cb\r\n  );\r\n});\r\n```\r\n\r\n当然，常用的还有发布任务\r\n```javascript\r\n// 发布模式\r\n// 构建资源发布，并退出gulp进程\r\ngulp.task('dist', cb => {\r\n  gutil.env.env = gutil.env.env === undefined ? 'production' : gutil.env.env;\r\n  runSequence(\r\n    'build',\r\n    () => {\r\n      cb();\r\n      process.nextTick(process.exit);\r\n    }\r\n  );\r\n});\r\n```\r\n## 总结\r\n文章里主要整理了我在项目中用到的一些解决方案与实践方法。其中也还存在一些不足，例如HTML与CSS的增量发布等，这些都是之后可以再进行优化的地方。\r\n\r\n完。\r\n\r\n----\r\nHappy Coding！\r\n----\r\n----","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/22","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/22/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/22/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/22/events","html_url":"https://github.com/alienzhou/blog/issues/22","id":390659811,"node_id":"MDU6SXNzdWUzOTA2NTk4MTE=","number":22,"title":"年终回顾，为你汇总一份「前端技术清单」","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T12:36:39Z","updated_at":"2018-12-13T12:36:39Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 2018 眼看就要过去了，今年的你相较去年技术上有怎样的收获呢？\r\n\r\n记得年初的时候我给自己制定了一个学习计划，现在回顾来看完成度还不错。但仍有些遗憾，一些技术点没有时间去好好学习。\r\n\r\n在学习中我发现，像文章这样的知识往往是碎片化的，而前端涉及到的面很多，如果不将这些知识有效梳理，则无法形成体系、相互串联。最后有一种东懂一块，西了解一点的感觉。因此，我结合工作体会抽象出了一些前端基础技术能力，并将这段时间学习或产出的一些不错的内容根据这些能力进行整理，形成了一份前端技术清单（[github 地址](https://github.com/alienzhou/frontend-tech-list)）。\r\n\r\n不论你是正在自学前端遇到了瓶颈，还是对某些技术熟练掌握但某些还未涉足，都希望这份清单能对你有所帮助。\r\n\r\n> 由于个人精力有限，一些技术点的归纳可能有失偏颇，或者目前并未纳入进来，因此 [github 上的清单内容](https://github.com/alienzhou/frontend-tech-list) 也会不断更新。目前只包含纯前端基础内容，NodeJS 、客户端泛前端、小程序、可视化等内容先留着坑吧。\r\n\r\n清单内容↓↓↓\r\n\r\n## 0. 年度报告\r\n\r\n- [2018 前端工具调查报告](https://ashleynolan.co.uk/blog/frontend-tooling-survey-2018-results)\r\n- [2018 JavaScript 调查报告](https://2018.stateofjs.com/)\r\n\r\n## 1. 基础拾遗\r\n\r\n> 温故而知新，不知则习之，是以牢固根基。\r\n\r\n### 1.1. JavaScript\r\n\r\n- [You-Dont-Know-JS \\[英\\]](https://github.com/getify/You-Dont-Know-JS)\r\n- JavaScript 基础运行机制：\r\n    - [JS 引擎、运行时与调用栈概述 \\[英\\]](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf)\r\n    - [V8 引擎简介 \\[英\\]](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e)\r\n    - [内存管理与4中常见的泄漏 \\[英\\]](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)\r\n- Event Loop（面试里总会有一题 Event Loop…）：\r\n    - [从 Event Loop 规范探究 JavaScript 异步及浏览器更新渲染时机](https://github.com/aooy/blog/issues/5)\r\n    - [异步之 Event Loop \\[英\\]](https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5)\r\n    - [NodeJS 中的 Event Loop、Timers 与 `process.nextTick()` \\[英\\]](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\r\n    - [Tasks、Microtasks、Queues 与Schedules \\[英\\]](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\r\n- [Web Workers 及其5个常见使用场景 \\[英\\]](https://blog.sessionstack.com/how-javascript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c0757f6a)\r\n- [如何避免 async/await 地狱 \\[英\\]](https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c)\r\n- [“回调地狱”的解决思路汇总](https://www.jianshu.com/p/bc7b8d542dcd)\r\n\r\n### 1.2. CSS\r\n\r\n- [You-Need-to-Know-CSS](https://lhammer.cn/You-need-to-know-css/#/)\r\n- [CSS布局指南](https://juejin.im/post/5b3b56a1e51d4519646204bb)\r\n- [CSS 中的各类换行处理方式 \\[英\\]](https://css-tricks.com/where-lines-break-is-complicated-heres-all-the-related-css-and-html/)：处理经典的换行问题\r\n- [浏览器将rem转成px时有精度误差怎么办？](https://www.zhihu.com/question/264372456)\r\n- [精准操控的滚动体验，浅谈新标准 Scroll Snap](https://juejin.im/post/5ba079e86fb9a05d1227fddb)\r\n- [如何完美实现一个非`button`元素的按钮 \\[英\\]](https://www.scottohara.me/blog/2018/10/03/unbutton-buttons.html)\r\n- [巧用 CSS Grid 来创建横向滚动容器 \\[英\\]](https://uxdesign.cc/creating-horizontal-scrolling-containers-the-right-way-css-grid-c256f64fc585)\r\n- [如何处理内联元素中的空隙 \\[英\\]](https://css-tricks.com/fighting-the-space-between-inline-block-elements/)\r\n- [CSS Stacking Context 里那些鲜为人知的坑](https://segmentfault.com/a/1190000002783265)\r\n\r\n### 1.3. 浏览器\r\n\r\n- [浏览器的工作原理](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\r\n- 现代浏览器内部是如何运行的：\r\n    - [Chrome浏览器概览](https://developers.google.com/web/updates/2018/09/inside-browser-part1)\r\n    - [浏览时发生了什么？](https://developers.google.com/web/updates/2018/09/inside-browser-part2)\r\n    - [渲染进程的内部工作原理](https://developers.google.com/web/updates/2018/09/inside-browser-part3)\r\n    - [compositor是如何来提高交互性能的？](https://developers.google.com/web/updates/2018/09/inside-browser-part4)\r\n- [完整的页面生命周期 API 介绍 \\[英\\]](https://developers.google.com/web/updates/2018/07/page-lifecycle-api)\r\n- [四个新的观察者：Intersection / Mutation / Resize / Performance (Observer)](https://www.zeolearn.com/magazine/different-types-of-observers-supported-by-modern-browsers)\r\n- [渲染引擎工作方式及优化建议 \\[英\\]](https://blog.sessionstack.com/how-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance-7b95553baeda)\r\n- [浏览器内核渲染：重建引擎](https://juejin.im/post/5bbaa7da6fb9a05d3761aafe)\r\n- [跨域解决方案汇总](https://www.jianshu.com/p/438183ddcea8)\r\n\r\n## 2. 工程化与工具\r\n\r\n> 软件规模的扩大带来了工程化的需求，前端也不例外。随着 NodeJS 的出现，前端工程师可以使用熟悉的 JS 快速开发所需的工具。工具链生态的繁荣也是前端圈繁荣的一个写照。\r\n\r\n### 2.1. webpack\r\n\r\n- [webpack 中的 Chunk 关系图算法 \\[英\\]](https://medium.com/webpack/the-chunk-graph-algorithm-week-26-29-7c88aa5e4b4e)\r\n- [webpack 进阶系列文章](https://juejin.im/post/5bc1a73df265da0a8d36b74f#heading-13)\r\n- 编译优化：\r\n    - [如何提升大型项目中 webpack 的性能 🎥 \\[英\\]](https://www.youtube.com/watch?v=AifDI71uqF0)\r\n    - [运行时优化：Separating a Manifest \\[英\\]](https://survivejs.com/webpack/optimizing/separating-manifest)\r\n    - [在 webpack 中使用 \\<link rel=”prefetch/preload”> \\[英\\]](https://medium.com/webpack/link-rel-prefetch-preload-in-webpack-51a52358f84c)\r\n    - [如何更好使用 webpack tree-shaking](https://juejin.im/post/5b8ce49df265da438151b468)\r\n- 关于 webpack 编译缓存的讨论：\r\n    - [mzgoddard's comment](https://github.com/webpack/webpack/issues/250#issuecomment-240643985)\r\n    - [\\[spec: webpack 5\\] - A module disk cache between build processes](https://github.com/webpack/webpack/issues/6527)\r\n\r\n### 2.2. Gulp\r\n\r\n- [Gulp 4 简介 \\[英\\]](https://fettblog.eu/gulp-4-parallel-and-series/)\r\n- [基于Gulp的多页面应用实践指南](https://www.jianshu.com/p/35571124770f)\r\n\r\n### 2.3. Linter\r\n\r\n- [JS Linter 进化史](https://zhuanlan.zhihu.com/p/34656263)\r\n- [为何要在项目汇总使用 ESLint \\[英\\]](https://medium.com/the-node-js-collection/why-and-how-to-use-eslint-in-your-project-742d0bc61ed7)\r\n\r\n### 2.4. 静态类型（Typescript/Flow）\r\n\r\n- [Typescript 总体架构 \\[英\\]](https://github.com/Microsoft/TypeScript/wiki/Architectural-Overview)\r\n- 为什么要在 JavaScript 中进行静态类型检查：\r\n    - [第一部分](https://www.jianshu.com/p/bda750e2d15e)\r\n    - [第二、三部分](https://www.jianshu.com/p/289b3c734a9f)\r\n    - [第四部分](https://www.jianshu.com/p/d23f93be8821)\r\n\r\n### 2.5. Babel\r\n\r\n- [Babel 用户手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md)\r\n- [Babel 插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md)\r\n\r\n### 2.6. CSS预处理与模块化\r\n\r\n- [CSS 进化史 \\[英\\]](https://medium.com/@perezpriego7/css-evolution-from-css-sass-bem-css-modules-to-styled-components-d4c1da3a659b)\r\n- [CSS 模块化方案系列](https://juejin.im/post/5b20e8e0e51d4506c60e47f5)\r\n\r\n## 3. 性能优化\r\n\r\n> 性能优化其实就是在理解浏览器的基础上“因地制宜”，因此可以配合1.3节“浏览器”部分进行理解。\r\n\r\n强烈推荐把 [Google Web 上性能优化](https://developers.google.com/web/fundamentals/performance/why-performance-matters/) Tab 中的文章都通读一遍，其基本涵盖了现代浏览器中性能优化的所有点，非常系统。下面也摘录了其中一些个人认为非常不错的篇幅。\r\n\r\n### 3.1. 加载性能\r\n\r\n- [PRPL 模式 \\[英\\]](https://developers.google.com/web/fundamentals/performance/prpl-pattern/)\r\n- [图片懒加载完全指南 \\[英\\]](https://css-tricks.com/the-complete-guide-to-lazy-loading-images)\r\n- [使用 Intersection Observer 来懒加载图片 \\[英\\]](http://deanhume.com/lazy-loading-images-using-intersection-observer/)\r\n- [图片与视频懒加载的详细指南 \\[英\\]](https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/)\r\n- [使用 Application Shell 架构来实现秒开应用 \\[英\\]](https://developers.google.com/web/updates/2015/11/app-shell)\r\n\r\n### 3.2. 运行时性能\r\n\r\n- [避免大型、复杂的布局和布局抖动 \\[英\\]](https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=zh-cn#avoid-forced-synchronous-layouts)\r\n- [什么导致强制同步布局（reflow）？ \\[英\\]](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)\r\n- [如何诊断强制同步布局 \\[英\\]](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/forced-synchronous-layouts?hl=zh-cn)\r\n- [无线性能优化：Composite](http://taobaofed.org/blog/2016/04/25/performance-composite/)\r\n- [如何不择手段提升scroll事件的性能](https://zhuanlan.zhihu.com/p/30078937)\r\n- [使用 passive event listener 来提高滚动流畅性 \\[英\\]](https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md)\r\n- 节流和去抖（throttle & debounce）：\r\n    - [JavaScript 函数节流和函数去抖应用场景辨析](https://github.com/hanzichi/underscore-analysis/issues/20)\r\n    - [underscore 函数去抖的实现](https://github.com/hanzichi/underscore-analysis/issues/21)\r\n- requestIdleCallback - 一个强大而神器的 API：\r\n    - [requestIdleCallback使用入门 \\[英\\]](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)\r\n    - [Idle Until Urgent \\[英\\]](https://philipwalton.com/articles/idle-until-urgent)：requestIdleCallback的妙用\r\n\r\n### 3.3. 前端缓存\r\n\r\n- [Web 缓存简介：以购买牛奶的为例 \\[英\\]](https://dev.to/kbk0125/web-caching-explained-by-buying-milk-at-the-supermarket-9k4)\r\n- [大话前端缓存 \\[英\\]](https://calendar.perfplanet.com/2016/a-tale-of-four-caches/)\r\n- [缓存（一）—— 缓存总览：从性能优化的角度看缓存](https://github.com/amandakelake/blog/issues/43)\r\n- [缓存（二）—— 浏览器缓存机制：强缓存、协商缓存](https://github.com/amandakelake/blog/issues/41)\r\n- [缓存（三）—— 数据存储：cookie、Storage、indexedDB](https://github.com/amandakelake/blog/issues/13)\r\n\r\n### 3.4. 性能调试与实践\r\n\r\n- [使用 Chrome DevTools 提升页面速度 \\[英\\]](https://developers.google.com/web/tools/chrome-devtools/speed/get-started)：Chrome DevTools实操讲解\r\n- [了解 DevTools 中的 Resource Timing](https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing)\r\n- [淘宝新势力周H5性能优化实战](https://segmentfault.com/a/1190000014359615)\r\n- [优化打包策略来提升页面加载速度](https://juejin.im/post/5aed037b6fb9a07aa047e1e1)\r\n- [Chrome DevTools 中你可能不知道的调试技巧](https://zhuanlan.zhihu.com/p/42059158)\r\n- [前端性能测量 \\[英\\]](https://speedcurve.com/blog/user-timing-and-custom-metrics/)\r\n\r\n### 3.5. 性能指标\r\n\r\n- [以用户为中心的前端性能指标 \\[英\\]](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics)：前端性能指标的来龙去脉\r\n- DOMContentLoaded:\r\n    - [你不知道的 DOMContentLoaded](https://zhuanlan.zhihu.com/p/25876048)\r\n    - [Deciphering the Critical Rendering Path \\[英\\]](https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/)\r\n- FP (First Paint)：\r\n    - [Chrome的First Paint](http://eux.baidu.com/blog/fe/Chrome%E7%9A%84First%20Paint)\r\n- FCP (First Contentful Paint)：\r\n    - [First Contentful Paint Explained \\[英\\]](https://gtmetrix.com/blog/first-contentful-paint-explained/)\r\n    - [First Contentful Paint \\[英\\]](https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint)\r\n- FMP (First Meaningful Paint)：\r\n    - [Chrome 中的 First Meaningful Paint](https://juejin.im/entry/598080226fb9a03c5d535cd5)\r\n    - [Time to First Meaningful Paint](https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/view?hl=zh-cn#heading=h.k50nnyhtptq0)\r\n- TTI (Time to interactive)：\r\n    - [Time to Interactive Explainer](https://github.com/WICG/time-to-interactive)\r\n    - [衡量用户体验的新标准](https://calendar.perfplanet.com/2017/time-to-interactive-measuring-more-of-the-user-experience/)\r\n- TTFB (Time To First Byte)：\r\n    - [TTFB，以及页面加载的时间节点](https://zhuanlan.zhihu.com/p/23588780)\r\n- FID (First Input Delay)：\r\n    - [First Input Delay](https://developers.google.com/web/updates/2018/05/first-input-delay)\r\n- Speed Index：\r\n    - [WebPagetest: Speed Index](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index)\r\n\r\n## 4. 安全\r\n\r\n> 很多安全风险老生常谈，但是往往到出现问题时，才会被重视或者意识到。\r\n\r\n- [8大前端安全问题上篇](https://insights.thoughtworks.cn/eight-security-problems-in-front-end/)\r\n- [8大前端安全问题下篇](http://insights.thoughtworks.cn/eight-security-problems-in-front-end-2/)\r\n- [概念讲解：编码、加密、哈希与混淆 \\[英\\]](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation)\r\n- [常见 Web 安全攻防总结](https://zoumiaojiang.com/article/common-web-security/)\r\n\r\n### 4.1. XSS\r\n\r\n- [如何防止XSS攻击？](https://tech.meituan.com/fe_security.html)\r\n\r\n### 4.2. CSRF\r\n\r\n- [如何防止CSRF攻击？](https://juejin.im/post/5bc009996fb9a05d0a055192)\r\n- [Site Isolation \\[英\\]](https://developers.google.com/web/updates/2018/07/site-isolation)：Chrome的新特性\r\n\r\n### 4.3. CSP\r\n\r\n- [Content Security Policy 入门教程](http://www.ruanyifeng.com/blog/2016/09/csp.html)\r\n- [Content Security Policy (CSP) \\[英\\]](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)\r\n\r\n### 4.4. HTTPS\r\n\r\n- [图文还原 HTTPS 原理](https://mp.weixin.qq.com/s/3NKOCOeIUF2SGJnY7II9hA)\r\n- [浅谈有赞全站 HTTPS 推进](https://segmentfault.com/a/1190000013635363)\r\n\r\n### 4.5. 安全实录\r\n\r\n- [About `rel=noopener` \\[英\\]](https://mathiasbynens.github.io/rel-noopener/)：打开一个新页面是如何带来安全隐患的\r\n- [一种新型的“钓鱼”方式 \\[英\\]](http://www.azarask.in/blog/post/a-new-type-of-phishing-attack/)\r\n- [一个媒体文件请求引发的跨站风险 \\[英\\]](https://jakearchibald.com/2018/i-discovered-a-browser-bug)\r\n- [Mitigating Spectre \\[英\\]](https://security.googleblog.com/2018/07/mitigating-spectre-with-site-isolation.html)： Chrome 中的跨站安全问题\r\n\r\n## 5. 自动化测试\r\n\r\n> 自动化测试是软件工程的重要部分之一，但却极容易被忽视。\r\n\r\n- [2018 前端自动化测试综述 \\[英\\]](https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2018-f68950900bc3)\r\n- [测试你的前端代码（介绍篇）\\[英\\]](https://hackernoon.com/testing-your-frontend-code-part-i-introduction-7e307eac4446)\r\n\r\n### 5.1. 单元测试\r\n\r\n- [测试你的前端代码（单元测试篇）\\[英\\]](https://hackernoon.com/testing-your-frontend-code-part-ii-unit-testing-1d05f8d50859)\r\n- [Fakes、Mocks 以及 Stubs 概念明晰](https://zhuanlan.zhihu.com/p/26942686)\r\n- [测试覆盖（率）到底有什么用？](http://www.infoq.com/cn/articles/test-coverage-rate-role)\r\n\r\n### 5.2. 端到端测试 (E2E)\r\n\r\n- [测试你的前端代码（E2E 测试篇）\\[英\\]](https://hackernoon.com/testing-your-frontend-code-part-iii-e2e-testing-e9261b56475)\r\n- [什么是一个好的 E2E 测试？\\[英\\]](https://testing.googleblog.com/2016/09/testing-on-toilet-what-makes-good-end.html)\r\n- [平衡单元测试和端到端测试](http://www.infoq.com/cn/articles/balancing-unit-and-end-to-end-tests)\r\n- [对过多的 E2E 测试说“不” \\[英\\]](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)\r\n\r\n### 5.3. 其他\r\n\r\n- [测试你的前端代码（集成测试篇）\\[英\\]](https://hackernoon.com/testing-your-frontend-code-part-iv-integration-testing-f1f4609dc4d9)\r\n- [测试你的前端代码（可视化测试篇）\\[英\\]](https://medium.com/@giltayar/testing-your-frontend-code-part-v-visual-testing-935864cfb5c7)\r\n\r\n## 6. 框架与类库\r\n\r\n> 如果说基础知识是道，那框架与工具可能就是术；学习与理解它们，但千万不要成为它们的奴隶。\r\n\r\n### 6.1. React\r\n\r\n- [React 底层揭秘 \\[英\\]](https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/)\r\n- [你所需要知道的 React 细节](https://github.com/hateonion/react-bits-CN)\r\n- [React Fiber 架构](https://zhuanlan.zhihu.com/p/37095662)\r\n- [React 16 Fiber 源码速览](http://zxc0328.github.io/2017/09/28/react-16-source/)\r\n- [React 是怎样炼成的](https://segmentfault.com/a/1190000013365426)：React早期的进化之路\r\n- 从零开始实现一个React：\r\n    - [1. JSX和虚拟DOM](https://github.com/hujiulong/blog/issues/4)\r\n    - [2. 组件和生命周期](https://github.com/hujiulong/blog/issues/5)\r\n    - [3. diff算法](https://github.com/hujiulong/blog/issues/6)\r\n    - [4. 异步的setState](https://github.com/hujiulong/blog/issues/7)\r\n- [「react技术栈」单页应用实践快速入门](https://www.jianshu.com/p/0b2acb50f321)\r\n\r\n### 6.2. Vue\r\n\r\n- [深入浅出 - vue变化侦测原理](https://github.com/berwin/Blog/issues/17)\r\n- [Vue 模板编译原理](https://github.com/berwin/Blog/issues/18)\r\n\r\n### 6.3. Redux\r\n\r\n- [重新设计 Redux \\[英\\]](https://hackernoon.com/redesigning-redux-b2baee8b8a38)：Rematch\r\n- [如何用 GraphQL 来替代 Redux \\[英\\]](https://hackernoon.com/how-graphql-replaces-redux-3fff8289221d)\r\n- [解读 Redux 的设计思路与用法](https://div.io/topic/1309)\r\n- [(Redux)应用构建的三个原则 \\[英\\]](https://jaysoo.ca/2016/02/28/organizing-redux-application/#rule-1-organize-by-feature)\r\n\r\n### 6.4. RxJS\r\n\r\n- [ReactiveX 官网](http://reactivex.io/)：宝石图真的非常形象易读\r\n- [响应式编程，是明智的选择](https://www.cnblogs.com/android-blogs/p/5586395.html)\r\n- [图解RxJS \\[英\\]](https://blog.angularindepth.com/learn-to-combine-rxjs-sequences-with-super-intuitive-interactive-diagrams-20fce8e6511)\r\n- [调试RxJS：Tooling \\[英\\]](https://blog.angularindepth.com/debugging-rxjs-4f0340286dd3)\r\n- [调试RxJS：Logging \\[英\\]](https://blog.angularindepth.com/debugging-rxjs-part-2-logging-56904459f144)\r\n\r\n\r\n## 7. 新技术/方向\r\n\r\n> 前端领域新技术、新方向层出不穷，这里汇总一些新技术方向；作为开发者需要多了解但是不要盲从\r\n\r\n### 7.1. PWA\r\n\r\n- [PWA 学习与实践系列](https://juejin.im/post/5ac8a67c5188255c5668b0b8#heading-3)\r\n- [Service Worker 入门简介 \\[英\\]](https://medium.freecodecamp.org/service-workers-the-little-heroes-behind-progressive-web-apps-431cc22d0f16)\r\n- [PWA 在 iOS 平台上的特殊问题 \\[英\\]](https://medium.com/@firt/pwas-are-coming-to-ios-11-3-cupertino-we-have-a-problem-2ff49fd7d6ea)\r\n- [在你的 PWA 中小心使用 iOS 的 meta 标签 \\[英\\]](https://medium.com/@firt/dont-use-ios-web-app-meta-tag-irresponsibly-in-your-progressive-web-apps-85d70f4438cb)\r\n- [饿了么的 PWA 升级实践](https://medium.com/elemefe/upgrading-ele-me-to-progressive-web-app-2a446832e509)\r\n- [离线指南](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/)\r\n- [Android 中的 WebAPKs \\[英\\]](https://developers.google.cn/web/fundamentals/integration/webapks?hl=zh-cn)\r\n- [Pinterest 的 PWA 实践 \\[英\\]](https://medium.com/@Pinterest_Engineering/a-one-year-pwa-retrospective-f4a2f4129e05)\r\n- [异步 HTTP Cookies API \\[英\\]](https://developers.google.com/web/updates/2018/09/asynchronous-access-to-http-cookies)：赋能Service Worker\r\n\r\n### 7.2. CSS Houdini\r\n\r\n- [认识 Houdini 与 CSS Paint API \\[英\\]](https://codersblock.com/blog/say-hello-to-houdini-and-the-css-paint-api/)\r\n- [用 Houdini 来拯救 CSS Polyfill \\[英\\]](https://philipwalton.com/articles/the-dark-side-of-polyfilling-css/)\r\n\r\n### 7.3. Web Components\r\n\r\n- [Web Components 基本概念和用法](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)\r\n- [Web Components 指南 \\[英\\]](https://css-tricks.com/modular-future-web-components/)\r\n- [Shadow DOM 使用简介](http://web.jobbole.com/87088/)\r\n- [HTMLUnknownElement 与 HTML5 自定义元素的故事](http://www.zhangxinxu.com/wordpress/2018/03/htmlunknownelement-html5-custom-elements/)\r\n\r\n### 7.4. 微前端（Micro Frontends）\r\n\r\n- [微前端主页 \\[英\\]](https://micro-frontends.org/)\r\n- [微前端的那些事儿](https://microfrontend.cn/)\r\n- [技术雷达之「微前端」- 将微服务理念扩展到前端开发](https://zhuanlan.zhihu.com/p/32378432)\r\n\r\n### 7.5. HTTP/2\r\n\r\n- [HTTP/2 幕后原理](https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html)\r\n- [全面介绍的 HTTP/2 \\[英\\]](https://hpbn.co/http2/)\r\n- [HTTP/2 主页](https://http2.github.io/):\r\n    - [HTTP/2 协议 \\[英\\]](https://httpwg.org/specs/rfc7540.html)\r\n    - [HPACK: HTTP/2 Header压缩 \\[英\\]](https://httpwg.org/specs/rfc7541.html)\r\n\r\n### 7.6. WebAssembly\r\n\r\n- [WebAssembly 官网](https://webassembly.org/)\r\n- [WebAssembly 现状与实战](https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html)\r\n- WebAssembly 系列：\r\n    - [一、生动形象地介绍 WebAssembly](https://segmentfault.com/a/1190000008714589)\r\n    - [二、JavaScript Just-in-time (JIT) 工作原理](https://segmentfault.com/a/1190000008632441)\r\n    - [三、编译器如何生成汇编](https://segmentfault.com/a/1190000008664761)\r\n    - [四、WebAssembly 工作原理](https://segmentfault.com/a/1190000008686643)\r\n    - [五、为什么 WebAssembly 更快？](https://segmentfault.com/a/1190000008699213)\r\n    - [六、WebAssembly 的现在与未来](https://segmentfault.com/a/1190000008714515)\r\n\r\n## 8. 业务相关\r\n\r\n> 在业务中往往还有一些与“业务无关”的场景需求，不论是什么业务几乎都会遇到；因此，在变与不变中，我们更需要去抽象出这些问题。\r\n\r\n### 8.1. 数据打点上报\r\n\r\n- [如何精确统计页面停留时长](https://techblog.toutiao.com/2018/06/05/ru-he-jing-que-tong-ji-ye-mian-ting-liu-shi-chang/)\r\n- [揭开JS无埋点技术的神秘面纱](http://unclechen.github.io/2018/06/24/%E6%8F%AD%E5%BC%80JS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/)\r\n\r\n### 8.2. 前端监控\r\n\r\n- [前端异常监控解决方案研究](https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/)\r\n- [监控平台前端SDK开发实践](https://tech.meituan.com/hunt_sdk_practice.html)\r\n- [把前端监控做到极致](https://zhuanlan.zhihu.com/p/32262716)\r\n- [前端监控系统探索总结](https://juejin.im/post/5a3e121451882533f01ec66d)\r\n\r\n### 8.3. A/B测试\r\n\r\n- Twitter的A/B测试实践：\r\n    - [一、为什么要测试以及测试的意义](http://www.infoq.com/cn/articles/twitter-ab-test-practise-part01)\r\n    - [二、技术概述](http://www.infoq.com/cn/articles/twitter-ab-test-practise-part02)\r\n    - [三、检测和避免 A/B Test中 bucket不平衡问题](http://www.infoq.com/cn/articles/twitter-ab-test-practise-part03)\r\n    - [四、A/B Test中使用多个控制的启示](http://www.infoq.com/cn/articles/twitter-ab-test-practise-part04)\r\n- [Netflix A/B Test 实验平台实践 \\[英\\]](https://medium.com/netflix-techblog/its-all-a-bout-testing-the-netflix-experimentation-platform-4e1ca458c15)\r\n- 指导方法\r\n    - [实验中容易遇到的七种问题 \\[英\\]](https://www.exp-platform.com/Documents/2009-ExPpitfalls.pdf)\r\n    - [实验的七个准则 \\[英\\]](https://www.exp-platform.com/Documents/2014%20experimentersRulesOfThumb.pdf)\r\n    - [小流量如何进行AB测试](https://www.jianshu.com/p/3ab537f16b81)\r\n- 案例分享\r\n    - [大众点评AB测试框架Gemini](https://www.csdn.net/article/2015-03-24/2824303)\r\n    - [新浪新闻客户端AB测试与灰度发布](https://segmentfault.com/a/1190000012377139)\r\n    - [天猫App A/B测试实践](http://www.infoq.com/cn/articles/tmall-app-ab-test)\r\n- 工具\r\n    - [AB测试样本数量计算器](https://www.eyeofcloud.com/124.html)\r\n    - [AB测试结果有效性分析工具](https://www.eyeofcloud.com/126.html)\r\n\r\n### 8.4. “服务端推”\r\n\r\n- [各类“服务器推”技术原理与实例](https://juejin.im/post/5b135b78f265da6e420eab7d)\r\n- [长连接/websocket/SSE等主流服务器推送技术比较](https://zhuanlan.zhihu.com/p/31297574)\r\n- [Comet：基于 HTTP 长连接的“服务器推”技术](https://www.ibm.com/developerworks/cn/web/wa-lo-comet/)\r\n- [深入 WebSockets、HTTP/2 SSE \\[英\\]](https://blog.sessionstack.com/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7)\r\n- [WebSocket 应用安全问题分析](https://security.tencent.com/index.php/blog/msg/119)\r\n\r\n### 8.5. 动效\r\n\r\n- [动画设计的12个原则🎥 \\[英\\]](https://www.youtube.com/watch?v=uDqjIdI4bF4)\r\n- [贝塞尔曲线扫盲](http://www.html-js.com/article/1628)\r\n- [动画：从 AE 到 Web](https://aotu.io/notes/2018/03/06/ae2web/)\r\n- 最全最好用的动效落地方法：\r\n    - [基础知识](https://zhuanlan.zhihu.com/p/34501702)\r\n    - [落地方式](https://zhuanlan.zhihu.com/p/34815524)\r\n\r\n## 9. 不归类的好文\r\n\r\n> 开卷有益。\r\n\r\n- [Recursion? We don't need no stinking recursion!](http://raganwald.com/2018/05/20/we-dont-need-no-stinking-recursion.html)：如何将一些递归改为循环（尾递归优化）\r\n- [Turning your web traffic into a Super Computer](https://ben.akrin.com/?p=5997)：通过 Web Worker 和 WebSocket 来将全世界的电脑连接成超级计算机\r\n- [Designing very large (JavaScript) applications](https://medium.com/@cramforce/designing-very-large-javascript-applications-6e013a3291a3)：高屋建瓴，适合阅读与思考\r\n\r\n> 注：其中部分外文文章可能需要“科学上网”","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/21","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/21/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/21/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/21/events","html_url":"https://github.com/alienzhou/blog/issues/21","id":390659405,"node_id":"MDU6SXNzdWUzOTA2NTk0MDU=","number":21,"title":"【webpack进阶】你真的掌握了loader么？- loader十问","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845019,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE5","url":"https://api.github.com/repos/alienzhou/blog/labels/Webpack","name":"Webpack","color":"e4e669","default":false,"description":""},{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T12:35:34Z","updated_at":"2018-12-13T12:55:06Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 往期文章：\r\n> - [【webpack进阶】前端运行时的模块化设计与实现](https://github.com/alienzhou/blog/issues/19)\r\n> - [【webpack进阶】使用babel避免webpack编译运行时模块依赖](https://github.com/alienzhou/blog/issues/18)\r\n> - [【webpack进阶】可视化展示webpack内部插件与钩子关系📈](https://github.com/alienzhou/blog/issues/20)\r\n\r\n## 1. loader 十问\r\n\r\n在我学习webpack loader的过程中，也阅读了网上很多相关文章，收获不少。但是大多都只介绍了loader的配置方式或者loader的编写方式，对其中参数、api及其他细节的介绍并不清晰。\r\n\r\n这里有一个「loader十问」，是我在阅读loader源码前心中的部分疑问：\r\n\r\n1. webpack默认配置是在哪处理的，loader有什么默认配置么？\r\n2. webpack中有一个resolver的概念，用于解析模块文件的真实绝对路径，那么loader和普通模块的resolver使用的是同一个么？\r\n3. 我们知道，除了config中的loader，还可以写inline的loader，那么inline loader和normal config loader执行的先后顺序是什么？\r\n4. 配置中的`module.rules`在webpack中是如何生效与实现的？\r\n5. webpack编译流程中loader是如何以及在何时发挥作用的？\r\n6. loader为什么是自右向左执行的？\r\n7. 如果在某个pitch中返回值，具体会发生什么？\r\n8. 如果你写过loader，那么可能在loader function中用到了`this`，这里的`this`究竟是什么，是webpack实例么？\r\n9. loader function中的`this.data`是如何实现的？\r\n10. 如何写一个异步loader，webpack又是如何实现loader的异步化的？\r\n\r\n也许你也会有类似的疑问。下面我会结合loader相关的部分源码，为大家还原loader的设计与实现原理，解答这些疑惑。\r\n\r\n## 2. loader运行的总体流程\r\n\r\nwebpack编译流程非常复杂，但其中涉及loader的部分主要包括了：\r\n\r\n- loader（webpack）的默认配置\r\n- 使用loaderResolver解析loader模块路径\r\n- 根据`rule.modules`创建RulesSet规则集\r\n- 使用loader-runner运行loader\r\n\r\n其对应的大致流程如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/10/14/166713f3741bc389?w=365&h=606&f=png&s=44142)\r\n\r\n首先，在`Compiler.js`中会为将用户配置与默认配置合并，其中就包括了loader部分。\r\n\r\n然后，webpack就会根据配置创建两个关键的对象——`NormalModuleFactory`和`ContextModuleFactory`。它们相当于是两个类工厂，通过其可以创建相应的`NormalModule`和`ContextModule`。其中`NormalModule`类是这篇文章主要关注的，webpack会为源码中的模块文件对应生成一个`NormalModule`实例。\r\n\r\n在工厂创建`NormalModule`实例之前还有一些必要步骤，其中与loader最相关的就是通过loader的resolver来解析loader路径。\r\n\r\n在`NormalModule`实例创建之后，则会通过其`.build()`方法来进行模块的构建。构建模块的第一步就是使用loader来加载并处理模块内容。而loader-runner这个库就是webpack中loader的运行器。\r\n\r\n最后，将loader处理完的模块内容输出，进入后续的编译流程。\r\n\r\n上面就是webpack中loader涉及到的大致流程。下面会结合源码对其进行具体的分析，而在源码阅读分析过程中，就会找到「loader十问」的解答。\r\n\r\n## 3. loader运行部分的具体分析\r\n\r\n### 3.1. webpack默认配置\r\n\r\n> Q：1. webpack默认配置是在哪处理的，loader有什么默认配置么？\r\n\r\nwebpack和其他工具一样，都是通过配置的方式来工作的。随着webpack的不断进化，其默认配置也在不断变动；而曾经版本中的某些最佳实践，也随着版本的升级进入了webpack的默认配置。\r\n\r\nwebpack的入口文件是`lib/webpack.js`，会根据配置文件，设置编译时的配置options [(source code)](https://github.com/webpack/webpack/blob/master/lib/webpack.js#L37-L40)（上一篇[《可视化展示webpack内部插件与钩子关系📈》](https://github.com/alienzhou/blog/issues/20)提到的plugin也是在这里触发的）\r\n\r\n```javascript\r\noptions = new WebpackOptionsDefaulter().process(options);\r\ncompiler = new Compiler(options.context);\r\ncompiler.options = options;\r\n```\r\n\r\n由此可见，默认配置是放在`WebpackOptionsDefaulter`里的。因此，如果你想要查看当前webpack默认配置项具体内容，可以在[该模块](https://github.com/webpack/webpack/blob/master/lib/WebpackOptionsDefaulter.js)里查看。\r\n\r\n例如，在`module.rules`这部分的默认值为`[]`；但是此外还有一个`module.defaultRules`配置项，虽然不开放给开发者使用，但是包含了loader的默认配置 [(source code)](https://github.com/webpack/webpack/blob/master/lib/WebpackOptionsDefaulter.js#L61-L87)：\r\n\r\n```javascript\r\nthis.set(\"module.rules\", []);\r\nthis.set(\"module.defaultRules\", \"make\", options => [\r\n    {\r\n        type: \"javascript/auto\",\r\n        resolve: {}\r\n    },\r\n    {\r\n        test: /\\.mjs$/i,\r\n        type: \"javascript/esm\",\r\n        resolve: {\r\n            mainFields:\r\n                options.target === \"web\" ||\r\n                options.target === \"webworker\" ||\r\n                options.target === \"electron-renderer\"\r\n                    ? [\"browser\", \"main\"]\r\n                    : [\"main\"]\r\n        }\r\n    },\r\n    {\r\n        test: /\\.json$/i,\r\n        type: \"json\"\r\n    },\r\n    {\r\n        test: /\\.wasm$/i,\r\n        type: \"webassembly/experimental\"\r\n    }\r\n]);\r\n```\r\n\r\n> 此外值得一提的是，`WebpackOptionsDefaulter`继承自`OptionsDefaulter`，而`OptionsDefaulter`则是一个封装的配置项存取器，封装了一些特殊的方法来操作配置对象。\r\n\r\n### 3.2. 创建`NormalModuleFactory`\r\n\r\n`NormalModule`是webpack中不得不提的一个类函数。源码中的模块在编译过程中会生成对应的`NormalModule`实例。\r\n\r\n`NormalModuleFactory`是`NormalModule`的工厂类。其创建是在`Compiler.js`中进行的，`Compiler.js`是webpack基本编译流程的控制类。`compiler.run()`方法中的主体（钩子）流程如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/10/14/166715d115c84870?w=574&h=1716&f=png&s=153704)\r\n\r\n`.run()`在触发了一系列`beforeRun`、`run`等钩子后，会调用`.compile()`方法，其中的第一步就是调用`this.newCompilationParams()`创建`NormalModuleFactory`实例。\r\n\r\n```javascript\r\nnewCompilationParams() {\r\n    const params = {\r\n        normalModuleFactory: this.createNormalModuleFactory(),\r\n        contextModuleFactory: this.createContextModuleFactory(),\r\n        compilationDependencies: new Set()\r\n    };\r\n    return params;\r\n}\r\n```\r\n\r\n### 3.3. 解析（resolve）loader的真实绝对路径\r\n\r\n> Q：2. webpack中有一个resolver的概念，用于解析模块文件的真实绝对路径，那么loader模块与normal module（源码模块）的resolver使用的是同一个么？\r\n\r\n在`NormalModuleFactory`中，创建出`NormalModule`实例之前会涉及到四个钩子：\r\n\r\n- beforeResolve\r\n- resolve\r\n- factory\r\n- afterResolve\r\n\r\n其中较为重要的有两个：\r\n\r\n- resolve部分负责解析loader模块的路径（例如css-loader这个loader的模块路径是什么）；\r\n- factory负责来基于resolve钩子的返回值来创建`NormalModule`实例。\r\n\r\n`resolve`钩子上注册的方法较长，其中还包括了模块资源本身的路径解析。`resolver`有两种，分别是loaderResolver和normalResolver。\r\n\r\n```javascript\r\nconst loaderResolver = this.getResolver(\"loader\");\r\nconst normalResolver = this.getResolver(\"normal\", data.resolveOptions);\r\n```\r\n\r\n由于除了config文件中可以配置loader外，还有inline loader的写法，因此，对loader文件的路径解析也分为两种：inline loader和config文件中的loader。resolver钩子中会先处理inline loader。\r\n\r\n#### 3.3.1. inline loader \r\n\r\n```\r\nimport Styles from 'style-loader!css-loader?modules!./styles.css';\r\n```\r\n\r\n上面是一个inline loader的例子。其中的request为`style-loader!css-loader?modules!./styles.css`。\r\n\r\n首先webpack会从request中解析出所需的loader [(source code)](https://github.com/webpack/webpack/blob/master/lib/NormalModuleFactory.js#L184-L187):\r\n\r\n```javascript\r\nlet elements = requestWithoutMatchResource\r\n    .replace(/^-?!+/, \"\")\r\n    .replace(/!!+/g, \"!\")\r\n    .split(\"!\");\r\n```\r\n\r\n因此，从`style-loader!css-loader?modules!./styles.css`中可以取出两个loader：`style-loader`和`css-loader`。\r\n\r\n然后会将“解析模块的loader数组”与“解析模块本身”一起并行执行，这里用到了[`neo-async`](https://github.com/suguru03/neo-async)这个库。\r\n\r\n> `neo-async`库和`async`库类似，都是为异步编程提供一些工具方法，但是会比`async`库更快。\r\n\r\n解析返回的结果格式大致如下：\r\n\r\n```javascript\r\n[ \r\n    // 第一个元素是一个loader数组\r\n    [ { \r\n        loader:\r\n            '/workspace/basic-demo/home/node_modules/html-webpack-plugin/lib/loader.js',\r\n        options: undefined\r\n    } ],\r\n    // 第二个元素是模块本身的一些信息\r\n    {\r\n        resourceResolveData: {\r\n            context: [Object],\r\n            path: '/workspace/basic-demo/home/public/index.html',\r\n            request: undefined,\r\n            query: '',\r\n            module: false,\r\n            file: false,\r\n            descriptionFilePath: '/workspace/basic-demo/home/package.json',\r\n            descriptionFileData: [Object],\r\n            descriptionFileRoot: '/workspace/basic-demo/home',\r\n            relativePath: './public/index.html',\r\n            __innerRequest_request: undefined,\r\n            __innerRequest_relativePath: './public/index.html',\r\n            __innerRequest: './public/index.html'\r\n        },\r\n\tresource: '/workspace/basic-demo/home/public/index.html'\r\n    }\r\n]\r\n```\r\n\r\n其中第一个元素就是该模块被引用时所涉及的所有inline loader，包含loader文件的绝对路径和配置项。\r\n\r\n#### 3.3.2. config loader\r\n\r\n> Q：3. 我们知道，除了config中的loader，还可以写inline的loader，那么inline loader和normal config loader执行的先后顺序是什么？\r\n\r\n上面一节中，webpack首先解析了inline loader的绝对路径与配置。接下来则是解析config文件中的loader [(source code)](https://github.com/webpack/webpack/blob/master/lib/NormalModuleFactory.js#L270-L279)，即`module.rules`部分的配置：\r\n\r\n```javascript\r\nconst result = this.ruleSet.exec({\r\n    resource: resourcePath,\r\n    realResource:\r\n        matchResource !== undefined\r\n            ? resource.replace(/\\?.*/, \"\")\r\n            : resourcePath,\r\n    resourceQuery,\r\n    issuer: contextInfo.issuer,\r\n    compiler: contextInfo.compiler\r\n});\r\n```\r\n\r\n`NormalModuleFactory`中有一个`ruleSet`的属性，这里你可以简单理解为：它可以根据模块路径名，匹配出模块所需的loader。`RuleSet`细节此处先按下不表，其具体内容我会在下一节介绍。\r\n\r\n这里向`this.ruleSet.exec()`中传入源码模块路径，返回的`result`就是当前模块匹配出的config中的loader。如果你熟悉webpack配置，会知道`module.rules`中有一个`enforce`字段。基于该字段，webpack会将loader分为preLoader、postLoader和loader三种 [(source code)](https://github.com/webpack/webpack/blob/master/lib/NormalModuleFactory.js#L284-L311)：\r\n\r\n```javascript\r\nfor (const r of result) {\r\n    if (r.type === \"use\") {\r\n        // post类型\r\n        if (r.enforce === \"post\" && !noPrePostAutoLoaders) {\r\n            useLoadersPost.push(r.value);\r\n        // pre类型\r\n        } else if (\r\n            r.enforce === \"pre\" &&\r\n            !noPreAutoLoaders &&\r\n            !noPrePostAutoLoaders\r\n        ) {\r\n            useLoadersPre.push(r.value);\r\n        } else if (\r\n            !r.enforce &&\r\n            !noAutoLoaders &&\r\n            !noPrePostAutoLoaders\r\n        ) {\r\n            useLoaders.push(r.value);\r\n        }\r\n    }\r\n    // ……\r\n}\r\n```\r\n\r\n最后，使用neo-aysnc来并行解析三类loader数组 [(source code)](https://github.com/webpack/webpack/blob/master/lib/NormalModuleFactory.js#L312-L335)：\r\n\r\n```javascript\r\nasyncLib.parallel(\r\n    [\r\n        this.resolveRequestArray.bind(\r\n            this,\r\n            contextInfo,\r\n            this.context,\r\n            useLoadersPost, // postLoader\r\n            loaderResolver\r\n        ),\r\n        this.resolveRequestArray.bind(\r\n            this,\r\n            contextInfo,\r\n            this.context,\r\n            useLoaders, // loader\r\n            loaderResolver\r\n        ),\r\n        this.resolveRequestArray.bind(\r\n            this,\r\n            contextInfo,\r\n            this.context,\r\n            useLoadersPre, // preLoader\r\n            loaderResolver\r\n        )\r\n    ]\r\n    // ……\r\n}\r\n```\r\n\r\n那么最终loader的顺序究竟是什么呢？下面这一行代码可以解释：\r\n\r\n```javascript\r\nloaders = results[0].concat(loaders, results[1], results[2]);\r\n```\r\n\r\n其中`results[0]`、`results[1]`、`results[2]`、`loader`分别是postLoader、loader（normal config loader）、preLoader和inlineLoader。因此合并后的loader顺序是：post、inline、normal和pre。\r\n\r\n然而loader是从右至左执行的，真实的loader执行顺序是倒过来的，因此inlineLoader是整体后于config中normal loader执行的。\r\n\r\n### 3.3.3. RuleSet\r\n\r\n> Q：4. 配置中的`module.rules`在webpack中是如何生效与实现的？\r\n\r\nwebpack使用`RuleSet`对象来匹配模块所需的loader。`RuleSet`相当于一个规则过滤器，会将resourcePath应用于所有的`module.rules`规则，从而筛选出所需的loader。其中最重要的两个方法是：\r\n\r\n- 类静态方法`.normalizeRule()`\r\n- 实例方法`.exec()`\r\n\r\nwebpack编译会根据用户配置与默认配置，实例化一个`RuleSet`。首先，通过其上的静态方法`.normalizeRule()`将配置值转换为标准化的test对象；其上还会存储一个`this.references`属性，是一个map类型的存储，key是loader在配置中的类型和位置，例如，`ref-2`表示loader配置数组中的第三个。\r\n\r\n> p.s. 如果你在.compilation中某个钩子上打印出一些NormalModule上request相关字段，那些用到loader的模块会出现类似`ref-`的值。从这里就可以看出一个模块是否使用了loader，命中了哪个配置规则。\r\n\r\n实例化后的`RuleSet`就可以用于为每个模块获取对应的loader。这个实例化的`RuleSet`就是我们上面提到的`NormalModuleFactory`实例上的`this.ruleSet`属性。工厂每次创建一个新的`NormalModule`时都会调用`RuleSet`实例的`.exec()`方法，只有当通过了各类测试条件，才会将该loader push到结果数组中。\r\n\r\n### 3.4. 运行loader\r\n\r\n#### 3.4.1. loader的运行时机\r\n\r\n> Q：5. webpack编译流程中loader是如何以及在何时发挥作用的？\r\n\r\nloader的绝对路径解析完毕后，在`NormalModuleFactory`的`factory`钩子中会创建当前模块的`NormalModule`对象。到目前为止，loader的前序工作已经差不多结束了，下面就是真正去运行各个loader。\r\n\r\n我们都知道，运行loader读取与处理模块是webpack模块处理的第一步。但如果说到详细的运行时机，就涉及到webpack编译中`compilation`这个非常重要的对象。\r\n\r\nwebpack是以入口维度进行编译的，`compilation`中有一个重要方法——`.addEntry()`，会基于入口进行模块构建。`.addEntry()`方法中调用的`._addModuleChain()`会执行一系列的模块方法 [(source code)](https://github.com/webpack/webpack/blob/master/lib/Compilation.js#L996-L1010)\r\n\r\n```javascript\r\nthis.semaphore.acquire(() => {\r\n    moduleFactory.create(\r\n        {\r\n            // ……\r\n        },\r\n        (err, module) => {\r\n            if (err) {\r\n                this.semaphore.release();\r\n                return errorAndCallback(new EntryModuleNotFoundError(err));\r\n            }\r\n            // ……\r\n            if (addModuleResult.build) {\r\n                // 模块构建\r\n                this.buildModule(module, false, null, null, err => {\r\n                    if (err) {\r\n                        this.semaphore.release();\r\n                        return errorAndCallback(err);\r\n                    }\r\n\r\n                    if (currentProfile) {\r\n                        const afterBuilding = Date.now();\r\n                        currentProfile.building = afterBuilding - afterFactory;\r\n                    }\r\n\r\n                    this.semaphore.release();\r\n                    afterBuild();\r\n                });\r\n            }\r\n        }\r\n    )\r\n}\r\n```\r\n\r\n其中，对于未build过的模块，最终会调用到`NormalModule`对象的[`.doBuild()`方法](https://github.com/webpack/webpack/blob/master/lib/NormalModule.js#L257)。而构建模块(`.doBuild()`)的第一步就是[运行所有的loader](https://github.com/webpack/webpack/blob/master/lib/NormalModule.js#L265)。\r\n\r\n这时候，loader-runner就登场了。\r\n\r\n#### 3.4.2. loader-runner —— loader的执行库\r\n\r\n> Q：6. loader为什么是自右向左执行的？\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/10/14/166726229bc58100?w=2010&h=198&f=png&s=50665)\r\n\r\nwebpack将loader的运行工具剥离出来，独立成了[loader-runner库](https://github.com/webpack/loader-runner)。因此，你可以编写一个loader，并用独立的loader-runner来测试loader的效果。\r\n\r\nloader-runner分为了两个部分：loadLoader.js与LoaderRunner.js。\r\n\r\nloadLoader.js是一个兼容性的模块加载器，可以加载例如cjs、esm或SystemJS这种的模块定义。而LoaderRunner.js则是loader模块运行的核心部分。其中暴露出来的`.runLoaders()`方法则是loader运行的启动方法。\r\n\r\n如果你写过或了解如何编写一个loader，那么肯定知道，每个loader模块都支持一个`.pitch`属性，上面的方法会优先于loader的实际方法执行。实际上，webpack官方也给出了pitch与loader本身方法的执行顺序图：\r\n\r\n```\r\n|- a-loader `pitch`\r\n  |- b-loader `pitch`\r\n    |- c-loader `pitch`\r\n      |- requested module is picked up as a dependency\r\n    |- c-loader normal execution\r\n  |- b-loader normal execution\r\n|- a-loader normal execution\r\n```\r\n\r\n这两个阶段（pitch和normal）就是loader-runner中对应的`iteratePitchingLoaders()`和`iterateNormalLoaders()`两个方法。\r\n\r\n`iteratePitchingLoaders()`会递归执行，并记录loader的`pitch`状态与当前执行到的`loaderIndex`（`loaderIndex++`）。当达到最大的loader序号时，才会处理实际的module：\r\n\r\n```javascript\r\nif(loaderContext.loaderIndex >= loaderContext.loaders.length)\r\n    return processResource(options, loaderContext, callback);\r\n```\r\n\r\n当`loaderContext.loaderIndex`值达到整体loader数组长度时，表明所有pitch都被执行完毕（执行到了最后的loader），这时会调用`processResource()`来处理模块资源。主要包括：添加该模块为依赖和读取模块内容。然后会递归执行`iterateNormalLoaders()`并进行`loaderIndex--`操作，因此loader会“反向”执行。\r\n\r\n接下来，我们讨论几个loader-runner的细节点：\r\n\r\n> Q：7. 如果在某个pitch中返回值，具体会发生什么？\r\n\r\n官网上说：\r\n\r\n> if a loader delivers a result in the pitch method the process turns around and skips the remaining loaders\r\n\r\n这段说明表示，在pitch中返回值会跳过余下的loader。这个表述比较粗略，其中有几个细节点需要说明：\r\n\r\n首先，只有当`loaderIndex`达到最大数组长度，即pitch过所有loader后，才会执行`processResource()`。\r\n\r\n```javascript\r\nif(loaderContext.loaderIndex >= loaderContext.loaders.length)\r\n    return processResource(options, loaderContext, callback);\r\n```\r\n\r\n因此，在pitch中返回值除了跳过余下loader外，不仅会使`.addDependency()`不触发（不将该模块资源添加进依赖），而且无法读取模块的文件内容。loader会将pitch返回的值作为“文件内容”来处理，并返回给webpack。\r\n\r\n---\r\n\r\n> Q：8. 如果你写过loader，那么可能在loader function中用到了`this`，这里的`this`究竟是什么，是webpack实例么？\r\n\r\n其实这里的`this`既不是webpack实例，也不是compiler、compilation、normalModule等这些实例。而是一个[叫`loaderContext`的loader-runner特有对象](https://github.com/webpack/loader-runner/blob/master/lib/LoaderRunner.js#L263-L291)。\r\n\r\n每次调用`runLoaders()`方法时，如果不显式传入context，则会默认创建一个新的`loaderContext`。所以在官网上提到的各种loader API（callback、data、loaderIndex、addContextDependency等）都是该对象上的属性。\r\n\r\n---\r\n\r\n> Q：9. loader function中的`this.data`是如何实现的？\r\n\r\n知道了loader中的`this`其实是一个叫`loaderContext`的对象，那么`this.data`的实现其实就是`loaderContext.data`的实现 [(source code)](https://github.com/webpack/loader-runner/blob/master/lib/LoaderRunner.js#L346-L351)：\r\n\r\n```javascript\r\nObject.defineProperty(loaderContext, \"data\", {\r\n    enumerable: true,\r\n    get: function() {\r\n        return loaderContext.loaders[loaderContext.loaderIndex].data;\r\n    }\r\n});\r\n```\r\n\r\n这里定义了一个`.data`的（存）取器。可以看出，调用`this.data`时，不同的normal loader由于`loaderIndex`不同，会得到不同的值；而pitch方法的形参`data`也是不同的loader下的data [(source code)](https://github.com/webpack/loader-runner/blob/master/lib/LoaderRunner.js#L177)。\r\n\r\n```javascript\r\nrunSyncOrAsync(\r\n    fn,\r\n    loaderContext,\r\n    [loaderContext.remainingRequest, loaderContext.previousRequest, currentLoaderObject.data = {}],\r\n    function(err) {\r\n        // ……\r\n    }\r\n);\r\n```\r\n\r\n`runSyncOrAsync()`中的数组`[loaderContext.remainingRequest, loaderContext.previousRequest, currentLoaderObject.data = {}]`就是pitch方法的入参，而`currentLoaderObject`就是当前`loaderIndex`所指的loader对象。\r\n\r\n因此，如果你想要保存一个“贯穿始终”的数据，可以考虑保存在`this`的其他属性上，或者通过修改loaderIndex，来取到其他loader上的数据（比较hack）。\r\n\r\n--- \r\n\r\n> Q：10. 如何写一个异步loader，webpack又是如何实现loader的异步化的？\r\n\r\npitch与normal loader的实际执行，都是在[`runSyncOrAsync()`](https://github.com/webpack/loader-runner/blob/master/lib/LoaderRunner.js#L90)这个方法中。\r\n\r\n根据webpack文档，当我们调用`this.async()`时，会将loader变为一个异步的loader，并返回一个异步回调。\r\n\r\n在具体实现上，`runSyncOrAsync()`内部有一个`isSync`变量，默认为`true`；当我们调用`this.async()`时，它会被置为`false`，并返回一个`innerCallback`作为异步执行完后的回调通知：\r\n\r\n```javascript\r\ncontext.async = function async() {\r\n    if(isDone) {\r\n        if(reportedError) return; // ignore\r\n        throw new Error(\"async(): The callback was already called.\");\r\n    }\r\n    isSync = false;\r\n    return innerCallback;\r\n};\r\n```\r\n\r\n我们一般都使用`this.async()`返回的callback来通知异步完成，但实际上，执行`this.callback()`也是一样的效果：\r\n\r\n```javascript\r\nvar innerCallback = context.callback = function() {\r\n    // ……\r\n}\r\n```\r\n\r\n同时，在`runSyncOrAsync()`中，只有`isSync`标识为`true`时，才会在loader function执行完毕后立即（同步）回调callback来继续loader-runner。\r\n\r\n```javascript\r\nif(isSync) {\r\n    isDone = true;\r\n    if(result === undefined)\r\n        return callback();\r\n    if(result && typeof result === \"object\" && typeof result.then === \"function\") {\r\n        return result.catch(callback).then(function(r) {\r\n            callback(null, r);\r\n        });\r\n    }\r\n    return callback(null, result);\r\n}\r\n```\r\n\r\n看到这里你会发现，代码里有一处会判断返回值是否是Promise（`typeof result.then === \"function\"`），如果是Promise则会异步调用callback。因此，想要获得一个异步的loader，除了webpack文档里提到的`this.async()`方法，还可以直接返回一个Promise。\r\n\r\n## 4. 尾声\r\n\r\n以上就是webapck loader相关部分的源码分析。相信到这里，你已经对最开始的「loader十问」有了答案。希望这篇文章能够让你在学会配置loader与编写一个简单的loader之外，能进一步了解loader的实现。\r\n\r\n阅读源码的过程中可能存在一些纰漏，欢迎大家来一起交流。\r\n\r\n## 告别「webpack配置工程师」\r\n\r\nwebpack是一个强大而复杂的前端自动化工具。其中一个特点就是配置复杂，这也使得「webpack配置工程师」这种戏谑的称呼开始流行🤷但是，难道你真的只满足于玩转webpack配置么？\r\n\r\n显然不是。在学习如何使用webpack之外，我们更需要深入webpack内部，探索各部分的设计与实现。万变不离其宗，即使有一天webpack“过气”了，但它的某些设计与实现却仍会有学习价值与借鉴意义。因此，在学习webpack过程中，我会总结一系列【webpack进阶】的文章和大家分享。\r\n\r\n欢迎感兴趣的同学多多交流与关注！\r\n\r\n> 往期文章：\r\n> - [【webpack进阶】前端运行时的模块化设计与实现](https://github.com/alienzhou/blog/issues/19)\r\n> - [【webpack进阶】使用babel避免webpack编译运行时模块依赖](https://github.com/alienzhou/blog/issues/18)\r\n> - [【webpack进阶】可视化展示webpack内部插件与钩子关系📈](https://github.com/alienzhou/blog/issues/20)\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/20","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/20/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/20/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/20/events","html_url":"https://github.com/alienzhou/blog/issues/20","id":390658747,"node_id":"MDU6SXNzdWUzOTA2NTg3NDc=","number":20,"title":"【webpack进阶】可视化展示webpack内部插件与钩子关系📈","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845019,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE5","url":"https://api.github.com/repos/alienzhou/blog/labels/Webpack","name":"Webpack","color":"e4e669","default":false,"description":""},{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2018-12-13T12:33:41Z","updated_at":"2019-06-15T02:27:31Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 往期文章：\r\n> - [【webpack进阶】前端运行时的模块化设计与实现](https://github.com/alienzhou/blog/issues/19)\r\n> - [【webpack进阶】使用babel避免webpack编译运行时模块依赖](https://github.com/alienzhou/blog/issues/18)\r\n\r\n## 引言\r\n\r\nwebpack的成功之处，不仅在于强大的打包构建能力，也在于它灵活的插件机制。\r\n\r\n也许你了解过webpack的插件与钩子机制；但你或许不知道，webpack内部拥有超过180个钩子，这些钩子与模块（内置插件）之间的「创建」「注册」「调用」关系非常复杂。因此，掌握webpack内部插件与钩子间的关系会帮助我们更进一步理解webpack的内部执行方式。\r\n\r\n「webpack模块/内置插件与钩子关系图📈」：复杂性也可窥见一斑。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/9/29/16625513129661c2?w=2874&h=1636&f=png&s=2002331)\r\n\r\n---\r\n\r\n本文的第一部分会先介绍钩子（hook）这个重要的概念与webpack插件的工作方式。然而，熟悉的朋友会发现，这种灵活的机制使得webpack模块之间的联系更加松散与非耦合的同时，让想要理清webpack内部源码结构与联系变得更困难。\r\n\r\n所以，第二部分将会介绍webpack内部插件与钩子关系的可视化展示工具📈，用一张图理清webpack内部这种错综复杂的关系。\r\n\r\n**可视化工具使用效果图：**\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/9/29/16625b730faf4a62?w=800&h=511&f=gif&s=3405680)\r\n\r\n## 1. webpack的插件机制\r\n\r\n在具体介绍webpack内置插件与钩子可视化工具之前，我们先来了解一下webpack中的插件机制。\r\n\r\nwebpack实现插件机制的大体方式是：\r\n\r\n- 「创建」—— webpack在其内部对象上创建各种钩子；\r\n- 「注册」—— 插件将自己的方法注册到对应钩子上，交给webpack；\r\n- 「调用」—— webpack编译过程中，会适时地触发相应钩子，因此也就触发了插件的方法。\r\n\r\n\r\n## 1.1. Tapable\r\n\r\n[Tapable](https://github.com/webpack/tapable)就是webpack用来创建钩子的库。\r\n\r\n> The tapable packages exposes many Hook classes, which can be used to create hooks for plugins.\r\n\r\n通过Tapable，可以快速创建各类钩子。以下是各种钩子的类函数：\r\n\r\n```javascript\r\nconst {\r\n\tSyncHook,\r\n\tSyncBailHook,\r\n\tSyncWaterfallHook,\r\n\tSyncLoopHook,\r\n\tAsyncParallelHook,\r\n\tAsyncParallelBailHook,\r\n\tAsyncSeriesHook,\r\n\tAsyncSeriesBailHook,\r\n\tAsyncSeriesWaterfallHook\r\n} = require(\"tapable\");\r\n```\r\n\r\n以最简单的`SyncHook`为例，它可以帮助我们创建一个同步的钩子。为了帮助理解Tapable创建钩子的使用方式，我们以一个“下班回家进门”的模拟场景来介绍Tapable是如何使用的。\r\n\r\n现在我们有一个`welcome.js`模块，它设定了我们“进门回家”的一系列行为（开门、脱鞋…）：\r\n\r\n```javascript\r\n// welcome.js\r\nconst {SyncHook} = require('tapable');\r\n\r\nmodule.exports = class Welcome {\r\n    constructor(words) {\r\n        this.words = words;\r\n        this.sayHook = new SyncHook(['words']);\r\n    }\r\n\r\n    // 进门回家的一系列行为\r\n    begin() {\r\n        console.log('开门');\r\n        console.log('脱鞋');\r\n        console.log('脱外套');\r\n        // 打招呼\r\n        this.sayHook.call(this.words);\r\n        console.log('关门');\r\n    }\r\n}\r\n```\r\n\r\n首先，我们在构造函数里创建了一个同步钩子`sayHook`，它用来进行之后的打招呼。\r\n\r\n然后，`begin()`方法描述了我们刚回家进门的一系列动作：开门、脱鞋、脱外套、关门。其中，在「脱外套」与「关门」之间是一个打招呼的行为，我们在此触发了`sayHook`钩子，并将words作为参数传入其中。\r\n\r\n> 注意，这里的`.call()`的方法是Tapable提供的触发钩子的方法，不是js中原生的call方法。\r\n\r\n触发这一系列流程也非常简单：\r\n\r\n```JavaScript\r\n// run.js\r\nconst Welcome = require('./welcome');\r\nconst welcome = new Welcome('我回来啦！');\r\nwelcome.begin();\r\n\r\n/* output:\r\n * 开门\r\n * 脱鞋\r\n * 脱外套\r\n * 关门\r\n * /\r\n```\r\n\r\n接下来，我们希望有不同的打招呼方式 —— “普通地打招呼”和“大喊一声”。\r\n\r\n对应的我们会有两个模块`say.js`和`shout.js`，通过`.tap()`方法在`sayHook`钩子上注册相应方法。\r\n\r\n```JavaScript\r\n// say.js\r\nmodule.exports = function (welcome) {\r\n    welcome.sayHook.tap('say', words => {\r\n        console.log('轻声说:', words);\r\n    });\r\n};\r\n\r\n// shout.js\r\nmodule.exports = function (welcome) {\r\n    welcome.sayHook.tap('shout', words => {\r\n        console.log('出其不意的大喊一声:', words);\r\n    });\r\n};\r\n```\r\n\r\n最后，我们修改一下`run.js`，给`welcome`应用`shout.js`这个模块。\r\n\r\n```JavaScript\r\n// run.js\r\nconst Welcome = require('./welcome');\r\nconst applyShoutPlugin = require('./shout');\r\nconst welcome = new Welcome('我回来啦！');\r\napplyShoutPlugin(welcome);\r\nwelcome.begin();\r\n\r\n/* output:\r\n * 开门\r\n * 脱鞋\r\n * 脱外套\r\n * 出其不意的大喊一声: 我回来啦！\r\n * 关门\r\n * /\r\n```\r\n\r\n这样，我们就把打招呼的实现方式与welcome解耦了。我们也可以使用`say.js`模块，甚至和`shout.js`两者同时使用。这就好比创建了一个“可插拔”的系统机制 —— 我可以根据需求自主选择要不要打招呼，要用什么方式打招呼。\r\n\r\n虽然上面的例子非常简单，但是已经可以帮助我们理解tapable的使用以及插件的思想。\r\n\r\n## 1.2. webpack中的插件\r\n\r\n在介绍webpack的插件机制前，先简单回顾下上面“进门回家”例子：\r\n\r\n- 我们的`Welcome`类是主要的功能类，其中包含具体的功能函数`begin()`与钩子`sayHook`；\r\n- `run.js`模块负责执行流程，控制代码流；\r\n- 最后，`say.js`和`shout.js`是独立的“可插入”模块。根据需要，我们可以自主附加到主流程中。\r\n\r\n理解了上面这个例子，就可以很好地类比到webpack中：\r\n\r\n例如，webpack中有一个重要的类 —— `Compiler`，它创建了非常多的钩子，这些钩子将会散落在“各地”被调用（call）。它就类似于我们的`Welcome`类。\r\n\r\n```JavaScript\r\n// Compiler类中的部分钩子\r\n\r\nthis.hooks = {\r\n    /** @type {SyncBailHook<Compilation>} */\r\n    shouldEmit: new SyncBailHook([\"compilation\"]),\r\n    /** @type {AsyncSeriesHook<Stats>} */\r\n    done: new AsyncSeriesHook([\"stats\"]),\r\n    /** @type {AsyncSeriesHook<>} */\r\n    additionalPass: new AsyncSeriesHook([]),\r\n    /** @type {AsyncSeriesHook<Compiler>} */\r\n    beforeRun: new AsyncSeriesHook([\"compiler\"]),\r\n    /** @type {AsyncSeriesHook<Compiler>} */\r\n    run: new AsyncSeriesHook([\"compiler\"]),\r\n    /** @type {AsyncSeriesHook<Compilation>} */\r\n    emit: new AsyncSeriesHook([\"compilation\"]),\r\n    ……\r\n}\r\n```\r\n\r\n然后，webpack中的插件会将所需执行的函数通过 `.tap()` / `.tapAsync()` / `.tapPromise()` 等方法注册到对应钩子上。这样，webpack调用相应钩子时，插件中的函数就会自动执行。\r\n\r\n那么，还有一个问题：webpack是如何调用插件，将插件中的方法在编译阶段注册到钩子上的呢？\r\n\r\n对于这个问题，webpack规定每个插件的实例，必须有一个`.apply()`方法，webpack打包前会调用所有插件的`.apply()`方法，插件可以在该方法中进行钩子的注册。\r\n\r\n在webpack的[`lib/webpack.js`](https://github.com/webpack/webpack/blob/master/lib/webpack.js#L42-L50)中，有如下代码：\r\n\r\n```JavaScript\r\nif (options.plugins && Array.isArray(options.plugins)) {\r\n    for (const plugin of options.plugins) {\r\n        plugin.apply(compiler);\r\n    }\r\n}\r\n```\r\n\r\n上面这段代码会从webpack配置的`plugins`字段中取出所有插件的实例，然后调用其`.apply()`方法，并将`Compiler`的实例作为参数传入。这就是为什么webpack要求我们所有插件都需要提供`.apply()`方法，并在其中进行钩子的注册。\r\n\r\n> 注意，和`.call()`一样，这里的`.apply()`也不是js的原生方法。你会在源码中看到许多`.call()`与`.apply()`，但它们基本都不是你认识的那个方法。\r\n\r\n## 2. 编译期（Compiler中）钩子的触发流程\r\n\r\n目前，网上已经有了一些解析webpack的优质文章。其中也不乏对webpack编译流程整理与介绍的文章。\r\n\r\n但是，由于我近期的工作与兴趣原因，需要对webpack内部的执行步骤与细节做一些较为深入的调研，包括各种钩子与方法的注册、触发时机、条件等等。目前的一些文章内容可能不足以支持，据此做了一定的整理工作。\r\n\r\n### 2.1. 一张待完善的图\r\n\r\n下面是我之前梳理的`Compiler`中`.run()`方法（编译的启动方法）的执行流程及钩子触发情况（图中只涉及了一部分compilation的相关钩子，完整版还需进一步整理）：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/9/29/166255f64585604f?w=7913&h=9314&f=png&s=2967412)\r\n\r\n但是梳理过程中其实出现了一些困难。如果你也曾经想要仔细阅读webpack源码并梳理内部各个模块与插件执行流程与关系，可能也会碰到和我一样的麻烦。下面就来说一下：\r\n\r\n### 2.2. 插件与钩子机制带来的问题\r\n\r\n首先，可以看到由于图比较细，所以它会比网上常见的整体流程图要复杂；但是，即使只算上webpack常用插件、`compiler`钩子与`compilation`钩子，这张图也只算是其中一小部分。更不用说另外上百个你可能从未接触过的钩子。这些模块与钩子交织出了一个复杂的webpack系统。\r\n\r\n其次，在源码阅读与整理的过程中，还会遇到几个问题：\r\n\r\n- **联系松散**。根据以上的例子，你可以发现：使用tapable钩子类似事件监听模式，虽然能有效解耦，但钩子的注册与调用几乎完全无关，很难将一个钩子的“创建 - 注册 - 调用”过程有效联系起来。\r\n\r\n- **模块交互基于钩子**。webpack内部模块与插件在很多时候，是通过钩子机制来进行联系与调用的。但是，基于钩子的模式是松散的。例如你看到源码里一个模块提供了几个钩子，但你并不知道，在何时、何地该钩子会被调用，又在何时、何地钩子上被注册了哪些方法。这些以往都是需要我们通过在代码库中搜索关键词来解决。\r\n\r\n- **钩子数量众多**。webpack内部的钩子非常多，数量达到了180+，类型也五花八门。除了官网列出的`compiler`与`compilation`中那些常用的钩子，还存在着众多其他可以使用的钩子。有些有用的钩子你可能无从知晓，例如我最近用到的`localVars`、`requireExtensions`等钩子。\r\n\r\n- **内置插件众多**。webpack v4+ 本身内置了许多插件。即使非插件，webpack的模块自身也经常使用tapable钩子来交互。甚至可以认为，webpack项目中的各个模块都是“插件化”的。这也使得几乎每个模块都会和各种钩子“打交道”。\r\n\r\n\r\n这些问题导致了想要全面了解webpack中模块/插件间作用关系（核心是与钩子的关系）具有一定的困难。为了帮助理解与阅读webpack源码、理清关系，我制作了一个小工具来可视化展示内置插件与钩子之间的关系，并支持通过交互操作进一步获取源码信息。\r\n\r\n## 3. Webpack Internal Plugin Relation\r\n\r\n[Webpack-Internal-Plugin-Relation](https://github.com/alienzhou/webpack-internal-plugin-relation)是一个可以展现webpack内部模块（插件）与钩子间关系的工具。文章开头展示的动图就是其功能与使用效果。\r\n\r\n> github仓库地址：[https://github.com/alienzhou/webpack-internal-plugin-relation](https://github.com/alienzhou/webpack-internal-plugin-relation)\r\n> 可以在这里查看 [在线演示](https://alienzhou.github.io/webpack-internal-plugin-relation/) \r\n\r\n### 3.1. 关系类型\r\n\r\n模块/插件与钩子的关系主要分为三类：\r\n\r\n- 模块/插件「创建」钩子，如`this.hooks.say = new SyncHook()`；\r\n- 模块/插件将方法「注册」到钩子上，如`obj.hooks.say.tap('one', () => {...})`;\r\n- 模块/插件通过「调用」来触发钩子事件，如`obj.hooks.say.call()`。\r\n\r\n### 3.2. 效果演示\r\n\r\n可以进行模块/插件与钩子之间的关系展示：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/9/29/16625b6e741edc52?w=800&h=511&f=gif&s=2956252)\r\n\r\n可以通过点击等交互，展示模块内钩子信息，双击直接跳转至webpack相应源码处：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/9/29/16625b730faf4a62?w=800&h=511&f=gif&s=3405680)\r\n\r\n由于关系非常复杂（600+关系），可以对关系类型进行筛选，只展示关心的内容：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/9/30/16628a3932c5b50b?w=800&h=511&f=gif&s=3368092)\r\n\r\n### 3.3. 工具包含的功能\r\n\r\n具体来说，这个工具包含的功能主要包括：\r\n\r\n- **关系收集**：\r\n    - 收集模块中hook的创建信息，即钩子的创建信息；\r\n    - 收集模块中hook的注册信息，记录哪些模块对哪些钩子进行了注册；\r\n    - 收集模块中hook的调用信息，即钩子是在代码中的哪一行触发的；\r\n    - 生成包含「模块信息」、「钩子信息」、「源码位置信息」等原始数据的文件。\r\n\r\n- **可视化展示**：\r\n    - 使用力导向图可视化展示插件、钩子间关系。可以看到目前webpack v4中有超过180个钩子与超过130个模块；\r\n    - 展示所有模块与钩子列表。\r\n\r\n- **交互信息**：\r\n    - 支持对力导向图中节点的展现进行筛选；\r\n    - 通过单击javascript module类节点，可在左下角查看模块的详细信息；\r\n    - 双击javascript module类节点，可直接打开webpack对应源码查看；\r\n    - 双击节点间关系，可直接打开并定位源码具体行数，进行查看；\r\n    - 可以选择要查看的关系：创建-contain / 注册-register / 调用-call。\r\n\r\n### 3.4. 基于原始数据定制自己的功能\r\n\r\n目前，工具会将原始的采集结果都保留下来。因此，如果你并不需要可视化展示，或者有自己的定制化需求，那么完全可以基于这些信息进行处理，用于你所需的地方。模块的原始信息结构如下：\r\n\r\n```javascript\r\n\"lib/MultiCompiler.js\": {\r\n  \"hooks\": [\r\n    {\r\n      \"name\": \"done\",\r\n      \"line\": 17\r\n    },\r\n    {\r\n      \"name\": \"invalid\",\r\n      \"line\": 18\r\n    },\r\n    {\r\n      \"name\": \"run\",\r\n      \"line\": 19\r\n    },\r\n    {\r\n      \"name\": \"watchClose\",\r\n      \"line\": 20\r\n    },\r\n    {\r\n      \"name\": \"watchRun\",\r\n      \"line\": 21\r\n    }\r\n  ],\r\n  \"taps\": [\r\n    {\r\n      \"hook\": \"done\",\r\n      \"type\": \"tap\",\r\n      \"plugin\": \"MultiCompiler\",\r\n      \"line\": 37\r\n    },\r\n    {\r\n      \"hook\": \"invalid\",\r\n      \"type\": \"tap\",\r\n      \"plugin\": \"MultiCompiler\",\r\n      \"line\": 48\r\n    }\r\n  ],\r\n  \"calls\": [\r\n    {\r\n      \"hook\": \"done\",\r\n      \"type\": \"call\",\r\n      \"line\": 44\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n## 4. 尾声\r\n\r\n这个[Webpack-Internal-Plugin-Relation](https://github.com/alienzhou/webpack-internal-plugin-relation)的小工具主要通过：\r\n\r\n1. 遍历webpack源码模块文件\r\n2. 语法分析获取钩子相关信息\r\n3. 加工原始采集信息，转换为力导向图所需格式\r\n4. 基于力导向图数据构建前端web可视化服务\r\n5. 最后再辅以一些交互功能\r\n\r\n目前我在使用它帮助阅读与整理webapck源码与编译流程。也许有些朋友也碰到了类似问题，分享出来希望它也能在某些方面对你有所帮助。如果你也对webpack或者这个工具感兴趣，希望能多多支持我的文章和工具，一同交流学习～😊\r\n\r\n\r\n## 告别「webpack配置工程师」\r\n\r\n> 写在最后。\r\n\r\nwebpack是一个强大而复杂的前端自动化工具。其中一个特点就是配置复杂，这也使得「webpack配置工程师」这种戏谑的称呼开始流行🤷但是，难道你真的只满足于玩转webpack配置么？\r\n\r\n显然不是。在学习如何使用webpack之外，我们更需要深入webpack内部，探索各部分的设计与实现。万变不离其宗，即使有一天webpack“过气”了，但它的某些设计与实现却仍会有学习价值与借鉴意义。因此，在学习webpack过程中，我会总结一系列【webpack进阶】的文章和大家分享。\r\n\r\n欢迎感兴趣的同学多多交流与关注！\r\n\r\n> 往期文章：\r\n> - [【webpack进阶】前端运行时的模块化设计与实现](https://github.com/alienzhou/blog/issues/19)\r\n> - [【webpack进阶】使用babel避免webpack编译运行时模块依赖](https://github.com/alienzhou/blog/issues/18)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/19","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/19/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/19/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/19/events","html_url":"https://github.com/alienzhou/blog/issues/19","id":390658016,"node_id":"MDU6SXNzdWUzOTA2NTgwMTY=","number":19,"title":"【webpack进阶】前端运行时的模块化设计与实现","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845019,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE5","url":"https://api.github.com/repos/alienzhou/blog/labels/Webpack","name":"Webpack","color":"e4e669","default":false,"description":""},{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T12:31:36Z","updated_at":"2018-12-13T12:55:34Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 你真的了解前端模块化么？\r\n\r\n## 告别「webpack配置工程师」\r\nwebpack是一个强大而复杂的前端自动化工具。其中一个特点就是配置复杂，这也使得「webpack配置工程师」这种戏谑的称呼开始流行🤷但是，难道你真的只满足于玩转webpack配置么？\r\n\r\n显然不是。在学习如何使用webpack之外，我们更需要深入webpack内部，探索各部分的设计与实现。万变不离其宗，即使有一天webpack“过气”了，但它的某些设计与实现却仍会有学习价值与借鉴意义。因此，在学习webpack过程中，我会总结一系列【webpack进阶】的文章和大家分享。\r\n\r\n欢迎感兴趣的同学多多交流与关注！\r\n\r\n## 1. 引言\r\n\r\n下面进入正题。一直以来，在前端领域，开发人员日益增长的语言能力需求和落后的JavaScript规范形成了一大矛盾。例如，我们会用babel来进行ES6到ES5的语法转换，会使用各种polyfill来兼容老式上的新特性……而我们本文的主角 —— 模块化也是如此。\r\n\r\n由于JavaScript在设计之初就没有考虑这一点，加之模块化规范的迟到，导致社区中涌现出一系列前端运行时的模块化方案，例如RequireJS、seaJS等。以及与之对应的编译期模块依赖解决方案，例如browserify、rollup和本文的主角webpack。\r\n\r\n但是我们要知道，`<script type=\"module\">`还存在一定的兼容性与使用问题。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/8/27/1657be864c854472?w=2348&h=1252&f=png&s=273693)\r\n\r\n在更通用的范围内来讲，浏览器原生实际是不支持所谓的CommonJS或ESM模块化规范的。那么webpack是如何在打包出的代码中实现模块化的呢？\r\n\r\n\r\n## 2. NodeJS中的模块化\r\n\r\n在探究webpack打包后代码的模块化实现前，我们先来看一下Node中的模块化。\r\n\r\nNodeJS（以下简称为Node）在模块化上基本是遵循的CommonJS规范，而webpack打包出来的代码所实现模块化的方式，也类似于CommonJS。因此，我们先以熟悉的Node（这里主要参考Node v10）作为引子，简单介绍它的模块化实现，帮助我们接下来理解webpack的实现。\r\n\r\nNode中的模块引入会经历下面几个步骤：\r\n\r\n1. 路径分析\r\n2. 文件定位\r\n3. 编译执行\r\n\r\n在Node中，模块以文件维度存在，并且在编译后缓存于内存中，通过`require.cache`可以查看模块缓存情况。在模块中添加`console.log(require.cache)`查看输出如下：\r\n\r\n```JavaScript\r\n{ '/Users/alienzhou/programming/gitrepo/test.js':\r\n   Module {\r\n     id: '.',\r\n     exports: {},\r\n     parent: null,\r\n     filename: '/Users/alienzhou/programming/gitrepo/test.js',\r\n     loaded: false,\r\n     children: [],\r\n     paths:\r\n      [ '/Users/alienzhou/programming/gitrepo/node_modules',\r\n        '/Users/alienzhou/programming/node_modules',\r\n        '/Users/alienzhou/node_modules',\r\n        '/Users/node_modules',\r\n        '/node_modules' ] } }\r\n```\r\n\r\n上面就是模块对象的数据结构，也可以在[Node源码](https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L102-L110)中找到Module类的构造方法。其中`exports`属性非常重要，它就是模块的导出对象。因此，下面这行语句\r\n\r\n```JavaScript\r\nvar test = require('./test.js');\r\n```\r\n\r\n其实就是把`test.js`模块的`exports`属性赋值给`test`变量。\r\n\r\n也许你还会好奇，当我们写一个Node(JavaScript)模块时，模块里的`module`、`require`、`__filename`等这些变量是哪来的？如果你看过[Node loader.js 部分源码](https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L124-L131)，应该就大致能理解：\r\n\r\n```JavaScript\r\nModule.wrap = function(script) {\r\n  return Module.wrapper[0] + script + Module.wrapper[1];\r\n};\r\n\r\nModule.wrapper = [\r\n  '(function (exports, require, module, __filename, __dirname) { ',\r\n  '\\n});'\r\n];\r\n```\r\n\r\nNode会自动将每个模块进行包装（wrap），将其变为一个function。例如模块test.js原本为：\r\n\r\n```JavaScript\r\nconsole.log(require.cache);\r\nmodule.exports = 'test';\r\n```\r\n\r\n包装后大致会变为：\r\n\r\n```JavaScript\r\n(function (exports, require, module, __filename, __dirname) {\r\n    console.log(require.cache);\r\n    module.exports = 'test';\r\n});\r\n```\r\n\r\n这下你应该明白`module`、`require`、`__filename`这些变量都是哪来的了吧 —— 它们会被作为function的参数在模块编译执行时注入进来。以一个扩展名为`.js`的模块为例，当你`require`它时，一个完整的方法调用大致包括下面几个过程：\r\n\r\n```flow\r\nst=>start: require()引入模块\r\nop1=>operation: 调用._load()加载模块\r\nop2=>operation: new Module(filename, parent)创建模块对象\r\nop3=>operation: 将模块对象存入缓存\r\nop4=>operation: 根据文件类型调用Module._extensions\r\nop5=>operation: 调用.compile()编译执行js模块\r\ncond=>condition: Module._cache是否无缓存\r\ne=>end: 返回module.exports结果\r\nst->op1->cond\r\ncond(yes)->op2->op3->op4->op5->e\r\ncond(no)->e\r\n```\r\n\r\n在[Node源码](https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L685-L691)中能看到，模块执行时，包装定义的几个变量被注入了：\r\n\r\n```JavaScript\r\nif (inspectorWrapper) {\r\n    result = inspectorWrapper(compiledWrapper, this.exports, this.exports,\r\n                              require, this, filename, dirname);\r\n\r\n} else {\r\n    result = compiledWrapper.call(this.exports, this.exports, require, this,\r\n                                  filename, dirname);\r\n}\r\n\r\n```\r\n\r\n> 题外话，从这里你也可以看出，在模块内使用`module.exports`与`exports`的区别\r\n\r\n## 3. webpack实现的前端模块化\r\n\r\n之所以在介绍「webpack是如何在打包出的代码中实现模块化」之前，先用一定篇幅介绍了Node中的模块化，是因为两者在同步依赖的设计与实现上有异曲同工之处。理解Node的模块化对学习webpack很有帮助。当然，由于运行环境的不同（webpack打包出的代码运行在客户端，而Node是在服务端），实现上也有一定的差异。\r\n\r\n下面就来看一下，webpack是如何在打包出的代码中实现前端（客户端）模块化的。\r\n\r\n### 3.1. 模块对象\r\n和Node的模块化实现类似，在webpack打包出的代码中，每个模块也有一个对应的模块对象。在`__webpack_require__()`方法中，有这么一段代码：\r\n\r\n```javascript\r\nfunction __webpack_require__(moduleId) {\r\n    // …… other code\r\n    \r\n    var module = installedModules[moduleId] = {\r\n        i: moduleId,\r\n        l: false,\r\n        exports: {},\r\n        parents: null,\r\n        children: []\r\n    };\r\n    \r\n    // …… other code\r\n}\r\n```\r\n\r\n类似于Node，在webpack中各个模块的也有对应的模块对象，其数据结构基本遵循CommonJS规范；其中`installedModules`则是模块缓存对象，类似于Node中的`require.cache`/`Module._cache`。\r\n\r\n### 2.2. 模块的require：`__webpack_require__`\r\n`__webpack_require__`是webpack前端运行时模块化中非常重要的一个方法，相当于CommonJS规范中的`require`。\r\n\r\n根据第一部分的流程图：在Node中，当我们`require`一个模块时，会先判断该模块是否在缓存之中，如果存在则直接返回该模块的`exports`属性；否则会加载并执行该模块。webpack中的实现也类似：\r\n\r\n```javascript\r\nfunction __webpack_require__(moduleId) {\r\n    // 1.首先会检查模块缓存\r\n    if(installedModules[moduleId]) {\r\n        return installedModules[moduleId].exports;\r\n    }\r\n    \r\n    // 2. 缓存不存在时，创建并缓存一个新的模块对象，类似Node中的new Module操作\r\n    var module = installedModules[moduleId] = {\r\n        i: moduleId,\r\n        l: false,\r\n        exports: {},\r\n        children: []\r\n    };\r\n\r\n    // 3. 执行模块，类似于Node中的：\r\n    // result = compiledWrapper.call(this.exports, this.exports, require, this, filename, dirname);\r\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r\n\r\n    module.l = true;\r\n\r\n    // 4. 返回该module的输出\r\n    return module.exports;\r\n}\r\n```\r\n\r\n如果你仔细对比webpack与Node，你会发现在`__webpack_require__`中有一个重要的区别：\r\n\r\n在webpack中不存在像Node一样调用`._compile()`这种方法的过程。即不会像Node那样，对一个未载入缓存的模块，通过「读取模块路径 -> 编译模块代码 -> 执行模块」来载入模块。为什么呢？\r\n\r\n这是因为，Node作为服务端语言，模块都是本地文件，加载时延低，可同步阻塞进行模块文件寻址、读取、编译和执行，这些过程在模块require的时候再“按需”执行即可；而webpack运行在客户端（浏览器），显然不能在需要时（即执行`__webpack_require__`时）再通过网络加载js文件，并同步地等待加载完成后再返回`__webpack_require__`。这种网络时延，显然不能满足“同步依赖”的要求。\r\n\r\n那么webpack是如何解决这个问题的呢？\r\n\r\n\r\n### 3.2. 如何解决前端的同步依赖\r\n\r\n我们还是回来看下Node：\r\n\r\nNode（v10）中加载、编译与执行（js）模块的代码主要集中在`Module._extensions['.js']`和`Module.prototype._compile`中。首先会通过`fs.readFileSync`读取文件内容，然后通过`vm.runInThisContext`来编译和执行JavaScript代码。\r\n\r\n> The vm module provides APIs for compiling and running code within V8 Virtual Machine contexts.\r\n\r\n但是，根据上面的分析，在前端runtime中肯定不能通过网络去同步获取JavaScript脚本文件；那么就需要我们换一个思路：有没有什么地方能够预先放置我们“之后”可能会需要的模块，让我们能够在require时不需要同步等待过长的时间（当然，这里的“之后”可能是几秒、几分钟后，也可能是这次事件循环task的下几行代码）。\r\n\r\n内存就是一个不错的选择。我们可以把同步依赖的模块先“注册”到内存中（模块暂存），等到require时，再执行该模块、缓存模块对象、返回对应的`exports`。而webpack中，这个所谓的内存就是`modules`对象。\r\n\r\n> 注意这里指的模块暂存和模块缓存概念完全不同。暂存可以粗略类比为将编译好的模块代码先放到内存中，实际并没有引入该模块。基于这个目的，我们也可以把“模块暂存”理解为“模块注册”，因此后文中“模块暂存”与“模块注册”具有相等的概念。\r\n\r\n所以，过程大致是这样的：\r\n\r\n当我们已经获取了模块内容后（但模块还未执行），我们就将其暂存在`modules`对象中，键就是webpack的moduleId；等到需要使用`__webpack_require__`引用模块时，发现缓存中没有，则从`modules`对象中取出暂存的模块并执行。\r\n\r\n### 3.3. 如何”暂存“模块\r\n\r\n思路已经清晰了，那么我们就来看看，webpack是如何将模块“暂存”在`modules`对象上的。在实际上，webpack打包出来的代码可以简单分为两类：\r\n\r\n- 一类是webpack模块化的前端runtime，你可以简单类比为RequireJS这样的前端模块化类库所实现的功能。它会控制模块的加载、缓存，提供诸如`__webpack_require__`这样的require方法等。\r\n- 另一类则是模块注册与运行的代码，包含了源码中的模块代码。为了进一步理解，我们先来看一下这部分的代码是怎样的。\r\n\r\n> 为了便于学习与代码阅读，建议你可以在webpack（v4）配置中加入`optimization:{runtimeChunk: {name: 'runtime'}}`，这样会让webpack将runtime与模块注册代码分开打包。\r\n\r\n```JavaScript\r\n// webpack module chunk\r\n(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[\"home-0\"],{\r\n\r\n/***/ \"module-home-0\":\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nconst myalert = __webpack_require__(\"module-home-1\");\r\n\r\nmyalert('test');\r\n\r\n/***/ }),\r\n\r\n/***/ \"module-home-1\":\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (a) {\r\n    alert('hi:' + a);\r\n};\r\n\r\n/***/ })\r\n\r\n},[[\"module-home-0\",\"home-1\"]]]);\r\n```\r\n\r\n上面这是一个不包含runtime的chunk，我们不妨将其称为module chunk（下面会沿用这个叫法）。简化一下这部分代码，大致结构如下：\r\n\r\n```JavaScript\r\n// webpack module chunk\r\nwindow[\"webpackJsonp\"].push([\r\n    [\"home-0\"], // chunkIds\r\n    {\r\n        \"module-home-0\": (function(module, exports, __webpack_require__){ /* some logic */ }),\r\n        \"module-home-1\": (function(module, exports, __webpack_require__){ /* some logic */ })\r\n    },\r\n    [[\"module-home-0\",\"home-1\"]]\r\n])\r\n```\r\n\r\n这里，`.push()`方法参数为一个数组，包含三个元素：\r\n\r\n- 第一个元素是一个数组，`[\"home-0\"]`表示该js文件所包含的所有chunk的id（可以粗略理解为，webpack中module组成chunk，chunk又组成file）；\r\n- 第二个元素是一个对象，键是各个模块的id，值则是一个被function包装后的模块；\r\n- 第三个元素也是一个数组，其又是由多个数组组成。具体作用我们先按下不表，最后再说。\r\n\r\n来看下参数数组的第二个元素 —— 包含模块代码的对象，你会发现这里方法签名是不是很像Node中的通过`Module.wrap()`进行的模块代码包装？没错，[webpack源码](https://github.com/webpack/webpack/blob/master/lib/FunctionModuleTemplatePlugin.js#L16-L31)中也有类似，会像Node那样，将每个模块的代码用一个function包装起来。\r\n\r\n而当webpack配置了runtime分离后，打包出的文件中会出现一个“纯净”的、不包含任何模块代码的runtime，其主要是一个自执行方法，其中暴露了一个全局变量`webpackJsonp`：\r\n\r\n```JavaScript\r\n// webpack runtime chunk\r\nvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\r\nvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\r\njsonpArray.push = webpackJsonpCallback;\r\n```\r\n\r\n> `webpackJsonp`变量名可以通过`output.jsonpFunction`进行配置\r\n\r\n可以看到，`window[\"webpackJsonp\"]`上的`.push()`方法已经被修改为了`webpackJsonpCallback()`方法。该方法如下：\r\n\r\n```javascript\r\n// webpack runtime chunk\r\nfunction webpackJsonpCallback(data) {\r\n    var chunkIds = data[0];\r\n    var moreModules = data[1];\r\n    var executeModules = data[2];\r\n\r\n    var moduleId, chunkId, i = 0, resolves = [];\r\n    // webpack会在installChunks中存储chunk的载入状态，据此判断chunk是否加载完毕\r\n    for(;i < chunkIds.length; i++) {\r\n        chunkId = chunkIds[i];\r\n        if(installedChunks[chunkId]) {\r\n            resolves.push(installedChunks[chunkId][0]);\r\n        }\r\n        installedChunks[chunkId] = 0;\r\n    }\r\n    \r\n    // 注意，这里会进行“注册”，将模块暂存入内存中\r\n    // 将module chunk中第二个数组元素包含的 module 方法注册到 modules 对象里\r\n    for(moduleId in moreModules) {\r\n        if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n            modules[moduleId] = moreModules[moduleId];\r\n        }\r\n    }\r\n\r\n    if(parentJsonpFunction) parentJsonpFunction(data);\r\n\r\n    while(resolves.length) {\r\n        resolves.shift()();\r\n    }\r\n\r\n    deferredModules.push.apply(deferredModules, executeModules || []);\r\n\r\n    return checkDeferredModules();\r\n};\r\n```\r\n\r\n注意以上方法的这几行，就是我们之前所说的「将模块“暂存”在modules对象上」\r\n\r\n```JavaScript\r\n// webpackJsonpCallback\r\nfor(moduleId in moreModules) {\r\n    if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n    modules[moduleId] = moreModules[moduleId];\r\n    }\r\n}\r\n```\r\n\r\n配合`__webpack_require__()`中下面这一行代码，就实现了在需要引入模块时，同步地将模块从暂存区取出来执行，避免使用网络请求导致过长的同步等待时间。\r\n\r\n```JavaScript\r\n// __webpack_require__\r\nmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r\n```\r\n\r\n### 3.4. 模块的自动执行\r\n\r\n到目前为止，对于webpack的同步依赖实现已经介绍的差不多了，但还遗留一个小问题：webpack中的所有js源文件都是模块，但如果都是不会自动执行的模块，那我们只是在前端引入了一堆“死”代码，怎么让代码“活”起来呢？\r\n\r\n很多时候，我们引入一个script标签加载脚本文件，至少希望其中一个模块的代码会自动执行，而不仅仅是注册在`modules`对象上。一般来说，这就是webpack中所谓的入口模块。\r\n\r\nwebpack是如何让这些入口模块自动执行的呢？不知道你是否还记得module chunk中那个按下不表的第三个参数：这个参数是一个数组，而数组里面每个元素又是一个数组\r\n\r\n```javascript\r\n[[\"module-home-0\",\"home-1\"], [\"module-home-2\",\"home-3\",\"home-5\"]]\r\n```\r\n\r\n对照上面这个例子，我们可以具体解释下参数的含义。第一个元素`[\"module-home-0\",\"home-1\"]`表示，我希望自动执行moduleId为`module-home-0`的这个模块，但是该模块需要chunkId为`home-1`的chunk已经加载后才能执行；同理，`[\"module-home-2\",\"home-3\",\"home-5\"]`表示自动执行`module-home-2`模块，但是需要检查chunk`home-3`和`home-5`已经加载。\r\n\r\n执行某些模块需要保证一些chunk已经加载是因为，该模块所依赖的其他模块可能并不在当前chunk中，而webpack在编译期会通过依赖分析自动将依赖模块的所属chunkId注入到此处。\r\n\r\n这个模块“自动”执行的功能在runtime chunk的代码中主要是由`checkDeferredModules()`方法实现：\r\n\r\n```JavaScript\r\nfunction checkDeferredModules() {\r\n    var result;\r\n    for(var i = 0; i < deferredModules.length; i++) {\r\n        var deferredModule = deferredModules[i];\r\n        var fulfilled = true;\r\n        // 第一个元素是模块id，后面是其所需的chunk\r\n        for(var j = 1; j < deferredModule.length; j++) {\r\n            var depId = deferredModule[j];\r\n            // 这里会首先判断模块所需chunk是否已经加载完毕\r\n            if(installedChunks[depId] !== 0) fulfilled = false;\r\n        }\r\n        // 只有模块所需的chunk都加载完毕，该模块才会被执行（__webpack_require__）\r\n        if(fulfilled) {\r\n            deferredModules.splice(i--, 1);\r\n            result = __webpack_require__(__webpack_require__.s = deferredModule[0]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n```\r\n\r\n## 4. 异步依赖\r\n\r\n如果你只是想学习webpack前端runtime中同步依赖的设计与实现，那么到这里主要内容基本已经结束了。不过我们知道，webpack支持使用动态模块引入的语法（代码拆分），例如：`dynamic import`和早期的`require.ensure`，这种方式与使用CommonJS的`require`和ESM的`import`最重要的区别在于，该类方法会异步（或者说按需）加载依赖。\r\n\r\n### 4.1. 代码转换\r\n\r\n就像在源码中使用`require`会在webpack打包时被替换为`__webpack_require__`一样，在源码中使用的异步依赖语法也会被webpack修改。以`dynamic import`为例，下面的代码\r\n\r\n```JavaScript\r\nimport('./test.js').then(mod => {\r\n    console.log(mod);\r\n});\r\n```\r\n\r\n在产出后会被转换为\r\n\r\n```JavaScript\r\n__webpack_require__.e(/* import() */ \"home-1\")\r\n    .then(__webpack_require__.bind(null, \"module-home-3\"))\r\n    .then(mod => {\r\n        console.log(mod);\r\n    });\r\n```\r\n\r\n上面代码是什么意思呢？我们知道，webpack打包后会将一些module合并为一个chunk，因此上面的`\"home-1\"`就表示：包含`./test.js`模块的chunk的chunkId为`\"home-1\"`。\r\n\r\nwebpack首先通过`__webpack_require__.e`加载指定chunk的script文件（module chunk），该方法返回一个promise，当script加载并执行完成后resolve该promise。webpack打包时会保证异步依赖的所有模块都已包含在该module chunk或当前上下文中。\r\n\r\n既然module chunk已经执行，那么表明异步依赖已经就绪，于是在then方法中执行`__webpack_require__`引用`test.js`模块（webpack编译后moduleId为module-home-3）并返回。这样在第二个then方法中就可以正常使用该模块了。\r\n\r\n### 4.2. `__webpack_require__.e`\r\n\r\n异步依赖的核心方法就是`__webpack_require__.e`。下面来分析一下该方法：\r\n\r\n```JavaScript\r\n__webpack_require__.e = function requireEnsure(chunkId) {\r\n    var promises = [];\r\n    var installedChunkData = installedChunks[chunkId];\r\n    \r\n    // 判断该chunk是否已经被加载，0表示已加载。installChunk中的状态：\r\n    // undefined：chunk未进行加载,\r\n    // null：chunk preloaded/prefetched\r\n    // Promise：chunk正在加载中\r\n    // 0：chunk加载完毕\r\n    if(installedChunkData !== 0) {\r\n        // chunk不为null和undefined，则为Promise，表示加载中，继续等待\r\n        if(installedChunkData) {\r\n            promises.push(installedChunkData[2]);\r\n        } else {\r\n            // 注意这里installChunk的数据格式\r\n            // 从左到右三个元素分别为resolve、reject、promise\r\n            var promise = new Promise(function(resolve, reject) {\r\n                installedChunkData = installedChunks[chunkId] = [resolve, reject];\r\n            });\r\n            promises.push(installedChunkData[2] = promise);\r\n\r\n            // 下面代码主要是根据chunkId加载对应的script脚本\r\n            var head = document.getElementsByTagName('head')[0];\r\n            var script = document.createElement('script');\r\n            var onScriptComplete;\r\n\r\n            script.charset = 'utf-8';\r\n            script.timeout = 120;\r\n            if (__webpack_require__.nc) {\r\n                script.setAttribute(\"nonce\", __webpack_require__.nc);\r\n            }\r\n            \r\n            // jsonpScriptSrc方法会根据传入的chunkId返回对应的文件路径\r\n            script.src = jsonpScriptSrc(chunkId);\r\n\r\n            onScriptComplete = function (event) {\r\n                script.onerror = script.onload = null;\r\n                clearTimeout(timeout);\r\n                var chunk = installedChunks[chunkId];\r\n                if(chunk !== 0) {\r\n                    if(chunk) {\r\n                        var errorType = event && (event.type === 'load' ? 'missing' : event.type);\r\n                        var realSrc = event && event.target && event.target.src;\r\n                        var error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');\r\n                        error.type = errorType;\r\n                        error.request = realSrc;\r\n                        chunk[1](error);\r\n                    }\r\n                    installedChunks[chunkId] = undefined;\r\n                }\r\n            };\r\n            var timeout = setTimeout(function(){\r\n                onScriptComplete({ type: 'timeout', target: script });\r\n            }, 120000);\r\n            script.onerror = script.onload = onScriptComplete;\r\n            head.appendChild(script);\r\n        }\r\n    }\r\n    return Promise.all(promises);\r\n};\r\n```\r\n\r\n该方法首先会根据chunkId在installChunks中判断该chunk是否正在加载或已经被加载；如果没有则会创建一个promise，将其保存在installChunks中，并通过`jsonpScriptSrc()`方法获取文件路径，通过sciript标签加载，最后返回该promise。\r\n\r\n`jsonpScriptSrc()`则可以理解为一个包含chunk map的方法，例如这个例子中：\r\n\r\n```JavaScript\r\nfunction jsonpScriptSrc(chunkId) {\r\n    return __webpack_require__.p + \"\" + ({}[chunkId]||chunkId) + \".\" + {\"home-1\":\"0b49ae3b\"}[chunkId] + \".js\"\r\n}\r\n```\r\n\r\n其中包含一个map —— `{\"home-1\":\"0b49ae3b\"}`，会根据home-1这个chunkId返回home-1.0b49ae3b.js这个文件名。\r\n\r\n### 4.3. 更新chunk加载状态\r\n\r\n最后，你会发现，在onload中，并没有调用promise的resolve方法。那么是何时resolve的呢？\r\n\r\n你还记得在介绍同步require时用于注册module的`webpackJsonpCallback()`方法么？我们之前说过，该方法参数数组中的第一个元素是一个chunkId的数组，代表了该脚本所包含的chunk。\r\n\r\n> p.s. 当一个普通的脚本被浏览器下载完毕后，会先执行该脚本，然后触发onload事件。\r\n\r\n因此，在`webpackJsonpCallback()`方法中，有一段代码就是根据chunkIds的数组，检查并更新chunk的加载状态：\r\n\r\n```JavaScript\r\n// webpackJsonpCallback()\r\nvar moduleId, chunkId, i = 0, resolves = [];\r\nfor(;i < chunkIds.length; i++) {\r\n    chunkId = chunkIds[i];\r\n    if(installedChunks[chunkId]) {\r\n        resolves.push(installedChunks[chunkId][0]);\r\n    }\r\n    installedChunks[chunkId] = 0;\r\n}\r\n\r\n// ……\r\n\r\nwhile(resolves.length) {\r\n    resolves.shift()();\r\n}\r\n```\r\n\r\n上面的代码先根据模块注册时的chunkId，取出installedChunks对应的所有loading中的chunk，最后将这些chunk的promise进行resolve操作。\r\n\r\n## 5. 写在最后\r\n\r\n至此，对于「webpack打包后是如何实现前端模块化」这个问题就差不多结束了。本文通过Node中的模块化为引子，介绍了webpack中的同步与异步模块加载的设计与实现。\r\n\r\n为了方便大家对照文中内容查看webpack运行时源码，我把基础的webpack runtime chunk和module chunk放在了[这里](https://gitee.com/alienzhou/codes/o431yhewq8kimbtdnjpcl12)，有兴趣的朋友可以对照着看。\r\n\r\n最后还是欢迎对webpack感兴趣的朋友能够相互交流，关注我的系列文章。\r\n\r\n## 参考资料\r\n\r\n- [NodeJS internal - cjs module loader](https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js)\r\n- [webpack MainTemplate](https://github.com/webpack/webpack/blob/master/lib/MainTemplate.js)\r\n- [webpack FunctionModuleTemplatePlugin](https://github.com/webpack/webpack/blob/master/lib/FunctionModuleTemplatePlugin.js)\r\n- [webpack RuntimeTemplate](https://github.com/webpack/webpack/blob/master/lib/RuntimeTemplate.js)\r\n- [webpack runtime chunk示例](https://gitee.com/alienzhou/codes/o431yhewq8kimbtdnjpcl12)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/18","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/18/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/18/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/18/events","html_url":"https://github.com/alienzhou/blog/issues/18","id":390657717,"node_id":"MDU6SXNzdWUzOTA2NTc3MTc=","number":18,"title":"【webpack进阶】使用babel避免webpack编译运行时模块依赖","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845019,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE5","url":"https://api.github.com/repos/alienzhou/blog/labels/Webpack","name":"Webpack","color":"e4e669","default":false,"description":""},{"id":1160330255,"node_id":"MDU6TGFiZWwxMTYwMzMwMjU1","url":"https://api.github.com/repos/alienzhou/blog/labels/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7","name":"自动化工具","color":"f9c0d1","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T12:30:46Z","updated_at":"2018-12-13T12:55:45Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 引言\r\n\r\nbabel是一个非常强大的工具，作用远不止我们平时的ES6 -> ES5语法转换这么单一。在前端进阶的道路上，了解与学习babel及其灵活的插件模式将会为前端赋予更多的可能性。\r\n\r\n本文就是运用babel，通过编写babel插件解决了一个实际项目中的问题。\r\n\r\n> 本文相关代码已托管至github: [babel-plugin-import-customized-require](https://github.com/alienzhou/babel-plugin-import-customized-require)\r\n\r\n## 1. 遇到的问题 \r\n\r\n最近在项目中遇到这样一个问题：我们知道，使用webpack作为构建工具是会默认自动帮我们进行依赖构建；但是在项目代码中，有一部分的依赖是运行时依赖/非编译期依赖（可以理解为像requirejs、seajs那样的纯前端模块化），对于这种依赖不做处理会导致webpack编译出错。\r\n\r\n为什么需要非编译期依赖呢？例如，在当前的业务模块（一个独立的webpack代码仓库）里，我依赖了一个公共业务模块的打点代码\r\n\r\n```javascript\r\n// 这是home业务模块代码\r\n// 依赖了common业务模块的代码\r\nimport log from 'common:util/log.js'\r\n\r\nlog('act-1');\r\n```\r\n\r\n然而，可能是由于技术栈不统一，或是因为common业务代码遗留问题无法重构，或者仅仅是为了业务模块的分治……总之，无法在webpack编译期解决这部分模块依赖，而是需要放在前端运行时框架解决。\r\n\r\n为了解决webpack编译期无法解析这种模块依赖的问题，可以给这种非编译期依赖引入新的语法，例如下面这样：\r\n\r\n```javascript\r\n// __my_require__是我们自定义的前端require方法\r\nvar log = __my_require__('common:util/log.js')\r\n\r\nlog('act-1');\r\n```\r\n\r\n但这样就导致了我们代码形式的分裂，拥抱规范让我们希望还是能够用ESM的标准语法来一视同仁。\r\n\r\n我们还是希望能像下面这样写代码：\r\n\r\n```javascript\r\n// 标准的ESM语法\r\nimport * as log from 'common:util/log.js';\r\n\r\nlog('act-1');\r\n```\r\n\r\n此外，也可以考虑使用webpack提供了externals配置来避免某些模块被webpack打包。然而，一个重要的问题是，在已有的common代码中有一套前端模块化语法，要将webpack编译出来的代码与已有模式融合存在一些问题。因此该方式也存在不足。\r\n\r\n针对上面的描述，总结来说，我们的目的就是：\r\n\r\n- 能够在代码中使用ESM语法，来进行非编译期分析的模块引用\r\n- 由于webpack会尝试打包该依赖，需要不会在编译期出错\r\n\r\n## 2. 解决思路\r\n\r\n基于上面的目标，首先，我们需要有一种方式能够标识不需要编译的运行期依赖。例如`util/record`这个模块，如果是运行时依赖，可以参考标准语法，为模块名添加标识：`runtime:util/record`。效果如下：\r\n\r\n```javascript\r\n// 下面这两行是正常的编译期依赖\r\nimport React from 'react';\r\nimport Nav from './component/nav';\r\n\r\n// 下面这两个模块，我们不希望webpack在编译期进行处理\r\nimport record from 'runtime:util/record';\r\nimport {Banner, List} from 'runtime:ui/layout/component';\r\n```\r\n\r\n其次，虽然标识已经可以让开发人员知道代码里哪些模块是webpack需要打包的依赖，哪些是非编译期依赖；但webpack不知道，它只会拿到模块源码，分析import语法拿到依赖，然后尝试加载依赖模块。但这时webpack傻眼了，因为像`runtime:util/record`这样的模块是运行时依赖，编译期找不到该模块。那么，就需要通过一种方式，让webpack“看不见”非编译期的依赖。\r\n\r\n最后，拿到非编译期依赖，由于浏览器现在还不支持ESM的import语法，因此需要将它变为在前端运行时我们自定义的模块依赖语法。\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/8/18/1654c154b3778163?w=626&h=1454&f=png&s=70125)\r\n\r\n## 3. 使用babel对源码进行分析\r\n\r\n### 3.1. babel相关工具介绍\r\n\r\n> 对babel以及插件机制不太了解的同学，可以先看这一部分做一个简单的了解。\r\n\r\nbabel是一个强大的javascript compiler，可以将源码通过词法分析与语法分析转换为AST（抽象语法树），通过对AST进行转换，可以修改源码，最后再将修改后的AST转换会目标代码。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/8/17/1654852a672a4d8e?w=2004&h=362&f=png&s=107940)\r\n\r\n由于篇幅限制，本文不会对compiler或者AST进行过多介绍，但是如果你学过编译原理，那么对词法分析、语法分析、token、AST应该都不会陌生。即使没了解过也没有关系，你可以粗略的理解为：babel是一个compiler，它可以将javascript源码转化为一种特殊的数据结构，这种数据结构就是树，也就是AST，它是一种能够很好表示源码的结构。babel的AST是基于[ESTree](https://github.com/estree/estree)的。\r\n\r\n例如，`var alienzhou = 'happy'`这条语句，经过babel处理后它的AST大概是下面这样的\r\n\r\n```javascript\r\n{\r\n    type: 'VariableDeclaration',\r\n    kind: 'var',\r\n    // ...其他属性\r\n    decolarations: [{\r\n        type: 'VariableDeclarator',\r\n        id: {\r\n            type: 'Identifier',\r\n            name: 'alienzhou',\r\n            // ...其他属性\r\n        },\r\n        init: {\r\n            type: 'StringLiteral',\r\n            value: 'happy',\r\n            // ...其他属性\r\n        }\r\n    }],\r\n}\r\n```\r\n\r\n这部分AST node表示，这是一条变量声明的语句，使用`var`关键字，其中id和init属性又是两个AST node，分别是名称为alienzhou的标识符（Identifier）和值为happy的字符串字面量（StringLiteral）。\r\n\r\n这里，简单介绍一些如何使用babel及其提供的一些库来进行AST的分析和修改。生成AST可以通过`babel-core`里的方法，例如：\r\n\r\n```javascript\r\nconst babel = require('babel-core');\r\nconst {ast} = babel.transform(`var alienzhou = 'happy'`);\r\n```\r\n\r\n然后遍历AST，找到特定的节点进行修改即可。babel也为我们提供了traverse方法来遍历AST：\r\n\r\n```javascript\r\nconst traverse = require('babel-traverse').default;\r\n```\r\n\r\n在babel中访问AST node使用的是[vistor模式](https://en.wikipedia.org/wiki/Visitor_pattern)，可以像下面这样指定AST node type来访问所需的AST node：\r\n\r\n```javascript\r\ntraverse(ast, {\r\n    StringLiteral(path) {\r\n        console.log(path.node.value)\r\n        // ...\r\n    }\r\n})\r\n```\r\n\r\n这样就可以得到所有的字符串字面量，当然你也可以替换这个节点的内容：\r\n\r\n```javascript\r\nlet visitor = {\r\n    StringLiteral(path) {\r\n        console.log(path.node.value)\r\n        path.replaceWith(\r\n            t.stringLiteral('excited');\r\n        )\r\n    }\r\n};\r\ntraverse(ast, visitor);\r\n```\r\n\r\n> 注意，AST是一个mutable对象，所有的节点操作都会在原AST上进行修改。\r\n\r\n这篇文章不会详细介绍babel-core、babel-traverse的API，而是帮助没有接触过的朋友快速理解它们，具体的使用方式可以参考相关文档。\r\n\r\n由于大部分的webpack项目都会在loader中使用babel，因此只需要提供一个babel的插件来处理非编译期依赖语法即可。而babel插件其实就是导出一个方法，该方法会返回我们上面提到的visitor对象。\r\n\r\n那么接下来我们专注于visitor的编写即可。\r\n\r\n### 3.2 编写一个babel插件来解决非编译期依赖\r\n\r\nESM的import语法在AST node type中是[ImportDeclaration](https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md#importdeclaration)：\r\n\r\n```javascript\r\nexport default function () {\r\n    return {\r\n        ImportDeclaration: {\r\n            enter(path) {\r\n                // ...\r\n            }\r\n            exit(path) {\r\n                let source = path.node.source;\r\n                if (t.isStringLiteral(source) && /^runtime:/.test(source.value)) {\r\n                    // ...\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在enter方法里，需要收集ImportDeclaration语法的相关信息；在exit方法里，判断当前ImportDeclaration是否为非编译期依赖，如果是则进行语法转换。\r\n\r\n收集ImportDeclaration语法相关信息需要注意，对于不同的import specifier类型，需要不同的分析方式，下面列举了这五种import：\r\n\r\n```javascript\r\nimport util from 'runtime:util';\r\nimport * as util from 'runtime:util';\r\nimport {util} from 'runtime:util';\r\nimport {util as u} from 'runtime:util';\r\nimport 'runtime:util';\r\n```\r\n\r\n对应了三类specifier：\r\n\r\n- ImportSpecifier：`import {util} from 'runtime:util'`,`import {util as u} from 'runtime:util';`\r\n- ImportDefaultSpecifier：`import util from 'runtime:util'`\r\n- ImportNamespaceSpecifier：`import * as util from 'runtime:util'`\r\n\r\n> `import 'runtime:util'`中没有specifier\r\n\r\n可以在ImportDeclaration的基础上，对子节点进行traverse，这里新建了一个visitor用来访问Specifier，针对不同语法进行收集：\r\n\r\n```javascript\r\nconst specifierVisitor = {\r\n    ImportNamespaceSpecifier(_path) {\r\n        let data = {\r\n            type: 'NAMESPACE',\r\n            local: _path.node.local.name\r\n        };\r\n\r\n        this.specifiers.push(data);\r\n    },\r\n\r\n    ImportSpecifier(_path) {\r\n        let data = {\r\n            type: 'COMMON',\r\n            local: _path.node.local.name,\r\n            imported: _path.node.imported ? _path.node.imported.name : null\r\n        };\r\n\r\n        this.specifiers.push(data);\r\n    },\r\n\r\n    ImportDefaultSpecifier(_path) {\r\n        let data = {\r\n            type: 'DEFAULT',\r\n            local: _path.node.local.name\r\n        };\r\n\r\n        this.specifiers.push(data);\r\n    }\r\n}\r\n```\r\n\r\n在ImportDeclaration中使用specifierVisitor进行遍历：\r\n\r\n```javascript\r\nexport default function () {\r\n    // store the specifiers in one importDeclaration\r\n    let specifiers = [];\r\n    return {\r\n        ImportDeclaration: {\r\n            enter(path) {\r\n                path.traverse(specifierVisitor, { specifiers });\r\n            }\r\n            exit(path) {\r\n                let source = path.node.source;\r\n                if (t.isStringLiteral(source) && /^runtime:/.test(source.value)) {\r\n                    // ...\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n到目前为止，我们在进入ImportDeclaration节点时，收集了import语句相关信息，在退出节点时，通过判断可以知道目前节点是否是非编译期依赖。因此，如果是非编译期依赖，只需要根据收集到的信息替换节点语法即可。\r\n\r\n生成新节点可以使用babel-types。不过推荐使用babel-template，会令代码更简便与清晰。下面这个方法，会根据不同的import信息，生成不同的运行时代码，其中假定__my_require__方法就是自定义的前端模块require方法。\r\n\r\n```javascript\r\nconst template = require('babel-template');\r\n\r\nfunction constructRequireModule({\r\n    local,\r\n    type,\r\n    imported,\r\n    moduleName\r\n}) {\r\n\r\n    /* using template instead of origin type functions */\r\n    const namespaceTemplate = template(`\r\n        var LOCAL = __my_require__(MODULE_NAME);\r\n    `);\r\n\r\n    const commonTemplate = template(`\r\n        var LOCAL = __my_require__(MODULE_NAME)[IMPORTED];\r\n    `);\r\n\r\n    const defaultTemplate = template(`\r\n        var LOCAL = __my_require__(MODULE_NAME)['default'];\r\n    `);\r\n\r\n    const sideTemplate = template(`\r\n        __my_require__(MODULE_NAME);\r\n    `);\r\n    /* ********************************************** */\r\n\r\n    let declaration;\r\n    switch (type) {\r\n        case 'NAMESPACE':\r\n            declaration = namespaceTemplate({\r\n                LOCAL: t.identifier(local),\r\n                MODULE_NAME: t.stringLiteral(moduleName)\r\n            });\r\n            break;\r\n\r\n        case 'COMMON':\r\n            imported = imported || local;\r\n            declaration = commonTemplate({\r\n                LOCAL: t.identifier(local),\r\n                MODULE_NAME: t.stringLiteral(moduleName),\r\n                IMPORTED: t.stringLiteral(imported)\r\n            });\r\n            break;\r\n\r\n        case 'DEFAULT':\r\n            declaration = defaultTemplate({\r\n                LOCAL: t.identifier(local),\r\n                MODULE_NAME: t.stringLiteral(moduleName)\r\n            });\r\n            break;\r\n\r\n        case 'SIDE':\r\n            declaration = sideTemplate({\r\n                MODULE_NAME: t.stringLiteral(moduleName)\r\n            })\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return declaration;\r\n}\r\n```\r\n\r\n最后整合到一开始的visitor中：\r\n\r\n```javascript\r\nexport default function () {\r\n    // store the specifiers in one importDeclaration\r\n    let specifiers = [];\r\n    return {\r\n        ImportDeclaration: {\r\n            enter(path) {\r\n                path.traverse(specifierVisitor, { specifiers });\r\n            }\r\n            exit(path) {\r\n                let source = path.node.source;\r\n                let moduleName = path.node.source.value;\r\n                if (t.isStringLiteral(source) && /^runtime:/.test(source.value)) {\r\n                    let nodes;\r\n                    if (specifiers.length === 0) {\r\n                        nodes = constructRequireModule({\r\n                            moduleName,\r\n                            type: 'SIDE'\r\n                        });\r\n                        nodes = [nodes]\r\n                    }\r\n                    else {\r\n                        nodes = specifiers.map(constructRequireModule);\r\n                    }\r\n                    path.replaceWithMultiple(nodes);\r\n                }\r\n                specifiers = [];\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n那么，对于一段`import util from 'runtime:util'`的源码，在该babel插件修改后变为了`var util = require('runtime:util')['default']`，该代码也会被webpack直接输出。\r\n\r\n这样，通过babel插件，我们就完成了文章最一开始的目标。\r\n\r\n## 4. 处理dynamic import\r\n\r\n细心的读者肯定会发现了，我们在上面只解决了静态import的问题，那么像下面这样的动态import不是仍然会有以上的问题么？\r\n\r\n```javascript\r\nimport('runtime:util').then(u => {\r\n    u.record(1);\r\n});\r\n```\r\n是的，仍然会有问题。因此，进一步我们还需要处理动态import的语法。要做的就是在visitor中添加一个新的node type：\r\n\r\n```javascript\r\n{\r\n    Import: {\r\n        enter(path) {\r\n            let callNode = path.parentPath.node;\r\n            let nameNode = callNode.arguments && callNode.arguments[0] ? callNode.arguments[0] : null;\r\n\r\n            if (t.isCallExpression(callNode)\r\n                && t.isStringLiteral(nameNode)\r\n                && /^runtime:/.test(nameNode.value)\r\n            ) {\r\n                let args = callNode.arguments;\r\n                path.parentPath.replaceWith(\r\n                    t.callExpression(\r\n                        t.memberExpression(\r\n                            t.identifier('__my_require__'), t.identifier('async'), false),\r\n                            args\r\n                ));\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n这时，上面的动态import代码就会被替换为：\r\n\r\n```javascript\r\n__my_require__.async('runtime:util').then(u => {\r\n    u.record(1);\r\n});\r\n```\r\n\r\n非常方便吧。\r\n\r\n## 5. 写在最后\r\n\r\n> 本文相关代码已托管至github: [babel-plugin-import-customized-require](https://github.com/alienzhou/babel-plugin-import-customized-require)\r\n\r\n本文是从一个关于webpack编译期的需求出发，应用babel来使代码中部分模块依赖不在webpack编译期进行处理。其实从中可以看出，babel给我们赋予了极大的可能性。\r\n\r\n文中解决的问题只是一个小需求，也许你会有更不错的解决方案；然而这里更多的是展示了babel的灵活、强大，它给前端带来的更多的空间与可能性，在许多衍生的领域也都能发现它的身影。希望本文能成为一个引子，为你拓展解决问题的另一条思路。\r\n\r\n## 参考资料\r\n\r\n- [Babel AST spec](https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md)\r\n- [visitor pattern](https://en.wikipedia.org/wiki/Visitor_pattern)\r\n- [Babel Plugin Handbook](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md)\r\n- [AST Explorer](http://astexplorer.net/)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/17","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/17/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/17/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/17/events","html_url":"https://github.com/alienzhou/blog/issues/17","id":390638597,"node_id":"MDU6SXNzdWUzOTA2Mzg1OTc=","number":17,"title":"各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845016,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E7%BB%BC%E5%90%88","name":"综合","color":"a2eeef","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T11:36:30Z","updated_at":"2018-12-13T11:36:30Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 前言\r\n\r\n服务器推（Server Push）是一类特定技术的总称。一般情况，客户端与服务器的交互方式是：客户端发起请求，服务器收到请求返回响应结果，客户端接收响应结果进行处理。从上述的交互过程中可以看出，客户端想要获取数据，需要自主地向服务端发起请求，获取相关数据。\r\n\r\n在大多数场景下，客户端的“主动式”行为已经可以满足需求了。然而，在一些场景下，需要服务器“主动”向客户端推送数据。例如：\r\n\r\n- 聊天室或者对话类应用\r\n- 实时的数据监控与统计\r\n- 股票财经类看板等等\r\n\r\n这类应用有几个重要特点：要求较高的实时性，同时客户端无法预期数据更新周期，在服务端获取最新数据时，需要将信息同步给客户端。这类应用场景被称为“服务器推”（Server Push）。\r\n\r\n“服务器推”技术由来已久，从最初的简单轮询，到后来基于长轮询的COMET，到HTML5规范的SSE，以及实现全双工的WebSocket协议，“服务器推”的技术不断发展。本文会介绍这些技术的基本原理以及实现方式，来帮助大家迅速了解与掌握“服务器推”各类技术的基本原理。文末会附上完整的demo地址。\r\n\r\n## 1. 简易轮询\r\n\r\n简易轮询是“解决”该问题最简陋的一个技术方式。\r\n\r\n简易轮询本质上就是在前端创建一个定时器，每隔一定的时间去查询后端服务，如果有数据则进行相应的处理。\r\n\r\n```javascript\r\nfunction polling() {\r\n    fetch(url).then(data => {\r\n        process(data);\r\n        return;\r\n    }).catch(err => {\r\n        return;\r\n    }).then(() => {\r\n        setTimeout(polling, 5000);\r\n    });\r\n}\r\n\r\npolling();\r\n```\r\n\r\n轮询开始时，向后端发送请求，待响应结束后，间隔一定时间再去请求数据，如此循环往复。效果如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/8/163db06dae676193?w=1257&h=365&f=gif&s=315178)\r\n\r\n这种做法的优点就是非常简单，几乎不需要进行任何额外的配置或开发。\r\n\r\n而与此同时，缺点也十分明显。首先，这种相当于定时轮询的方式在获取数据上存在显而易见的延迟，要想降低延迟，只能缩短轮询间隔；而另一方面，每次轮询都会进行一次完整的HTTP请求，如果没有数据更新，相当于是一次“浪费”的请求，对服务端资源也是一种浪费。\r\n\r\n因此，轮询的时间间隔需要进行仔细考虑。轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担。\r\n\r\n### 2. COMET\r\n\r\n随着web应用的发展，尤其是基于ajax的web2.0时代中web应用需求与技术的发展，基于纯浏览器的“服务器推”技术开始受到较多关注，Alex Russell（Dojo Toolkit 的项目 Lead）称这种基于HTTP长连接、无须在浏览器端安装插件的“服务器推”技术为“Comet”。\r\n\r\n常用的COMET分为两种：基于HTTP的长轮询（long-polling）技术，以及基于iframe的长连接流（stream）模式。\r\n\r\n#### 2.1 基于HTTP的长轮询（long-polling）\r\n\r\n在简单轮询中，我们会每隔一定的时间向后端请求。这种方式最大的问题之一就是，数据的获取延迟受限于轮询间隔，无法第一时间获取服务想要推送数据。\r\n\r\n长轮询是再此基础上的一种改进。客户端发起请求后，服务端会保持住该连接，直到后端有数据更新后，才会将数据返回给客户端；客户端在收到响应结果后再次发送请求，如此循环往复。关于简单轮询与长轮询的区别，一图胜千言：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/7/163dabc8440e4ece?w=665&h=391&f=png&s=33101)\r\n\r\n这样，服务端一旦有数据想要推送，可以及时送达到客户端。\r\n\r\n```javascript\r\n\r\nfunction query() {\r\n    fetchMsg('/longpolling')\r\n        .then(function(data) {\r\n            // 请求结束，触发事件通知eventbus\r\n            eventbus.trigger('fetch-end', {data, status: 0});\r\n        });\r\n}\r\n\r\neventbus.on('fetch-end', function (result) {\r\n    // 处理服务端返回的数据\r\n    process(result);\r\n    // 再次发起请求\r\n    query();\r\n});\r\n```\r\n\r\n以上是一段简略版的前端代码，通过eventbus来通知请求结束，收到结束消息后，`process(result)`处理所需数据，同时再次调用`query()`发起请求。\r\n\r\n而在服务端，以node为例，服务端只需要在监听到有消息/数据更新时，再进行返回即可。\r\n\r\n```javascript\r\nconst app = http.createServer((req, res) => {\r\n    // 返回数据的方法\r\n    const longPollingSend = data => {\r\n        res.end(data);\r\n    };\r\n\r\n    // 当有数据更新时，服务端“推送”数据给客户端\r\n    EVENT.addListener(MSG_POST, longPollingSend);\r\n\r\n    req.socket.on('close', () => {\r\n        console.log('long polling socket close');\r\n        // 注意在连接关闭时移除监听，避免内存泄露\r\n        EVENT.removeListener(MSG_POST, longPollingSend);\r\n    });\r\n});\r\n```\r\n\r\n效果如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/8/163db08447932e5e?w=1200&h=311&f=gif&s=505612)\r\n\r\n### 2.2 基于iframe的长连接流（stream）模式\r\n\r\n当我们在页面中嵌入一个iframe并设置其src时，服务端就可以通过长连接“源源不断”地向客户端输出内容。\r\n\r\n例如，我们可以向客户端返回一段script标签包裹的javascript代码，该代码就会在iframe中执行。因此，如果我们预先在iframe的父页面中定义一个处理函数`process()`，而在每次有新数据需要推送时，在该连接响应中写入`<script>parent.process(${your_data})</script>`。那么iframe中的这段代码就会调用父页面中预先定义的`process()`函数。（是不是有点像JSONP传输数据的方式？）\r\n\r\n```javascript\r\n// 在父页面中定义的数据处理方法\r\nfunction process(data) {\r\n    // do something\r\n}\r\n\r\n// 创建不可见的iframe\r\nvar iframe = document.createElement('iframe');\r\niframe.style = 'display: none';\r\n// src指向后端接口\r\niframe.src = '/long_iframe';\r\ndocument.body.appendChild(iframe);\r\n```\r\n\r\n后端还是以node为例\r\n\r\n```javascript\r\nconst app = http.createServer((req, res) => {\r\n    // 返回数据的方法，将数据拼装成script脚本返回给iframe\r\n    const iframeSend = data => {\r\n        let script = `<script type=\"text/javascript\">\r\n                        parent.process(${JSON.stringify(data)})\r\n                    </script>`;\r\n        res.write(script);\r\n    };\r\n\r\n    res.setHeader('connection', 'keep-alive');\r\n    // 注意设置相应头的content-type\r\n    res.setHeader('content-type', 'text/html; charset=utf-8');        \r\n    // 当有数据更新时，服务端“推送”数据给客户端\r\n    EVENT.addListener(MSG_POST, iframeSend);\r\n\r\n    req.socket.on('close', () => {\r\n        console.log('iframe socket close');\r\n        // 注意在连接关闭时移除监听，避免内存泄露\r\n        EVENT.removeListener(MSG_POST, iframeSend);\r\n    });\r\n});\r\n```\r\n\r\n效果如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/8/163db0aba564b278?w=1206&h=334&f=gif&s=3632784)\r\n\r\n不过使用iframe有个小瑕疵，因此这个iframe相当于永远也不会加载完成，所以浏览器上会一直有一个loading标志。\r\n\r\n总得来说，长轮询和iframe流这两种COMMET技术，具有了不错的实用价值，其特点在于兼容性非常强，不需要客户端或服务端支持某些新的特性。不过，为了便于处理COMET使用时的一些问题，还是推荐在生产环境中考虑一些成熟的第三方库。值得一提的是，Socket.io在不兼容WebSocket（我们后面会提到）的浏览器中也会回退到长轮询模式。\r\n\r\n然而，COMET技术并不是HTML5标准的一部分，从兼容标准的角度出发的话，并不推荐使用。（尤其在我们有了一些其他技术之后）\r\n\r\n### 3. SSE (Server-Sent Events)\r\n\r\nSSE (Server-Sent Events) 是HTML5标准中的一部分。其实现原理类似于我们在上一节中提到的基于iframe的长连接模式。\r\n\r\nHTTP响应内容有一种特殊的content-type —— text/event-stream，该响应头标识了响应内容为事件流，客户端不会关闭连接，而是等待服务端不断得发送响应结果。\r\n\r\nSSE规范比较简单，主要分为两个部分：浏览器中的`EventSource`对象，以及服务器端与浏览器端之间的通讯协议。\r\n\r\n在浏览器中可以通过`EventSource`构造函数来创建该对象\r\n\r\n```javascript\r\nvar source = new EventSource('/sse');\r\n```\r\n\r\n而SSE的响应内容可以看成是一个事件流，由不同的事件所组成。这些事件会触发前端`EventSource`对象上的方法。\r\n\r\n```javascript\r\n// 默认的事件\r\nsource.addEventListener('message', function (e) {\r\n    console.log(e.data);\r\n}, false);\r\n\r\n// 用户自定义的事件名\r\nsource.addEventListener('my_msg', function (e) {\r\n    process(e.data);\r\n}, false);\r\n\r\n// 监听连接打开\r\nsource.addEventListener('open', function (e) {\r\n    console.log('open sse');\r\n}, false);\r\n\r\n// 监听错误\r\nsource.addEventListener('error', function (e) {\r\n    console.log('error');\r\n});\r\n\r\n```\r\n\r\n`EventSource`通过事件监听的方式来工作。注意上面的代码监听了`my_msg`事件，SSE支持自定义事件，默认事件通过监听`message`来获取数据。\r\n\r\nSSE中，每个事件由类型和数据两部分组成，同时每个事件可以有一个可选的标识符。不同事件的内容之间通过仅包含回车符和换行符的空行（\"\\r\\n\"）来分隔。每个事件的数据可能由多行组成。\r\n\r\n- 类型为空白，表示该行是注释，会在处理时被忽略。\r\n- 类型为 data，表示该行包含的是数据。以 data 开头的行可以出现多次。所有这些行都是该事件的数据。\r\n- 类型为 event，表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件。例如我在上面自定义的`my_msg`事件。\r\n- 类型为 id，表示该行用来声明事件的标识符。\r\n- 类型为 retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间。\r\n\r\n可以看到，SSE确实是一个比较简单的协议规范，服务端实现也比较简单：\r\n\r\n```javascript\r\nconst app = http.createServer((req, res) => {\r\n    const sseSend = data => {\r\n        res.write('retry:10000\\n');            \r\n        res.write('event:my_msg\\n');\r\n        // 注意文本数据传输\r\n        res.write(`data:${JSON.stringify(data)}\\n\\n`);\r\n    };\r\n\r\n    // 注意设置响应头的content-type\r\n    res.setHeader('content-type', 'text/event-stream');\r\n    // 一般不会缓存SSE数据\r\n    res.setHeader('cache-control', 'no-cache');\r\n    res.setHeader('connection', 'keep-alive');\r\n    res.statusCode = 200;\r\n\r\n    res.write('retry:10000\\n');\r\n    res.write('event:my_msg\\n\\n');\r\n\r\n    EVENT.addListener(MSG_POST, sseSend);\r\n\r\n    req.socket.on('close', () => {\r\n        console.log('sse socket close');\r\n        EVENT.removeListener(MSG_POST, sseSend);\r\n    });\r\n});\r\n```\r\n\r\n效果如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/8/163db0c9519f6a53?w=1191&h=450&f=gif&s=405289)\r\n\r\n此外，我们还可以考虑结合HTTP/2的优势来使用SSE。然而，一个可能不太好的消息是，IE/Edge并不兼容。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/7/163daf0d02eb1e6c?w=2352&h=1146&f=png&s=253828)\r\n\r\n当然，你可以通过一些手段来写一个兼容IE的polyfill。不过，由于IE上的XMLHttpRequest对象并不支持获取部分的响应内容，因此只能使用XDomainRequest来替代，当然，这也导致了一些小问题。如果大家对具体的实现细节感兴趣，可以看一下这个polyfill库[Yaffle/EventSource](https://github.com/Yaffle/EventSource)。\r\n\r\n### WebSocket\r\n\r\nWebSocket与http协议一样都是基于TCP的。WebSocket其实不仅仅限于“服务器推”了，它是一个全双工的协议，适用于需要进行复杂双向数据通讯的场景。因此也有着更复杂的规范。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/8/163db3d3dd408fcb?w=540&h=231&f=png&s=9923)\r\n\r\n当客户端要和服务端建立WebSocket连接时，在客户端和服务器的握手过程中，客户端首先会向服务端发送一个HTTP请求，包含一个`Upgrade`请求头来告知服务端客户端想要建立一个WebSocket连接。\r\n\r\n在客户端建立一个WebSocket连接非常简单：\r\n\r\n```javascript\r\nvar ws = new WebSocket('ws://127.0.0.1:8080');\r\n```\r\n当然，类似于`HTTP`和`HTTPS`，`ws`相对应的也有`wss`用以建立安全连接。\r\n\r\n这时的请求头如下：（注意其中的Upgrade字段）\r\n\r\n```\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\nCache-Control: no-cache\r\nConnection: Upgrade\r\nCookie: Hm_lvt_4e63388c959125038aabaceb227cea91=1527001174\r\nHost: 127.0.0.1:8080\r\nOrigin: http://127.0.0.1:8080\r\nPragma: no-cache\r\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\nSec-WebSocket-Key: 0lUPSzKT2YoUlxtmXvdp+w==\r\nSec-WebSocket-Version: 13\r\nUpgrade: websocket\r\n```\r\n\r\n而服务器在收到请求后进行处理，响应头如下\r\n\r\n```\r\nConnection: Upgrade\r\nOrigin: http://127.0.0.1:8080\r\nSec-WebSocket-Accept: 3NOOJEzyscVfEf0q14gkMrpV20Q=\r\nUpgrade: websocket\r\n```\r\n\r\n表示升级到了WebSocket协议。\r\n\r\n注意，上面的请求头中有一个`Sec-WebSocket-Key`，这其实和加密、安全性关系不大，最主要的作用是来验证服务器是否真的正确“理解”了WebSocket、该WebSocket连接是否有效。服务器会使用`Sec-WebSocket-Key`，并根据一个固定的算法\r\n\r\n```javascript\r\nmask = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";  // 一个规定的字符串\r\naccept = base64(sha1(key + mask));\r\n```\r\n\r\n生成`Sec-WebSocket-Accept`响应头字段，交由浏览器验证。\r\n\r\n接下来，浏览器与服务器之间就可以愉快地进行双向通信了。\r\n\r\n鉴于篇幅，关于WebSocket协议的具体规范与细节（例如数据帧格式、心跳检查等）就不在这里深入了，网络上也有很多这类的不错的文章可以阅读，感兴趣的读者也可以阅读本文最后的参考资料。\r\n\r\n下面简单介绍一下WebSocket的使用。\r\n\r\n在浏览器端，建立WebSocket连接后，可以通过`onmessage`来监听数据信息。\r\n\r\n```javascript\r\nvar ws = new WebSocket('ws://127.0.0.1:8080');\r\n\r\nws.onopen = function () {\r\n    console.log('open websocket');\r\n};\r\n\r\nws.onmessage = function (e) {\r\n    var data = JSON.parse(e.data);\r\n    process(data);\r\n};\r\n```\r\n\r\n在服务器端，由于WebSocket协议具有较多的规范与细节需要处理，因此建议使用一些封装较完备的第三方库。例如node中的[websocket-node](https://github.com/theturtle32/WebSocket-Node)和著名的[socket.io](https://github.com/socketio/socket.io)。当然，其他语言也有许多[开源实现](https://github.com/search?q=websocket)。node部分代码如下：\r\n\r\n```javascript\r\nconst http = require('http');\r\nconst WebSocketServer = require('websocket').server;\r\n\r\nconst app = http.createServer((req, res) => {\r\n    // ...\r\n});\r\napp.listen(process.env.PORT || 8080);\r\n\r\nconst ws = new WebSocketServer({\r\n    httpServer: app\r\n});\r\n\r\nws.on('request', req => {\r\n    let connection = req.accept(null, req.origin);\r\n    let wsSend = data => {\r\n        connection.send(JSON.stringify(data));\r\n    };\r\n    // 接收客户端发送的数据\r\n    connection.on('message', msg => {\r\n        console.log(msg);\r\n    });\r\n    connection.on('close', con => {\r\n        console.log('websocket close');\r\n        EVENT.removeListener(MSG_POST, wsSend);\r\n    });\r\n    // 当有数据更新时，使用WebSocket连接来向客户端发送数据\r\n    EVENT.addListener(MSG_POST, wsSend);\r\n});\r\n```\r\n\r\n效果如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/8/163db4bae3a5ec95?w=1229&h=679&f=gif&s=752411)\r\n\r\n## 写在最后\r\n\r\n服务器推（Server Push）作为一类特定的技术，在一些业务场景中起到了重要的作用，了解各类技术实现的原理与特点，有利于在实际的业务场景中帮助我们做出一定的选择与判断。\r\n\r\n为了便于理解文中的内容，我把所有代码整理在了一个demo里，感兴趣的朋友可以在[这里](https://github.com/alienzhou/server_push_demo)下载，并在本地运行查看。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/8/163db4e9e1cf80b1?w=1806&h=650&f=gif&s=2564909)\r\n\r\n## 参考资料\r\n\r\n- [w3c: Server-Sent Events](https://www.w3.org/TR/2015/REC-eventsource-20150203/)\r\n- [w3c: The WebSocket API](https://www.w3.org/TR/resource-hints/)\r\n- [Comet：基于 HTTP 长连接的“服务器推”技术](https://www.ibm.com/developerworks/cn/web/wa-lo-comet/)\r\n- [HTML5 服务器推送事件（Server-sent Events）实战开发](https://www.ibm.com/developerworks/cn/web/1307_chengfu_serversentevent/)\r\n- [What is Sec-WebSocket-Key for?\r\n](https://stackoverflow.com/questions/18265128/what-is-sec-websocket-key-for)\r\n- [Deep dive into WebSockets and HTTP/2 with SSE + how to pick the right path](https://blog.sessionstack.com/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7)\r\n- [MDN: Server Sent Event](https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events)\r\n- [The WebSocket Protocol](https://tools.ietf.org/html/rfc6455)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/16","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/16/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/16/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/16/events","html_url":"https://github.com/alienzhou/blog/issues/16","id":390634798,"node_id":"MDU6SXNzdWUzOTA2MzQ3OTg=","number":16,"title":"【CSS模块化之路3】 使用💅styled-components来进行react开发","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845018,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE4","url":"https://api.github.com/repos/alienzhou/blog/labels/CSS","name":"CSS","color":"7057ff","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T11:25:40Z","updated_at":"2018-12-13T11:25:40Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"CSS是一门几十分钟就能入门，但是却需要很长的时间才能掌握好的语言。它有着它自身的一些复杂性与局限性。其中非常重要的一点就是，本身不具备真正的模块化能力。\r\n\r\n> 系列文章链接 ↓ ↓\r\n> - [【CSS模块化之路1】使用BEM与命名空间来规范CSS](https://github.com/alienzhou/blog/issues/14)\r\n> - [【CSS模块化之路2】webpack中的Local Scope](https://github.com/alienzhou/blog/issues/15)\r\n> - [【CSS模块化之路3】 使用💅styled-components来进行react开发](https://github.com/alienzhou/blog/issues/16)\r\n\r\n## 1. 面临的问题\r\nCSS中虽然有`@import`功能。然而，我们都知道，这里的`@import`仅仅是表示引入相应的CSS文件，但其模块化核心问题并未解决——CSS文件中的任何一个选择器都会作用在整个文档范围里。\r\n\r\n而如今的前端项目规模越来越大，已经不是过去随便几个css、js文件就可以搞定的时代。与此同时的，对于一个大型的应用，前端开发团队往往也不再是一两个人。随着项目与团队规模的扩大，甚至是项目过程中人员的变动，如何更好进行代码开发的管理已经成为了一个重要问题。用CSS实现一些样式往往并不是最困难的所在，难的是使用一套合理的CSS架构来支持团队的合作与后续的维护。\r\n\r\n> What we want is to be able to write code that is as transparent and self-documenting as possible. \r\n\r\n本系列文章会介绍一些业界在探索CSS模块化进程中提出的方案。在前两篇文章中，我介绍了[如果使用BEM与命名空间来规范与架构你的CSS](https://juejin.im/editor/posts/5b20e8e0e51d4506c60e47f5)以及[如何使用Webpack中的CSS modules](https://juejin.im/post/5b234e25e51d45588016caa0)。在这篇文章中，我会介绍styled-components这种CSS in JS方案，以及如何在React中使用。\r\n\r\n## 2. styled-components是什么\r\n随着React等前端技术的不断流行，组件化的思想开始受到越来越多的人重视。以组件为中心的开发思路使得各种 css-in-js 实践出现。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f75d0bed9f5?w=1240&h=443&f=png&s=159913)![](https://user-gold-cdn.xitu.io/2018/6/15/16401f75d0f08cdb?w=1240&h=59&f=png&s=30399)\r\n\r\n💅styled-components，就是这些方案中的一种。它既具备了 css-in-js 的模块化与参数化的优点，又完全使用CSS的书写习惯，不会引起额外的学习成本。这些优点都是它渐渐流行的原因。\r\n\r\n如果你正在学习或使用React技术栈，就非常有必要了解一下💅styled-components了。接下来的部分，就会带着你迅速了解styled-components在React中的一些基本使用方式与使用场景。\r\n\r\n> P.S. 最新版 (v3.1.0) 的styled-components在SSR上有了极大的性能提升: you can now use streaming server-side rendering with styled-components -- [v3.1.0: A massive performance boost and streaming server-side rendering support](https://medium.com/styled-components/v3-1-0-such-perf-wow-many-streams-c45c434dbd03)\r\n\r\n## 3. 在react中使用styled-components\r\n### 3.1. 基本用法\r\n那么，如何在我们的react项目中使用styled-components呢？\r\n官网上有一句话非常形象：\r\n> It removes the mapping between components and styles. This means that **when you're defining your styles, you're actually creating a normal React component**, that has your styles attached to it.\r\n\r\n简单来说，就是在你使用styled-components进行样式定义的同时，你也就创建了一个React组件。来先看一下它基本语法：\r\n\r\n```javascript\r\nimport styled from 'styled-components';\r\n\r\nconst ListWrap = styled.ul`\r\n    margin: 0;\r\n    padding: 0;\r\n`;\r\n\r\nconst Item = styled.li`\r\n    margin: 10px 0;\r\n    padding: 5px 15px;\r\n    border-left: 3px solid #333;\r\n    font-size: 16px;\r\n    list-style: none;\r\n    font-weight: bold;\r\n`;\r\n```\r\n\r\n上面这段代码，其实就是定义了一个`li`元素的各种样式信息（边距、边框、字体等等）。是不是和直接在`.css`文件中直接写css很像？\r\n\r\n注意，当我们将这个`styled`的`li`元素赋给了`Item`这个变量时，我们也就创建了一个叫`Item`的React组件。因此，我们可以在JSX中直接使用`Item`\r\n\r\n```javascript\r\nimport React, {Component} from 'react';\r\n\r\nexport default class List extends Component {\r\n    render() {\r\n        return (\r\n            <ListWrap>\r\n                <Item>这是一条普通的记录</Item>\r\n                <Item>这也是一条普通的记录</Item>\r\n            </ListWrap>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f75d1061a6b?w=887&h=102&f=png&s=10712)\r\n\r\n是不是非常方便？\r\n\r\n如果你对ES6熟悉的话，也许已经发现了，在使用`styled`设置css样式的语法里，用到了模板字符串。因此，对于样式，我们完全可以加入变量计算。更进一步的，我们可以通过获取React组件的`props`来更改相应的css属性：\r\n\r\n```javascript\r\nconst Item = styled.li`\r\n    margin: 10px 0;\r\n    padding: 5px 15px;\r\n    border-left: 3px solid #333;\r\n    font-size: 16px;\r\n    list-style: none;\r\n    font-weight: bold;\r\n    text-decoration: ${props => props.underline ? 'underline' : 'none'};\r\n`;\r\n\r\nexport default class List extends Component {\r\n    render() {\r\n        return (\r\n            <ListWrap>\r\n                <Item>这是一条普通的记录</Item>\r\n                <Item>这也是一条普通的记录</Item>\r\n                <Item underline>这条记录有一条下划线</Item>\r\n            </ListWrap>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f75d150a951?w=882&h=143&f=png&s=15112)\r\n\r\n\r\n这一语法也是styled-components工作的核心之一。原因在于，使用模板字符串时，下面这两行代码是等价的：\r\n\r\n```javascript\r\nfunc`I love ${some_lib} & styled-component`\r\nfunc(['I love ',  '  & styled-component'], some_lib)\r\n```\r\n\r\n如果想具体了解，可以看文末的参考链接。\r\n\r\n### 3.2. 扩展已有样式\r\n有些时候，我们想要在已有的组件样式基础上，添加一些其他的样式属性，从而创建一个新的组件。\r\n\r\n例如，对于上一节中的`Item`组件，我们想要在此基础上，创建一个红底白字的新Item样式，但是其他属性（字体、边距等）保持一致。使用styled-components的`styled`方法可以很容易实现：\r\n\r\n```javascript\r\nconst RedItem = styled(Item)`\r\n    color: #fff;\r\n    background: #991302;\r\n`;\r\n\r\nexport default class List extends Component {\r\n    render() {\r\n        return (\r\n            <ListWrap>\r\n                <Item>这是一条普通的记录</Item>\r\n                <Item>这也是一条普通的记录</Item>\r\n                <Item underline>这条记录有一条下划线</Item>\r\n                <RedItem>这是一条红色的记录</RedItem>\r\n            </ListWrap>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f75d1469309?w=917&h=186&f=png&s=19708)\r\n\r\n是不是非常简单？这里需要一提的是，对于`styled.li`这种书写模式，实际上和`styled('li')`是等价的，只是一种方法的别名而已。\r\n\r\n### 3.3. 样式继承\r\n实际上，在styled-components中，对于组件的样式继承可以使用`extend`方法。因此，对于上一小节中的`RedItem`组件，我们也完全可以使用`extend`方法来实现：\r\n\r\n```javascript\r\nconst RedItem = Item.extend`\r\n    color: #fff;\r\n    background: #991302;\r\n`;\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f75d1374bb6?w=669&h=228&f=png&s=27091)\r\n\r\n在这个例子中，在css部分的代码是一样的。那么`extend`和`styled`两者有什么区别呢？官网上有一句话解释的非常清楚：\r\n> The styled() factory **generates new component styles with a new class**. Calling extend creates new component styles by extending the old one, and thus **doesn't generate two classes for a single component**. (styled() factory does that)\r\n\r\n怎么理解这句话呢？我们如果去审查页面元素，就会发现区别：\r\n`styled`方法会创建一个新的类`.iVuaxi`来应用这两行样式，而Item本身的样式依旧存在于`.bWdYgn`类中；\r\n而使用`extend`方法后则会在`.fYpJfw`类中实现所有的样式，并不会创建两个css类。\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f7659bb8714?w=540&h=124&f=png&s=46342)\r\n\r\n那么，什么时候使用`extend`方式，什么时候使用`styled`方式呢？styled-components官方推荐尽量去使用`extend`方式。当该react组件不是一个styled-components组件时，使用`styled`方式。\r\n\r\n### 3.4.修改标签类型\r\n除了需要继承组件样式外，有时候，我们可能想要更换该组件的HTML标签。例如按钮，我们已经有了一个button组件的样式，想要再创造一个一样的a标签按钮。这时候，我们就可以使用`withComponent`方法：\r\n\r\n```javascript\r\n// 使用withComponent方法修改标签类型\r\nconst DivItem = Item.withComponent('div');\r\n\r\nexport default class List extends Component {\r\n    render() {\r\n        return (\r\n            <ListWrap>\r\n                <Item>这是一条普通的记录</Item>\r\n                <Item>这也是一条普通的记录</Item>\r\n                <Item underline>这条记录有一条下划线</Item>\r\n                <RedItem>这是一条红色的记录</RedItem>\r\n                <ExtendedItem>这条记录使用了‘extend’</ExtendedItem>\r\n                <DivItem>这实际上是个div </DivItem>\r\n            </ListWrap>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f765fcc94dc?w=909&h=279&f=png&s=31427)\r\n\r\n### 3.5. 添加动画keyframes\r\n当然，styled-components作为一个组件样式方面的工具，肯定不会漏掉css3中的重要功能——动画。我们完全可以在使用styled-components创建的组件中，设置相应的css3动画。不过和之前稍有不同的是，我们还需要从styled-components库中导出一个`keyframes`方法。\r\n\r\n下面，我们就来创建一个带有动画的Item。首先，使用keyframes方法创建css3动画\r\n\r\n```javascript\r\nimport styled, {keyframes} from 'styled-components';\r\n\r\nconst MyAnimation = keyframes`\r\n    from {\r\n        padding-left: 0;\r\n        background: #991302;\r\n    }\r\n\r\n    to {\r\n        padding-left: 50px;\r\n        background: #009317;\r\n    }\r\n`;\r\n```\r\n\r\n然后，使用继承的方式，创建一个带动画的组件\r\n\r\n```javascript\r\nconst AnimateItem = RedItem.extend`\r\n    animation: ${MyAnimation} 2s linear infinite alternate;\r\n`;\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f7659c340eb?w=909&h=308&f=gif&s=53736)\r\n\r\n### 3.6. 全局样式\r\n有些时候，在开发中需要设置一些全局的样式，这个该怎么处理呢？典型的，当我们想要为`body`元素设置一些属性时，该怎么办呢？\r\n\r\n别担心，styled-components提供了`injectGlobal`方法来实现它。调用`injectGlobal`并不会返回一个组件，而是会将`injectGlobal`中的css相关样式直接添加到`<style>`标签内部。同样的，需要导出`injectGlobal`方法：\r\n\r\n```javascript\r\nimport styled, {keyframes, injectGlobal} from 'styled-components';\r\n\r\ninjectGlobal`\r\n    body {\r\n        border: 5px solid #991302;\r\n        background: #ddd;\r\n    }\r\n`;\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/6/15/16401f766fa6d723?w=911&h=374&f=png&s=37539)\r\n\r\n如果我们去看页面输出的话，可以看到这一段样式：![](https://user-gold-cdn.xitu.io/2018/6/15/16401f767381a83f?w=679&h=66&f=png&s=22877)这就是我们设置全局样式后的输出。\r\n\r\n## 4. 使用styled-components的一些优点\r\n\r\n使用styled-components来进行React技术栈的开发有许多优势，这里总结了一篇[post](https://medium.com/@jamiedixon/styled-components-production-patterns-c22e24b1d896)里的一些观点：\r\n1. 压缩你的样式代码（Compressed Styles）。使用styled-components可以有效简化部分样式的编写。\r\n1. 写出更清爽的JSX代码（Clearer JSX）。![原先的JSX](https://user-gold-cdn.xitu.io/2018/6/15/16401f767ed1bf08?w=1240&h=521&f=png&s=179379)![使用styled-components后的JSX](https://user-gold-cdn.xitu.io/2018/6/15/16401f76734dc323?w=1240&h=587&f=png&s=160107)\r\n1. 实现样式的组合与继承（Composing Styles）\r\n1. 属性过滤（Prop filtering）。styled-components会通过白名单的方式过滤无效的属性。\r\n\r\n## 5. 完善你的styled-components开发环境\r\n### 5.1. vs code插件\r\n工欲善其事，必先利其器。如果你使用vs code进行开发，可以很方便地安装styled-components插件：vscode-styled-components。该插件会进行语法与智能提示，提高我们的开发效率。![使用vscode-styled-components插件前](https://user-gold-cdn.xitu.io/2018/6/15/16401f76848f1d65?w=580&h=161&f=png&s=25835)![使用vscode-styled-components插件后](https://user-gold-cdn.xitu.io/2018/6/15/16401f76a42d5ecd?w=583&h=160&f=png&s=27394)\r\n\r\n### 5.2. stylelint\r\n如果你在使用styled-components的同时，也使用了stylelint来进行css检查，那么你很可能会遇到一些问题。因为styled-components会导致代码不符合某些检查规则。\r\n\r\n为了解决这个问题，styled-components提供了一个叫stylelint-config-styled-components的包来调整stylelint中的某些规则检查。你可以在你的`.stylelintrc`文件中添加配置：`\"processors\": [\"stylelint-processor-styled-components\"]`。这样你就可以继续使用stylelint了。具体配置方式可以参考[这里](https://www.styled-components.com/docs/tooling#stylelint)。\r\n\r\n## 参考资料\r\n\r\n> 想了解CSS模块化相关内容，可以看看\r\n> - [【CSS模块化之路1】使用BEM与命名空间来规范CSS](https://github.com/alienzhou/blog/issues/14)\r\n> - [【CSS模块化之路2】webpack中的Local Scope](https://github.com/alienzhou/blog/issues/15)\r\n\r\n如果你对文中提到一些点感兴趣，也可以在这里进一步阅读相关资料。\r\n- [The magic behind 💅 styled-components](https://mxstbr.blog/2016/11/styled-components-magic-explained/): 介绍了模板字符串对styled-components的重要作用\r\n- [💅 styled components 💅 — Production Patterns](https://medium.com/@jamiedixon/styled-components-production-patterns-c22e24b1d896): 使用styled components的一些优点\r\n- [A 5-minute Intro to Styled Components](https://medium.freecodecamp.org/a-5-minute-intro-to-styled-components-41f40eb7cd55)\r\n- [vs code下的💅styled-components插件](https://marketplace.visualstudio.com/items?itemName=jpoissonnier.vscode-styled-components)\r\n- [v3.1.0: A massive performance boost and streaming server-side rendering support](https://medium.com/styled-components/v3-1-0-such-perf-wow-many-streams-c45c434dbd03)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/15","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/15/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/15/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/15/events","html_url":"https://github.com/alienzhou/blog/issues/15","id":390634233,"node_id":"MDU6SXNzdWUzOTA2MzQyMzM=","number":15,"title":"【CSS模块化之路2】webpack中的Local Scope","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845018,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE4","url":"https://api.github.com/repos/alienzhou/blog/labels/CSS","name":"CSS","color":"7057ff","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T11:23:57Z","updated_at":"2018-12-13T11:23:57Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"CSS是一门几十分钟就能入门，但是却需要很长的时间才能掌握好的语言。它有着它自身的一些复杂性与局限性。其中非常重要的一点就是，本身不具备真正的模块化能力。\r\n\r\n## 1. 面临的问题\r\n你可能会说，CSS有`@import`功能。然而，我们都知道，这里的`@import`仅仅是表示引入相应的CSS文件，但其模块化核心问题并未解决——CSS文件中的任何一个选择器都会作用在整个文档范围里。\r\n\r\n因此，其实我们面临的最大问题就是——所有的选择器都是在一个全局作用域内的。一旦引入一个新的CSS文件，就有着与预期不符的样式表现的风险（因为一些不可预测的选择器）。\r\n\r\n而如今的前端项目规模越来越大，已经不是过去随便几个css、js文件就可以搞定的时代。与此同时的，对于一个大型的应用，前端开发团队往往也不再是一两个人。随着项目与团队规模的扩大，甚至是项目过程中人员的变动，如何更好进行代码开发的管理已经成为了一个重要问题。\r\n\r\n回想一下，有多少次：\r\n- 我们讨论着如何对class进行有效的命名，以避免协作开发时的冲突；\r\n- 我们面对一段别人写的css、html代码，想要去修改，然后疯狂查找、猜测每个类都是什么作用，哪些是可以去掉的，哪些是可以修改的——到最后我们选择重新添加一个新的class；\r\n- 我们准备重构代码时，重构也就成了重写\r\n- ……\r\n\r\n用CSS实现一些样式往往并不是最困难的所在，难的是使用一套合理的CSS架构来支持团队的合作与后续的维护。\r\n\r\n> What we want is to be able to write code that is as transparent and self-documenting as possible. \r\n\r\n本系列文章会介绍一些业界在探索CSS模块化进程中提出的方案。再上一篇文章里我们介绍了[如何使用BEM和命名空间来规范与架构我们的CSS](https://juejin.im/post/5b20e8e0e51d4506c60e47f5)。这一篇文章主要介绍了，如何在webpack中使用一种类似“CSS模块化”的解决方案———Local Scope，来规避一些开发中的问题。\r\n\r\n## 2. 什么是Local Scope\r\n通常来说，CSS中的所有选择器可以算是“全局作用域”。而“Local Scope”顾名思义，使CSS具有类似于局部作用域的能力，同时搭配类似JavaScript中模块化的写法，到达CSS模块化的效果。\r\n\r\n这么说可能有些抽象，我们可以来看一个例子。\r\n\r\n在webpack中引入css往往是这样的：\r\n\r\n```\r\n// index.css\r\n.title {\r\n    font-size: 30px;\r\n    color: #333;\r\n}\r\n\r\n// index.js\r\nimport './index.css';\r\n\r\nfunciont createTitle(str) {\r\n    var title = document.createElement('h1');\r\n    title.appendChild(document.createTextNode(str));\r\n    title.setAttribute('class', 'title');\r\n    document.body.appendChild(title);\r\n}\r\n\r\ncreateTitle('Hi!');\r\n```\r\n\r\n由于，webpack中将js、css、png等这些资源都视为模块，所以可以通过import导入。但是，实际上，对于导入的所有css，其“地位”都是平等的，都是在全局有效的。例如：\r\n\r\n```\r\n// index.css\r\n.title {\r\n    font-size: 30px;\r\n    color: #333;\r\n}\r\n\r\n// other.css\r\n.title {\r\n    font-size: 15px;\r\n    color: #999;\r\n}\r\n\r\n// index.js\r\nimport './index.css';\r\nimport './other.css';\r\n\r\nfunciont createTitle(str) {\r\n    var title = document.createElement('h1');\r\n    title.appendChild(document.createTextNode(str));\r\n    title.setAttribute('class', 'title');\r\n    document.body.appendChild(title);\r\n}\r\n\r\ncreateTitle('Hi!');\r\n```\r\n\r\n当我们引入了新的CSS文件other.css后，其中的`.title`和index.css中的`.title`有着同样的“作用域”——全局。\r\n\r\n回想一下在JavaScript中：\r\n\r\n```\r\n// a.js\r\nvar a = 1;\r\n\r\n// other.js\r\nvar a = 2;\r\n\r\n// index.html\r\n<script src=\"./a.js\"></script>\r\n<script src=\"./other.js\"></script>\r\n<script>\r\n    console.log(a); // 2\r\n</script>\r\n```\r\n\r\n如果某个html页面通过`script`标签引入这两js文件，那么a的值必定会有冲突，其中一个会被覆盖。如果使用模块化的方式，可以变成：\r\n\r\n```javascript\r\n// a.js\r\nexport var a = 1;\r\n\r\n// other.js\r\nexport var a = 2;\r\n\r\n// app.js\r\nimport {a} from './a';\r\nimport {a as other} from './other';\r\n\r\nconsole.log(a); // 1\r\nconsole.log(a); // 2\r\n```\r\n\r\n而所谓的Local Scope就是webpack中在CSS上针对这种问题的一个解决方案。类似JavaScript的模块化，通过对CSS文件进行模块引用与导出的方式，能够在开发时，更有效得控制各个class的作用范围。\r\n\r\n## 3. 使用方法\r\n首先，需要在webpack中对`css-loader`进行一定的配置。\r\n\r\n```javascript\r\n// loader: 'css-loader',\r\n// options: {\r\n//     modules: true,\r\n//     localIdentName: '[local]__[name]--[hash:base64:5]'\r\n// }\r\nconst config = {\r\n    entry: './src/index.js',\r\n    output: {\r\n        path: path.resolve(__dirname, 'dist'),\r\n        filename: 'bundle.js'\r\n    },\r\n    module: {\r\n        rules: [{\r\n            test: /\\.css$/,\r\n            use: [{\r\n                loader: 'style-loader'\r\n            }, {\r\n                loader: 'css-loader',\r\n                options: {\r\n                    modules: true,\r\n                    localIdentName: '[local]__[name]--[hash:base64:5]'\r\n                }\r\n            }]\r\n        }]\r\n    }\r\n};\r\n```\r\n\r\n然后，我们还是使用前一节例子中的那个场景：\r\n\r\n```\r\n// index.css\r\n:local .title {\r\n    font-size: 30px;\r\n    color: #333;\r\n}\r\n\r\n// other.css\r\n:local .title {\r\n    font-size: 15px;\r\n    color: #999;\r\n}\r\n\r\n// index.js\r\nimport styles from './index.css';\r\nimport others from './other.css';\r\n\r\nfunciont createTitle(str) {\r\n    var title = document.createElement('h1');\r\n    title.appendChild(document.createTextNode(str));\r\n    // styles.title  font-size: 30px;color: #333;\r\n    title.setAttribute('class', styles.title);\r\n    document.body.appendChild(title);\r\n}\r\n\r\ncreateTitle('Hi!');\r\n```\r\n\r\n其中需要注意的有三个地方：\r\n- 第一个是在CSS文件中的，类选择器前多了`:local`这个语法。通过添加`:local`就可以指示webpack，这不是一个“全局”的选择器（当然，实际上也是全局的，后面会简单解释）。\r\n- 第二个地方是在js文件中，将`import 'index.css'`变为了`import styles from './index.css'`。是不是看着很熟悉，没错，和JavaScript中的模块化方案用法一样。\r\n- 第三个地方，在使用到该class的地方，由原来的`title.setAttribute('class', ‘title’)`变为了`title.setAttribute('class', styles.title)`。这样我们可以选择在一部分dom元素上使用`styles.title`，即`index.css`的样式；在另一部分dom元素上使用`other.css`的样式。\r\n\r\n这样就解决了我们之前提到的问题。\r\n\r\n当然，有些时候，我们希望类选择器中的某一部分仍然是“全局”的，那么我们可以这么写：\r\n\r\n```css\r\n:local .title :global(.sub-title) { color: #666; }\r\n```\r\n\r\n## 4. 关于Local Scope\r\n虽然我们上面说了这么多次的“模块化”、“作用域”、“全局”，然而，实际上，对于CSS这门语言来说，它在自己本身的逻辑上是不具备这些特点的。而webpack中Local Scope的相关方案，其实也并不是（CSS本身逻辑支持的）真正意义上所谓的模块化。所以很多地方我都打上了引号。\r\n\r\n如果对着打包后的页面，打开chrome控制台，会发现，我们的html是这个样子的\r\n\r\n```\r\n<body>\r\n    <h1 class=\"title__index--330EV\">Hi!</h1>\r\n</body>\r\n```\r\n\r\n`h1`标签的`class`并不是我们在CSS中所写的`title`，而是一串奇怪的字符串`title__index--330EV`。\r\n\r\n当使用webpack进行打包时，由于检查到`:local`这个语法，因此会为`.title`这个class生成一个新的class名称，而我们在js文件中所使用的`styles.title`对应的就是这个新的classname。\r\n\r\n所以可以理解，其实当前的CSS语法逻辑中中并没有实际意义上所谓的local scope，但是，通过webpack打包时的操作，我们会为每个`:local`的class生成一个唯一的名称，而我们使用样式实际是指向了这个classname。这就实现了两个CSS文件中，相同名称的class在使用时就不会有冲突了，相当于避开了“全局作用域”。\r\n\r\n如果打开打包后的`bundle.js`,我们可以发现一段很有趣的代码\r\n\r\n```javascript\r\n// ……其余省略\r\n// exports\r\nexports.locals = {\r\n    \"title\": \"title__index--330EV\"\r\n};\r\n\r\n// ……其余省略\r\n// exports\r\nexports.locals = {\r\n    \"title\": \"title__other--3vRzX\"\r\n};\r\n```\r\n\r\n这是在两个不同的模块内的部分。上面一个就是导出的`index.css`中对应的classname，下面一个就是`other.css`的。通过`styles.title`就可以引用到`title__index--330EV`这个实际值。\r\n\r\n最后，再来说一下`title__index--330EV`这个值得由来。在上一节的一开始，我们对webpack进行了配置，其中有一行\r\n\r\n```javascript\r\nlocalIdentName: '[local]__[name]--[hash:base64:5]'\r\n```\r\n\r\n其实就是指示了唯一标识的命名方式：`local`是class的名称，`name`是文件的名称，而最后加上`hash`值。当然，你完全可以使用其他你喜欢的方式。默认是使用`[hash:base64]`。\r\n\r\n## 5. 写在最后\r\n其实webpack中的CSS模块化方案Local Scope，粗浅的来说也是通过生成唯一的classname来避免冲突，控制作用范围。只是和BEM不同，BEM是一个建议标准，更多的还是人为的操控，而webpack中的Local Scope则提供了一个完整的模块化与打包方案。在一定程度上提高了开发的效率，降低了错误率。","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/14","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/14/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/14/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/14/events","html_url":"https://github.com/alienzhou/blog/issues/14","id":390633994,"node_id":"MDU6SXNzdWUzOTA2MzM5OTQ=","number":14,"title":"【CSS模块化之路1】使用BEM与命名空间来规范CSS","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845018,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE4","url":"https://api.github.com/repos/alienzhou/blog/labels/CSS","name":"CSS","color":"7057ff","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T11:23:17Z","updated_at":"2018-12-13T11:23:17Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"CSS是一门几十分钟就能入门，但是却需要很长的时间才能掌握好的语言。它有着它自身的一些复杂性与局限性。其中非常重要的一点就是，本身不具备真正的模块化能力。\r\n\r\n## 1. 面临的问题\r\nCSS中虽然有`@import`功能。然而，我们都知道，这里的`@import`仅仅是表示引入相应的CSS文件，但其模块化核心问题并未解决——CSS文件中的任何一个选择器都会作用在整个文档范围里。\r\n\r\n因此，其实我们面临的最大问题就是——所有的选择器都是在一个全局作用域内的。一旦引入一个新的CSS文件，就有着与预期不符的样式表现的风险（因为一些不可预测的选择器）。\r\n\r\n而如今的前端项目规模越来越大，已经不是过去随便几个css、js文件就可以搞定的时代。与此同时的，对于一个大型的应用，前端开发团队往往也不再是一两个人。随着项目与团队规模的扩大，甚至是项目过程中人员的变动，如何更好进行代码开发的管理已经成为了一个重要问题。\r\n\r\n回想一下，有多少次：\r\n- 我们讨论着如何对class进行有效的命名，以避免协作开发时的冲突；\r\n- 我们面对一段别人写的css、html代码，想要去修改，然后疯狂查找、猜测每个类都是什么作用，哪些是可以去掉的，哪些是可以修改的——到最后我们选择重新添加一个新的class；\r\n- 我们准备重构代码时，重构也就成了重写\r\n- ……\r\n\r\n用CSS实现一些样式往往并不是最困难的所在，难的是使用一套合理的CSS架构来支持团队的合作与后续的维护。\r\n\r\n> What we want is to be able to write code that is as transparent and self-documenting as possible. \r\n\r\n本系列文章会介绍一些业界在探索CSS模块化进程中提出的方案。本篇主要会讲解BEM方法论，并将其与CSS命名空间结合。\r\n\r\n## 2. BEM命名方法论\r\n\r\nBEM其实是一种命名的规范。或者说是一种class书写方式的方法论（methodology）。BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由[Yandex](http://yandex.ru/)团队提出的一种前端命名方法论。在具体CSS类选择器上的表现就像下面这样\r\n\r\n```css\r\n.block {}\r\n.block__element {}\r\n.block--modifier {}\r\n.block__element--modifier {}\r\n```\r\n\r\n其中，block表示的是独立的分块或组件；element表示每个block中更细粒度的元素；modifier则通常会用来表示该block或者element不同的类型和状态。\r\n\r\n举个例子，例如我们有一个列表\r\n\r\n```html\r\n<ul class=\"list\">\r\n  <li class=\"item\">learn html</li>\r\n  <li class=\"item underline\">learn css</li>\r\n  <li class=\"item\">learn js</li>\r\n</ul>\r\n```\r\n\r\n列表容器的class为`.list`，列表内每条记录的class为`.item`，其中，还为第二个条记录添加了一个下划线`.underline`。简单的css如下\r\n\r\n```css\r\n.list {\r\n  margin: 15px;\r\n  padding: 0;\r\n}\r\n.list .item {\r\n  margin: 10px 0;\r\n  border-left: 3px solid #333;\r\n  font-size: 15px;\r\n  color: #333;\r\n  list-style: none;\r\n}\r\n.list .underline {\r\n  color: #111;\r\n  text-decoration: underline;\r\n}\r\n```\r\n\r\n这样的命名方式，我们在阅读html时并不能迅速了解：`.item`是只能在`.list`中使用么，它是仅仅定义在这个组件内的一部分么？`.underline`是一个通用样式么，我想修改列表的中underline的记录为红色，这会影响到项目其他地方么？\r\n\r\n这时候，我们就可以使用BEM方式来命名我们的class\r\n\r\n```css\r\n.list {\r\n  margin: 15px;\r\n  padding: 0;\r\n}\r\n.list__item {\r\n  margin: 10px 0;\r\n  border-left: 3px solid #333;\r\n  font-size: 15px;\r\n  color: #333;\r\n  list-style: none;\r\n}\r\n.list__item--underline {\r\n  color: #111;\r\n  text-decoration: underline;\r\n}\r\n```\r\n\r\n```html\r\n<ul class=\"list\">\r\n  <li class=\"list__item\">learn html</li>\r\n  <li class=\"list__item list__item--underline\">learn css</li>\r\n  <li class=\"list__item\">learn js</li>\r\n</ul>\r\n```\r\n\r\n这段代码的一大优势就是增加了它的自解释性：一定程度上，它的class名本身就是一个简易的文档。\r\n\r\n这里还需要避免一个误区，BEM命名规范里，我们的CSS并不会关心HTML中dom元素的层级结构。它的核心着眼点还是我们定义的块（block）、元素（element）、修饰符（modifier）这三部分。因为关注点不同，所以一个block内的所有element，在CSS中并不会考虑层级，因此也就没有`.list__item__avatar`这种写法\r\n\r\n```html\r\n<ul class=\"list\">\r\n  <li class=\"list__item\">\r\n    ![](avatar.png)\r\n    learn html\r\n  </li>\r\n  <li class=\"list__item list__item--underline\">learn css</li>\r\n  <li class=\"list__item\">learn js</li>\r\n</ul>\r\n```\r\n\r\n而是把这个`img`也看作block中的元素`.list__avatar`\r\n\r\n```html\r\n<ul class=\"list\">\r\n  <li class=\"list__item\">\r\n    ![](avatar.png)\r\n    learn html\r\n  </li>\r\n  <li class=\"list__item list__item--underline\">learn css</li>\r\n  <li class=\"list__item\">learn js</li>\r\n</ul>\r\n```\r\n\r\n从这个例子看一看出，CSS部分并不关心dom层级结构，而是在block下面有哪些element，这些element又有哪些modifier。\r\n\r\n基于这个思想，我们可以知道，如果一个block里面含有其他block并不会违反BEM的原则。例如上面这个列表的例子，其中头像avatar原本只是一个简单的element，现在如果变成了一个很复杂的组件——包括图片、姓名和标签，那么可能会有这么一个block\r\n\r\n```html\r\n<ul class=\"list\">\r\n  <li class=\"list__item\">\r\n    <div class=\"list__avatar\">\r\n      <img class=\"list__head list__head--female\" />\r\n      <span class=\"list__name\"></span>\r\n      <span class=\"list__tag\"></span>\r\n    </div>\r\n    learn html\r\n  </li>\r\n  <li class=\"list__item list__item--underline\">learn css</li>\r\n  <li class=\"list__item\">learn js</li>\r\n</ul>\r\n```\r\n\r\n我们可以为avatar创建一个新的block\r\n\r\n```html\r\n<ul class=\"list\">\r\n  <li class=\"list__item\">\r\n    <div class=\"avatar\">\r\n      <img class=\"avatar__head avatar__head--female\" />\r\n      <span class=\"avatar__name\"></span>\r\n      <span class=\"avatar__tag\"></span>\r\n    </div>\r\n    learn html\r\n  </li>\r\n  <li class=\"list__item list__item--underline\">learn css</li>\r\n  <li class=\"list__item\">learn js</li>\r\n</ul>\r\n```\r\n\r\n那么你可能会有疑问，什么时候需要在将一个elment重新抽象为新的block呢？仅仅当我们的dom元素变得很多的时候么？\r\n\r\n其实，BEM中的block一定程度上可以理解为一个“独立的块”。独立就意味着，把这一部分放到其他部分也可以正常展示与使用，它不会依赖其父元素或兄弟元素。而在另一个维度上面来说，也就是视觉设计的维度，当UI设计师给出UI稿后，其中的一些设计元素或组件会重复出现，这些部分也是可以考虑的。所以理解UI设计稿并不是指简单的还原，其中的设计原则与规范也值得揣摩。\r\n\r\n从上面的简单介绍可以看出，BEM有着一些优点\r\n\r\n- class的单一职责原则、开闭原则\r\n- 模块化思想，一般来说遵循这个方法的组件可以迁移环境\r\n- 一定程度上，避免命名的污染\r\n- 自解释性。可以直观看出各个class之间的依赖关系以及它们的作用范围（`.list__item`和`.list__item--underline`都是依赖于`.list`的，因此它们不能脱离于`.list`存在）\r\n\r\n当然，BEM仅仅是一种命名规范或建议。在没有约束的情况下，你随时都可以违反。所以我们可以借助类似BEM-constructor的工具，既帮我们进行一定的约束，同时也省去一些繁琐的重复工作。在介绍BEM-constructor之前，我们还需要简单了解一下BEM-constructor中命名空间（namespaces）的基本概念。\r\n\r\n## 3. 约定项目的命名空间（namespaces）\r\n\r\n命名空间（namespaces）也是一种关于CSS中class命名方式的规范。[《More Transparent UI Code with Namespaces》](https://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/)提供了一种命名空间的规范。在BEM的基础上，建立命名空间主要是为了进一步帮助我们：\r\n- 让代码能够自解释\r\n- 在一个全局的context中安全地加入一个新的class\r\n- 确保一个修改不会产生额外的副作用\r\n- 在后期维护时能够迅速定位问题\r\n\r\n命名空间分为以下几种。\r\n\r\n### Object: o-\r\n\r\n当你使用面向对象的CSS（Object-Oriented CSS）时，`o-`这个namespace将会非常有用。\r\n\r\n- 对象是一个抽象的概念。\r\n- 尽量避免修改它们的样式。\r\n- 如果要使用`o-`时请慎重考虑。\r\n\r\n### Component: c-\r\n\r\n`c-`应该是一个更为常见的namespace，表示Components（组件）。\r\n```css\r\n.c-list {}\r\n.c-avatar {}\r\n```\r\n从命名中我们就能知道：这是一个list组件；或者这是一个avatar组件。\r\n\r\n- Components应该是一组具体的UI。`c-`代表一个具体的组件。\r\n- 修改它们非常安全，只会对组件产生影响。\r\n\r\n### Utility: u-\r\n\r\nUtilities符合单一职责原则，实现一个具体的功能或效果。其概念有些类似JavaScript中的通用工具方法。例如一个清除浮动的Utility，或者一个文字居中的Utility。\r\n```css\r\n.u-clearfix {}\r\n.u-textCenter {}\r\n```\r\n由于Utilities作为一组工具集，在样式上具有更强的“话语权”，所以`!important`在Utilities中会更为常见。当我们看到下面这段HTML，我们会更加确信，这个大号的字体是`.u-largeFont`这个样式引起的。\r\n```java\r\n<h1 class=\"title u-largeFont\">namespace</h1>\r\n```\r\n\r\n- Utilities中的样式一般具有更高的权重.\r\n- 不要滥用`u-`前缀，只用在一些通用的工具方法上.\r\n\r\n### Theme: t-\r\n\r\n当我们使用Stateful Themes这种定义主题的方式时（后续有机会会介绍一些“自定义主题”的方式），往往我们会在最外层容器元素中加入一个代表不同主题的class。这里就会用到`t-`。\r\n\r\n- 主题`t-`是一个高层级的命名空间。\r\n- 一定程度上它和下面的Scope一样，也为其内部的规则提供了一个作用空间。\r\n- 可以很明显地标识当前UI的总体状态（主题）。\r\n\r\n### Scope: s-\r\n\r\n`s-`可能不是这么好理解，因为CSS中并没有Scope这个概念（或者说只有一个全局的Scope）。而`s-`正是希望通过命名的方式来建立一个新的Scope。\r\n\r\n但是请勿滥用它，只有在你确实需要创建一个新的“作用域”的时候再使用它。例如一个简单场景：CMS。如果你接触过CMS你就会知道，它一定有一个生成或编辑内容的功能。而通常的，我们会将这部分编辑的内容输出到页面中，并在外部赋予一个新的Scope，用以隔离该部分与外部整个站点的样式。\r\n\r\n```html\r\n<nav class=\"c-nav-primary\">\r\n  ...\r\n</nav>\r\n\r\n<section class=\"s-cms-content\">\r\n  <h1>...</h1>\r\n  <p>...</p>\r\n  <ul>\r\n    ...\r\n  </ul>\r\n  <p>...</p>\r\n</section>\r\n\r\n<ul class=\"c-share-links\">\r\n  ...\r\n</ul>\r\n```\r\n\r\n```css\r\n.s-cms-content {\r\n  font: 16px/1.5 serif; /* [1] */\r\n  h1, h2, h3, h4, h5, h6 {\r\n    font: bold 100%/1.5 sans-serif; /* [2] */\r\n  }\r\n  a {\r\n    text-decoration: underline; /* [3] */\r\n  }\r\n}\r\n```\r\n\r\n`section`部分就是展示CMS中的content（内容）。\r\n\r\n- 首先，用到Scopes的场景确实非常的少，因此你准备使用时一定要仔细考虑\r\n- 它的实现是要依赖于嵌套方式的（SASS/LESS中），也可以说是CSS后代选择器\r\n\r\n慎用，需要万分小心。\r\n\r\n## 4. 在SASS中使用BEM-constructor\r\n\r\nBEM-constructor是基于SASS的一个工具。使用BEM-constructor可以帮助规范并快速地创建符合BEM与namespace规范的class。BEM-constructor的语法非常简单。\r\n\r\n```shell\r\nnpm install sass-bem-constructor --save-dev\r\n```\r\n\r\n首先在SASS引入`@import 'bem-constructor';`，然后使用`@include block($name, $type) { ... }`创建block，其中`$name`是block的名字，`$type`是namespace的类型（`'object'`, `'component'`和`'utility'`）。类似得，使用`element($name...)`和`modifier($name...)`可以快速生成block中的其他部分。\r\n\r\n将最初的例子进行改写\r\n\r\n```css\r\n@import 'sass-bem-constructor/dist/_sass-bem-constructor.scss';\r\n\r\n@include block('list', 'component') {\r\n    margin: 15px;\r\n    padding: 0;\r\n    @include element('item') {\r\n        margin: 10px 0;\r\n        border-left: 3px solid #333;\r\n        font-size: 15px;\r\n        color: #333;\r\n        list-style: none;\r\n        @include modifier('underline') {\r\n            color: #111;\r\n            text-decoration: underline;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n生成的内容如下\r\n\r\n```css\r\n.c-list {\r\n  margin: 15px;\r\n  padding: 0;\r\n}\r\n.c-list__item {\r\n  margin: 10px 0;\r\n  border-left: 3px solid #333;\r\n  font-size: 15px;\r\n  color: #333;\r\n  list-style: none;\r\n}\r\n.c-list__item--underline {\r\n  color: #111;\r\n  text-decoration: underline;\r\n}\r\n```\r\n\r\nBEM-constructor支持我们之前提到的各种命名空间。例如`theme($themes...)`，`scope($name)`等等。语法格式基本类似。\r\n\r\n此外，如果不想使用namespace，也可以手动关闭\r\n\r\n```css\r\n$bem-use-namespaces: false; // defaults to true\r\n```\r\n\r\n同时也支持更改命名空间的前缀名\r\n\r\n```css\r\n$bem-block-namespaces: (\r\n    'object': 'obj',     // defaults to 'o'\r\n    'component': 'comp', // defaults to 'c'\r\n    'utility': 'helper', // defaults to 'u'\r\n);\r\n```\r\n\r\n当然，如果你不喜欢BEM中的`__`，`--`的连接线，也可以自定义\r\n\r\n```css\r\n$bem-element-separator: '-'; // Defaults to '__'\r\n$bem-modifier-separator: '-_-_'; // Defaults to '--'\r\n```\r\n\r\n## 5. 写在最后\r\n\r\nBEM和namespace是一种命名规范，或者说是一种使用建议。他的目的是帮助我们写出更易维护与协作的代码，更多的是在代码规范的层面上帮助我们解决CSS模块化中的问题。然而，也不得不承认，它距离我们梦想中的CSS模块化还有这很长的距离。但是无论如何，其中蕴含的一些组件化与CSS结构组织方式的想法也是值得我们去思考的。\r\n\r\n## 参考资料\r\n\r\n- [More Transparent UI Code with Namespaces](https://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/)\r\n- [BEM I (finally) understand](https://m.alphasights.com/bem-i-finally-understand-b0c74815d5b0)\r\n- [BEMIT: Taking the BEM Naming Convention a Step Further](https://csswizardry.com/2015/08/bemit-taking-the-bem-naming-convention-a-step-further/)\r\n- [Immutable CSS](https://csswizardry.com/2015/03/immutable-css/)\r\n- [bem-constructor](https://github.com/danielguillan/bem-constructor)\r\n- [Battling BEM – 5 common problems and how to avoid them](https://medium.com/fed-or-dead/battling-bem-5-common-problems-and-how-to-avoid-them-5bbd23dee319)\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/13","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/13/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/13/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/13/events","html_url":"https://github.com/alienzhou/blog/issues/13","id":390633497,"node_id":"MDU6SXNzdWUzOTA2MzM0OTc=","number":13,"title":"一篇全面的CSS布局学习指南 [译]","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845018,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE4","url":"https://api.github.com/repos/alienzhou/blog/labels/CSS","name":"CSS","color":"7057ff","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T11:21:53Z","updated_at":"2018-12-13T11:22:14Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 本文来自SmashingMagazine上一篇非常不错的CSS布局综述类文章，汇总了各类CSS布局技术，并提供了这些技术深度阅读的链接。故而翻译过来和大家分享，原文链接在文末，感谢作者Rachel Andrew。\r\n\r\n## 引言\r\n\r\n无论你是一个想要学习CSS布局的新手，还是一个比较有经验但想要进一步巩固与了解最新CSS布局知识的前端开发者，这篇指南都能帮你全面了解如今CSS布局发展的现状。\r\n\r\n在过去的许多年中，正如翻天覆地的前端开发一般，CSS布局也产生了巨大的变化。现在我们有需要可选的CSS布局方式来开发我们的网站，这也就要求我们对这些方式作出选择。在这片文章里，我会介绍各种CSS布局的基本使用方式以及使用的目的。\r\n\r\n如果你还是CSS方面的新手并且想要了解什么是最好的布局方法，这篇文章正式你所需要的；当然，如果你是一位比较有经验的开发者，想要了解一些关于CSS布局的最新知识，这篇文章也不容错过。当然，我不会将各类技术的细枝末节都放到这篇文章里（否则可以写一本书了），而是对各类技术做一个基本的概述，同时会给大家提供相关链接来进一步学习。\r\n\r\n---\r\n\r\n## 1. 正常文档流（Normal Flow）\r\n\r\n如果你打开一个没有用任何CSS来改变页面布局的网页，那么网页元素就会排列在一个正常流（normal flow）之中。在正常流中，元素盒子（boxes）会基于文档的写作模式（writing mode）一个接一个地排列。这就意味着，如果你的写作模式是水平方向的（句子是从左到右或从右到左书写），正常流会垂直地一个接一个排列页面的块级元素。\r\n\r\n当然，如果你是在一个垂直方向的写作模式下，句子是垂直方向书写的，所以块级元素会水平方法排列。\r\n\r\n![Block and Inline Directions change with Writing Mode](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10965531f9?w=918&h=356&f=png&s=7810)\r\n\r\n正常流是一种最基础的布局：当你为文档应用了CSS、创建了某些CSS布局，你其实是让这些块做了一个正常文档流之外的“事”。\r\n\r\n### 1.1. 通过页面结构来发挥正常文档流的优势\r\n\r\n通过确保你书写的页面具有良好的页面结构（well-structured manner），你可以最大程度利用正常流所带来的优势。试想一下，如果浏览器中没有正常流，那么你创建的元素都会堆积在浏览器的右上角。这就意味着你必须指定所有的元素的布局方式。\r\n\r\n有了正常流，即使CSS加载失败了，用户仍然能阅读你的页面内容；同时，一些不使用CSS的工具（例如一些阅读器）会按照元素在文档中的位置来读取页面内容。从 可用性（accessibility） 角度来看，这无疑是非常有帮助的，同时也让开发者轻松了一些。如果你的内容顺序和用户预期的阅读顺序一致，你就不需要为了将元素调整到正确的位置而进行大量的布局调整。当你继续读下去会发现，使用新的布局方式是如何让页面布局事半功倍的。\r\n\r\n因此，在思考如何布局之前，你需要认真思考你的文档结构，以及你希望用户以何种顺序来阅读文档中的内容。\r\n\r\n### 1.2. 脱离正常文档流\r\n\r\n一旦你有了一个结构良好的页面，你就需要去决定如何利用它并将它变为我们需要的布局结构。这会涉及到 脱离正常文档流（moving away from normal flow），即本文后续的部分内容。我们有许多布局“利器”可以使用，其中第一个就是`float`，它是一个描述什么是脱离正常文档流的非常好的例子。\r\n\r\n---\r\n\r\n## 2. 浮动（Float）\r\n\r\n浮动被用来将盒子（box）置于左侧或右侧，同时让内容环绕其展示。\r\n\r\n要让一个元素进行浮动，需要为该元素设置一个值为`left`或`right`的`float`属性。默认值为`none`。\r\n\r\n```css\r\n.item {\r\n    float: left\r\n}\r\n```\r\n\r\n值得强调的是，当你使某个元素浮动并让文字环绕它时，内容的line box被截断了。如果你让一个元素浮动，同时为紧跟着的包含文本的元素设置一个背景色，你会发现背景色会出现在浮动元素下方。\r\n\r\n![The background color on the content runs under the float](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10966db934?w=1196&h=682&f=png&s=129387)\r\n\r\n如果你想要在浮动元素和环绕的文本之间创建边距，你需要给浮动元素设置外边距。在文本元素上设置外边距只会让其相对于容器缩进。例如在下面这个例子中，你就需要为左侧浮动的图片设置右边距和下边距。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10966e8ee5?w=1134&h=628&f=png&s=281065)\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"item\"></div>\r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra. Kohlrabi radish okra azuki bean corn fava bean mustard tigernut jícama green bean celtuce. </p>\r\n  <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n</div>\r\n```\r\n\r\n```CSS\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n}\r\n\r\n.item {\r\n  width: 100px;\r\n  height: 100px;\r\n  float: left;\r\n  margin: 0 20px 20px 0;\r\n  background-color: rgba(111,41,97,.3);\r\n}\r\n```\r\n\r\n### 2.1. 清除浮动\r\n\r\n一旦你对一个元素应用了浮动，所有接下来的元素都会环绕它直到内容处于它下方且开始应用正常文档流。如果你想要避免这种情况，可以手动去清除浮动。\r\n\r\n当你不想要某个元素受到其之前的浮动元素影响时，为其添加`clear`属性即可。使用`left`值可以清除左浮动效果，`right`值为右浮动，`both`则会清除左右浮动。\r\n\r\n```css\r\n.clear {\r\n    clear: both;\r\n}\r\n```\r\n\r\n但是，当你发现在容器内有了一个浮动元素，同时容器文本内容过短时就会出现问题。文本盒子会被绘制在浮动元素下，然后接下来的部分会以正常流绘制在其后。\r\n\r\n![The box around the text does not clear the float](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10967f2208?w=1174&h=336&f=png&s=19626)\r\n\r\n\r\n为了避免这种情况，我们需要为容器中某个元素应用`clear`属性。我们可以在容器最后添加一个空元素并设置`clear`属性。但是在某些情况下可能无法使用这种方式（例如一些CMS系统生成的页面）。因此，最常见的清除浮动的hack方案是：在容器内添加一个CSS伪元素，并将其`clear`属性设置为both。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"item\"></div>\r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra.</p>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n}\r\n\r\n.item {\r\n  width: 100px;\r\n  height: 100px;\r\n  float: left;\r\n  margin: 0 20px 20px 0;\r\n  background-color: rgba(111,41,97,.3);\r\n}\r\n\r\n.container::after {\r\n  content: \"\";\r\n  display: table;\r\n  clear: both;\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10968de015?w=1128&h=358&f=png&s=41211)\r\n\r\n> example: [Smashing Guide to Layout: clearfix](https://codepen.io/rachelandrew/pen/jxJjje) on Codepen\r\n\r\n### 2.2. 块级格式化上下文（Block Formatting Context）\r\n\r\n清除浮动的另一个方法是在容器内创建BFC。一个BFC元素完全包裹住了它内部的所有元素，包括内部的浮动元素，保证浮动元素不会超出其底部。创建BFC的方式有很多种，其中最常用的一种清除浮动的方式是为元素设置除visible（默认）之外的`overflow`属性值。\r\n\r\n```css\r\n.container {\r\n    overflow: auto;\r\n}\r\n```\r\n\r\n像上面这样使用`overflow`一般情况下是有效的。然而，在某些情况下，这可能会带来一些阴影的截断或是非预期的滚动条。同时它也使你的CSS变得不那么直观：设置`overflow`是因为你想要展示滚动条还是仅仅为了获取清除浮动的能力呢？\r\n\r\n为了使清除浮动的意图更加直观，并且避免BFC的负面影响，你可以使用`flow-root`作为`display`属性的值。`display: flow-root`做的唯一的一件事就是去创建一个BFC，因此可以避免其他创建BFC方法带来的问题。\r\n\r\n```css\r\n.container {\r\n    display: flow-root;\r\n}\r\n```\r\n\r\n### 2.3. 浮动的一些遗留用法\r\n\r\n在新的布局方式出现以前，`float`经常会被用来创建多栏布局。我们会给一系列元素设置宽度并且将它们一个接一个进行浮动。通过为浮动元素设置一些精细的百分比大小可以创建类似网格的效果。\r\n\r\n我不建议在当下仍然过度地使用这种方法。但是，在现有的网站中，这种方式仍然会存在许多年。因此，当你碰到一个页面里面到处是`float`的应用，可以确定它就是用的这种技术。\r\n\r\n### 2.4. 关于浮动与清除浮动的其他阅读资料\r\n\r\n- “[The Clearfix: Force an Element To Self-Clear its Children](https://css-tricks.com/snippets/css/clear-fix/),” Chris Coyier, CSS-Tricks\r\n- “[float](https://developer.mozilla.org/en-US/docs/Web/CSS/float),” CSS: Cascading Style Sheets, MDN web docs\r\n- “[clear](https://developer.mozilla.org/en-US/docs/Web/CSS/clear),” CSS: Cascading Style Sheets, MDN web docs\r\n- “[Understanding CSS Layout And The Block Formatting Context](https://www.smashingmagazine.com/2017/12/understanding-css-layout-block-formatting-context/),” Rachel Andrew, Smashing Magazine\r\n\r\n---\r\n\r\n## 3. 定位（Positioning）\r\n\r\n想要把一个元素从正常流中移除，或者改变其在正常文档流中的位置，可以使用CSS中的`position`属性。当处于正常文档流时，元素的`position`属性为`static`。在块级维度上元素会一个接一个排列下去，当你滚动页面时元素也会随着滚动。\r\n\r\n当你改变元素的position属性时，通常情况下你也会设置一些偏移量来使元素相对于参照点进行一定的移动。不同的position值会产生不同的参照点。\r\n\r\n### 3.1. 相对定位（relative postioning）\r\n\r\n如果一个元素具有属性`position: relative`，那么它偏移的参照位是其原先在正常文档流中的位置。你可以使用top、left、bottom和right属性来相对其正常流位置进行移动。\r\n\r\n```css\r\n.item {\r\n    position: relative;\r\n    bottom: 50px;\r\n}\r\n```\r\n\r\n注意，页面上的其他元素并不会因该元素的位置变化而受到影响。该元素在正常流中的位置会被保留，因此你需要自己去处理一些元素内容覆盖的情况。\r\n\r\n```html\r\n<div class=\"container\">\r\n  \r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra. Kohlrabi radish okra azuki bean corn fava bean mustard tigernut jícama green bean celtuce. </p>\r\n  \r\n  <div class=\"item\"></div>\r\n  <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n}\r\n\r\n.item {\r\n  width: 100px;\r\n  height: 100px;\r\n  background-color: rgba(111,41,97,.3);\r\n  position: relative;\r\n  bottom: 50px;\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd1096a5574e?w=1118&h=740&f=png&s=267164)\r\n\r\n> example: [Smashing Guide to Layout: position: relative](https://codepen.io/rachelandrew/pen/MGxNwd) on Codepen\r\n\r\n### 3.2. 绝对定位（absolute postioning）\r\n\r\n给一个元素设置`position: absolute`属性可以将其完全从正常流中移除。其原本占据的空间也会被移除。该元素会定位会相对于视口容器，除非其某个祖先元素也是定位元素（position值不为static）。\r\n\r\n因此，当你为某个元素设置`position: absolute`时，首先发生的变化是该元素会定位在视口的左上角。你可以通过设置`top`、`left`、`bottom`和`right`偏移量属性来将元素移动到你想要的位置。\r\n\r\n```css\r\n.item {\r\n    position: absolute;\r\n    top: 20px;\r\n    right: 20px;\r\n}\r\n```\r\n\r\n通常情况下你并不希望元素相对于视口进行定位，而是相对于容器元素。在这种情况下，你需要为容器元素设置一个除了默认`static`之外的值。\r\n\r\n由于给一个元素设置`position: relative`并不会将其从正常流中移除，所以通常这是一个不错的选择。给你想要相对的容器元素设置`position\r\n: relative`，就可以让绝对定位的元素相对其进行偏移。\r\n\r\n```html\r\n<div class=\"container\">\r\n  \r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra. Kohlrabi radish okra azuki bean corn fava bean mustard tigernut jícama green bean celtuce. </p>\r\n  \r\n  <div class=\"item\"></div>\r\n  <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  position: relative;\r\n}\r\n\r\n.item {\r\n  width: 100px;\r\n  height: 100px;\r\n  background-color: rgba(111,41,97,.3);\r\n  position: absolute;\r\n  top: 20px;\r\n  left: 20px;\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10c4022eb6?w=1124&h=546&f=png&s=273461)\r\n\r\n> example: [Smashing Guide to Layout: position: absolute](https://codepen.io/rachelandrew/pen/zjbgvx) on Codepen\r\n\r\n### 3.3. 固定定位（fixed positioning）\r\n\r\n大多数情况下，`position: fixed`的元素会相对于视口定位，并且会从正常文档流中被移除，不会保留它所占据的空间。当页面滚动时，固定的元素会留在相对于视口的位置，而其他正常流中的内容则和通常一样滚动。\r\n\r\n```css\r\n.item {\r\n    position: fixed;\r\n    top: 20px;\r\n    left: 100px;\r\n}\r\n```\r\n\r\n当你想要一个固定导航栏一直停留在屏幕上时这会非常有效。和其他的position值一样，这也可能会造成一些元素被遮挡，需要小心保证页面内容的可读而不会被固定元素遮挡。\r\n\r\n```html\r\n<div class=\"container\">\r\n  \r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra. Kohlrabi radish okra azuki bean corn fava bean mustard tigernut jícama green bean celtuce. </p>\r\n  \r\n  <div class=\"item\"></div>\r\n  <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n  \r\n   <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n  \r\n   <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  position: relative;\r\n}\r\n\r\n.item {\r\n  width: 100px;\r\n  height: 100px;\r\n  background-color: rgba(111,41,97,.3);\r\n  position: fixed;\r\n  top: 20px;\r\n  left: 20px;\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10c42778cd?w=1126&h=768&f=png&s=461323)\r\n\r\n> example: [Smashing Guide to Layout: position: fixed](https://codepen.io/rachelandrew/pen/xjBvLE) on Codepen\r\n\r\n\r\n为了使一个固定定位的元素不相对于视口进行定位，你需要为容器元素设置`transform`、`perspective`、`filter`三个属性之一（不为默认值none）。这样固定的元素就会相对于该块级元素偏移，而非视口。\r\n\r\n### 3.4. STICKY 定位\r\n\r\n设置`position: sticky`会让元素在页面滚动时如同在正常流中，但当其滚动到相对于视口的某个特定位置时就会固定在屏幕上，如同fixed一般。这个属性值是一个较新的CSS属性，在浏览器兼容性上会差一些，但在不兼容的浏览器中会被忽略并会退到正常的滚动情况。\r\n\r\n```css\r\n.item {\r\n    position: sticky;\r\n    top: 0;\r\n}\r\n```\r\n\r\n下面的代码展示了如何创建一个非常流行导航栏效果：导航栏会随着页面滚动，而当导航栏滚动到页面顶部时则会固定在顶部位置。\r\n\r\n```html\r\n<div class=\"container\">\r\n  \r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra. Kohlrabi radish okra azuki bean corn fava bean mustard tigernut jícama green bean celtuce. </p>\r\n  \r\n  <div class=\"item\"></div>\r\n  <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n  \r\n   <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n  \r\n   <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  position: relative;\r\n}\r\n\r\n.item {\r\n  width: 100px;\r\n  height: 30px;\r\n  background-color: rgba(111,41,97,.3);\r\n  position: sticky;\r\n  top: 0;\r\n  width: 100%;\r\n}\r\n```\r\n\r\n> example: [Smashing Guide to Layout: position: sticky](https://codepen.io/rachelandrew/pen/LmawOy) on Codepen\r\n\r\n### 3.5. 关于定位（positioning）的其他阅读资料\r\n\r\n- “[Positioning](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning),” MDN Learning Area, MDN web docs, Mozilla\r\n- “[position: sticky](https://css-tricks.com/position-sticky-2/);,” Chris Coyier, CSS-Tricks\r\n- “[CSS position:sticky](https://caniuse.com/#feat=css-sticky),” Browser support information for sticky positioning, caniuse\r\n\r\n---\r\n\r\n## 4. 弹性布局（Flex Layout）\r\n\r\n弹性盒子（Flexbox）布局是一种为一维布局而设计的布局方法。一维的意思是你希望内容是按行或者列来布局。你可以使用`display: flex`来将元素变为弹性布局。\r\n\r\n```css\r\n.container {\r\n    display: flex;\r\n}\r\n```\r\n\r\n该容器的直接子元素会变为弹性项（flex item），并按行排列。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"item\">1</div>\r\n  <div class=\"item\">2</div>\r\n  <div class=\"item\">3</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: flex;\r\n}\r\n\r\n.item {\r\n  width: 100px;\r\n  height: 100px;\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10c4105b96?w=1062&h=310&f=png&s=15494)\r\n\r\n> example: [Smashing Guide to Layout: flex](https://codepen.io/rachelandrew/pen/RyObov) on Codepen\r\n\r\n### 4.1. 弹性盒子的轴（axes）\r\n\r\n在上面的例子中，我们会称弹性项在行内是从起始位置开始排列，而不是说它们是左对齐。这些元素会按行排列是因为默认的`flex-direction`值为`row`，`row`代表了文本的行文方向。由于我们工作的环境是英文（中文也是如此），一种自左向右的语言，行的开始位置就是在左边，因此我们的弹性项也是从左边开始的。因此`flex-direction`的值被定义为弹性盒子的主轴（main axis）。\r\n\r\n交叉轴（cross axis）则是和主轴垂直的一条轴。如果你的`flex-direction`是`row`并且弹性项是按照行内方向排列的，那么交叉轴就是块级元素的排列方向。如果`flex-direction`是`column`那么弹性项就会以块级元素排列的方向排布，然后交叉轴就会变为`row`。\r\n\r\n如果你习惯于从主轴与交叉轴的角度来使用弹性盒子，那么一切会变得非常简单。\r\n\r\n### 4.2. 方向和次序\r\n\r\n弹性盒子模型让我们可以通过为`flex-direction`属性设置`row-reverse`或`column-reverse`值来改变主轴上弹性项的方向。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"item\">1</div>\r\n  <div class=\"item\">2</div>\r\n  <div class=\"item\">3</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: flex;\r\n  flex-direction: row-reverse;\r\n}\r\n\r\n.item {\r\n  width: 100px;\r\n  height: 100px;\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10ce900086?w=1054&h=312&f=png&s=14797)\r\n\r\n> example: [Smashing Guide to Layout: flex-direction](https://codepen.io/rachelandrew/pen/zjXONE) on Codepen\r\n\r\n当然，你也可以通过`order`属性来改变某一个弹性项的顺序。但是要特别注意，这可能会给那些通过键盘（而非鼠标或触屏）访问你的网站的用户带来一些麻烦，因为tab的顺序是页面内元素在源码中的顺序而非显示顺序。你可以阅读之后的“显示和文档顺序”部分来了解更多相关内容。\r\n\r\n### 4.3. 一些Flex的属性\r\n\r\n这些flex的属性是用来控制弹性项在主轴上空间大小的。这三个属性是：\r\n\r\n- flex-grow\r\n- flex-shrink\r\n- flex-basis\r\n\r\n通常可以使用它们的简写形式：`flex`。第一个值代表`flex-grow`，第二个是`flex-shrink`，而第三个则是`flex-basis`。\r\n\r\n```css\r\n.item {\r\n    flex: 1 1 200px;\r\n}\r\n```\r\n\r\n`flex-basis`会为弹性项设置未拉伸和压缩时的初始大小。在上面的例子中，大小是200px，因此我们会给每个项200px的空间大小。但是大多数情况下容器元素大小不会正好被分为许多200px大小的项，而是可能有一些不足或剩余空间。`flex-grow`和`flow-shrink`属性允许我们在容器大小不足或有空余时控制各个弹性项的大小。\r\n\r\n如果`flex-grow`的值是任意的正数，那么弹性项会被允许拉伸来占据更多的空间。因此，在上面的例子中，当各项被设为200px后，所有多余的空间会被每个弹性项平分并填满。\r\n\r\n如果`flex-shrink`的值为任意的正数，那么当弹性项被设置了`flex-basis`后，元素溢出容器时会进行收缩。在上面这个CSS的例子中，如果容器空间不足，每个弹性项会等比例缩放以适应容器的大小。\r\n\r\n`flex-grow`和`flex-shrink`的值可以是任意的正数。一个具有较大`flex-grow`值的弹性项会在容器有剩余空间时拉伸更大的比例；而一个具有更大`flex-shrink`值的项则会在容器空间不足时被压缩的更多。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"item\">1</div>\r\n  <div class=\"item\">2</div>\r\n  <div class=\"item\">3</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: flex;\r\n}\r\n\r\n.item {\r\n  flex: 1 1 0;\r\n  width: 100px;\r\n  height: 100px;\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n\r\n.container :first-child {\r\n  flex: 2 1 0; \r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10d55eab80?w=1054&h=324&f=png&s=16745)\r\n\r\n> example: [Smashing Guide to Layout: flex properties](https://codepen.io/rachelandrew/pen/rvbaRM) on Codepen\r\n\r\n理解这些属性是理解如何使用弹性布局的关键，下面列出的一些资源会帮助我们进一步学习其中的细节。当你需要在容器的一个维度上拉伸或者压缩一些元素时，你可以考虑使用弹性盒子模型。如果你发现你正尝试在行和列两个维度上排列你的内容，你需要的是网格模型（grid），这时弹性盒子模型很可能不是最合适的工具了。\r\n\r\n### 4.4. 关于弹性盒子布局的其他阅读资料\r\n\r\n- “[CSS Flexible Box Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout),” A complete guide to the specification, MDN web docs, Mozilla\r\n- “[A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/),” Chris Coyier, CSS-Tricks\r\n- “[Flexbox Froggy](https://flexboxfroggy.com/),” A game for learning Flexbox\r\n- “[Flexbugs](https://github.com/philipwalton/flexbugs),” A community curated list of browser bugs relating to Flexbox\r\n- [Learn Flexbox for free - 12 interactive screencasts to take you from beginner to advanced](https://scrimba.com/g/gflexbox) from scrimba（译者荐）\r\n\r\n---\r\n\r\n## 5. 网格布局（grid layout）\r\n\r\nCSS网格布局（grid layout）是一种用来进行二维布局的技术。二维（two-dimesional）意味着你希望按照行和列来排布你的内容。和弹性盒子类似，网格布局也需要设置一个`display`值。你可以为容器元素设置`display: grid`，并且使用`grid-template-columns`和`grid-template-rows`属性来控制网格中的行与列。\r\n\r\n```css\r\n.container {\r\n    display: grid;\r\n    grid-template-columns: 200px 200px 200px;\r\n    grid-template-rows: 200px 200px;\r\n}\r\n```\r\n\r\n上面这段CSS会创建一个行列元素大小固定的网格。不过这也许并不是你希望的。默认值为`auto`，你可以认为这代表了“让格子尽可能的大”。如果你每没有指定行（row track）的大小，所有添加进来的行内容大小都会被置为`auto`。一种常用的模式是为网格制定列宽度，但是允许网格按需添加行。\r\n\r\n你可以使用任意的长度单位或时百分比来设置行与列，同时你可以使用为网格系统所创造的新的单位——`fr`。`fr`是一种弹性单位，它可以指定网格容器内的空间被如何划分。\r\n\r\n网格会替你计算与分配空间，你不需要去计算元素的百分比去适应容器大小。在下面这个例子中，我们使用`fr`来创建网格的列，这使得网格的列可以自适应。同时我们还使用了`grid-gap`来保证元素间的间距（关于网格内元素与的间距会在“对齐”这一部分详细介绍）。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div>1</div>\r\n  <div>2</div>\r\n  <div>3</div>\r\n  <div>4</div>\r\n  <div>5<br>has more content.</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr 1fr;\r\n  grid-gap: 20px;\r\n}\r\n\r\n.container > div {\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fd10d760b18f?w=1056&h=390&f=png&s=38583)\r\n\r\n> example: [Smashing Guide to Layout: a simple grid](https://codepen.io/rachelandrew/pen/erorKm) on Codepen\r\n\r\n\r\n### 5.1. 关于网格的一些术语\r\n\r\n网格系统总是有两个轴：inline axis表示页面中文字的文字排列的方向，block axis表示页面中块级元素的排列方向。\r\n\r\n一个被设置为`display: grid`的元素就是所谓的网格容器。在网格容器中会有网格线（grid line），网格线就是你在指定`grid-template-columns`和`grid-template-rows`时网格中行列所生成的。网格中的最小单位（也就是被四条网格线截取生成的区域）被成为网格单元格（grid cell），进一步的，由若干个单元格组成的矩形区域被成为网格区域（grid area）。\r\n\r\n![Grid Lines run between each track of the grid.](https://user-gold-cdn.xitu.io/2018/7/3/1645fdc7e2d360d1?w=514&h=238&f=png&s=6379)\r\n\r\n![Grid Tracks are between any two lines](https://user-gold-cdn.xitu.io/2018/7/3/1645fdcc9dec47b3?w=514&h=238&f=png&s=6030)\r\n\r\n![Grid cells are the smallest unit on the grid, a Grid Area is one or more cells together making a rectangular area](https://user-gold-cdn.xitu.io/2018/7/3/1645fdd0fdacbfb7?w=515&h=237&f=png&s=5354)\r\n\r\n### 5.2. 网格的自动排列规则\r\n\r\n一旦你创建了网格，那么网格容器的直接子元素就会开始将它们自己一个一个地放置在网格的单元格中。子元素的放置是依据网格的自动排列规则（auto-placement rule）。这些规则确保了网格内元素是被安排在各个空的单元格中，而不会彼此遮盖。\r\n\r\n网格中任何没有被进行定位的直接子元素都会根据自动排列规则进行放置。在下面这个列子中，我让每三个元素中的第一个占据两行，但仍然从起始行开始去自动排列。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div>1</div>\r\n  <div>2</div>\r\n  <div>3</div>\r\n  <div>4</div>\r\n  <div>5</div>\r\n  <div>6</div>\r\n  <div>7</div>\r\n  <div>8</div>\r\n  <div>9</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr 1fr;\r\n  grid-gap: 20px;\r\n}\r\n\r\n.container > div {\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n\r\n.container > div:nth-child(3n+1) {\r\n  grid-row-end: span 2;\r\n  background-color: rgba(193,225,237,.3);\r\n  border: 2px solid rgba(193,225,237,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645fe43135e298f?w=531&h=285&f=png&s=1586)\r\n\r\n> example: [Smashing Guide to Layout: auto-placement](https://codepen.io/rachelandrew/pen/ZoZoqY) on Codepen\r\n\r\n### 5.3. 基于行/列的基本定位方法\r\n\r\n定位网格元素最简单的方式是使用基于行/列（line）的定位方法，只需告诉浏览器从哪一排到哪一排来进行合并。例如，如果你需要一个2*2的网格区域，你可以将指定元素从第一行开始到第三行、从第一列开始到第三列，这样就可以覆盖到四个单元格。\r\n\r\n```css\r\n.item {\r\n    grid-column-start: 1;\r\n    grid-column-end: 3;\r\n    grid-row-start: 1;\r\n    grid-row-end: 3;\r\n}\r\n```\r\n\r\n这些属性可以用缩写来表示：`grid-column`和`grid-row`，其中起一个值代表起始值，第二个值代表结束值。\r\n\r\n```css\r\n.item {\r\n    grid-column: 1 / 3;\r\n    grid-row: 1 / 3;\r\n}\r\n```\r\n\r\n你也可以让网格项（grid item）占据同一个单元格。支持一些内容间会覆盖的设计。网格项会像通常网页中的元素那样叠起来，在html源码中下面的网格项会叠在其他元素上面。你仍然可以用`z-index`来控制它的堆叠顺序。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"one\">1</div>\r\n  <div class=\"two\">2</div>\r\n  <div class=\"three\">3</div>\r\n  <div class=\"four\">4</div>\r\n  <div class=\"five\">5</div>\r\n\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr 1fr;\r\n  grid-gap: 20px;\r\n}\r\n\r\n.container > div {\r\n  padding: 10px;\r\n}\r\n\r\n.one {\r\n  grid-column: 1 / 4;\r\n  grid-row: 1;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n\r\n.two {\r\n  grid-column: 1 / 3;\r\n  grid-row: 2;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n\r\n.three {\r\n  grid-column: 2 / 4;\r\n  grid-row: 2 / 5;\r\n  background-color: rgba(193,225,237,.3);\r\n  border: 2px solid rgba(193,225,237,.5);\r\n}\r\n\r\n.four {\r\n  grid-column: 1;\r\n  grid-row: 4 ;\r\n  background-color: rgba(193,225,237,.3);\r\n  border: 2px solid rgba(193,225,237,.5);\r\n}\r\n\r\n.five {\r\n  grid-column: 3 ;\r\n  grid-row: 4 / 5;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645ff2d0ec568f3?w=539&h=242&f=png&s=1187)\r\n\r\n> example: [Smashing Guide to Layout: line-based placement](https://codepen.io/rachelandrew/pen/mLgLZj) on Codepen\r\n\r\n### 5.4. 通过命名区域来定位元素\r\n\r\n你可以通过命名区域（named areas）来定位网格中的元素。要是用这种方式，你需要给每个元素一个名字，然后通过`grid-template-areas`属性的值来描述布局方式。\r\n\r\n```css\r\n.item1 {\r\n    grid-area: a;\r\n}\r\n\r\n.item2 {\r\n    grid-area: b;\r\n}\r\n\r\n.item3 {\r\n    grid-area: c;\r\n}\r\n\r\n.container {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr 1fr 1fr;\r\n    grid-template-areas: \r\n     \"a a b b\"\r\n     \"a a c c\";\r\n}\r\n```\r\n\r\n使用这种方式有几个需要注意的点。如果你想要合并一些单元格作为你的网格项，你需要重复元素的名字。网格区域需要能形成一个完整的矩形 —— 每个单元格都需要被填入一个值。如果你想要空出某些单元格，那就需要使用`.`这个值。例如在下面的CSS里我将最右下角的单元格留空。\r\n\r\n```css\r\n.container {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr 1fr 1fr;\r\n    grid-template-areas: \r\n     \"a a b b\"\r\n     \"a a c .\";\r\n}\r\n```\r\n\r\n你也可以通过下面这个demo的代码来看看实际的布局效果。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"one\">1</div>\r\n  <div class=\"two\">2</div>\r\n  <div class=\"three\">3</div>\r\n  <div class=\"four\">4</div>\r\n  <div class=\"five\">5</div>\r\n\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr 1fr;\r\n  grid-auto-rows: minmax(50px, auto);\r\n  grid-gap: 20px;\r\n  grid-template-areas: \r\n    \"a a a\"\r\n    \"b c c\"\r\n    \". . d\"\r\n    \"e e d\"\r\n}\r\n\r\n.container > div {\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n\r\n.one {\r\n  grid-area: a;\r\n}\r\n\r\n.two {\r\n  grid-area: b;\r\n}\r\n\r\n.three {\r\n  grid-area: c;\r\n}\r\n\r\n.four {\r\n  grid-area: d;\r\n}\r\n\r\n.five {\r\n  grid-area: e;\r\n}\r\n\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1645ffbcc1e79e99?w=535&h=312&f=png&s=1250)\r\n\r\n> example: [Smashing Guide to Layout: grid-template-areas](https://codepen.io/rachelandrew/pen/bMJKeX) on Codepen\r\n\r\n\r\n### 5.5. 关于网格布局的其他阅读资料\r\n\r\n这片文章只包括了CSS网格布局的一些初步内容，其中还有非常多的内容值得学习，下面的一些资料可以帮助你进一步学习。一些组件或整个页面的布局都可以使用网格。如果你需要在两个维度进行布局，网格布局是一个不错的选择 —— 不论需要布局的区域的大小。\r\n\r\n- “[CSS Grid Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout),” Web technology for developers, MDN web docs, Mozilla\r\n- “[Grid by Example](https://gridbyexample.com/),” Everything you need to learn CSS Grid Layout, Rachel Andrew\r\n- “[Grid Garden](https://cssgridgarden.com/),” A fun interactive game to test and improve your CSS skills\r\n- “[Layout Land](https://www.youtube.com/channel/UC7TizprGknbDalbHplROtag),” Jen Simmons, YouTube\r\n- [Learn CSS Grid for free - 14 interactive screencasts to take you from beginner to advanced](https://scrimba.com/g/gR8PTE) from scrimba（译者荐）\r\n\r\n我（作者）在Smashing Magazine也写一些文章来帮助你深入理解各种网格的概念：\r\n\r\n- “[Best Practices With CSS Grid Layout](https://www.smashingmagazine.com/2018/04/best-practices-grid-layout/)”\r\n- “[Styling Empty Cells With Generated Content And CSS Grid Layout](https://www.smashingmagazine.com/2018/02/generated-content-grid-layout/)”\r\n- “[Using CSS Grid: Supporting Browsers Without Grid](https://www.smashingmagazine.com/2017/11/css-grid-supporting-browsers-without-grid/)”\r\n- “[CSS Grid Gotchas And Stumbling Blocks](https://www.smashingmagazine.com/2017/09/css-grid-gotchas-stumbling-blocks/)”\r\n- “[Naming Things In CSS Grid Layout](https://www.smashingmagazine.com/2017/10/naming-things-css-grid-layout/)”\r\n\r\n---\r\n\r\n## 6. 显示顺序和文档顺序（visual and document order）\r\n\r\n在文章的最开始，我建议你以从上到下的阅读顺序来组织你的文档顺序，这样会有助于可读性和CSS的布局方式。从我们关于弹性盒子和CSS网格的简短介绍来看，你可以发现用这些布局方法可能会极大地改变页面展示的元素在文档中的顺序。这可能会导致一个隐含的问题。\r\n\r\n在一些非可视化的应用场景中，浏览器会遵循文档源码来进行使用。因此，屏幕阅读器会读取文档的顺序，此外使用键盘tab键来浏览的用户访问文档的顺序是基于源码的顺序，而不是元素展示的顺序。许多屏幕阅读器的用户并非完全失明，他们可能在使用屏幕阅读器的同时也能够看到这些元素在文档的哪个部分。在这些情况下，当与源码进行对比时，这种混乱的页面展现可能会令人充满迷惑。\r\n\r\n当你改变了元素在文档中原来的顺序时，一定确保知道自己在做什么。如果你发现你自己正在CSS中重新排序你的元素，你应该去回头看看是否要重新组织你的页面元素。你可以通过使用tab访问来测试一下你的页面。\r\n\r\n### 6.1. 关于显示顺序和文档顺序的其他阅读资料\r\n\r\n- “[CSS Grid Layout and Accessibility](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/CSS_Grid_Layout_and_Accessibility),” Web technology for developers, MDN web docs, Mozilla\r\n- “[HTML Source Order vs CSS Display Order](http://adrianroselli.com/2015/10/html-source-order-vs-css-display-order.html),” Adrian Roselli\r\n- “[Flexbox And The Keyboard Navigation Disconnect](https://tink.uk/flexbox-the-keyboard-navigation-disconnect/),” Code Things, Tink\r\n- “[The Responsive Order Conflict For Keyboard Focus](https://alastairc.ac/2017/06/the-responsive-order-conflict/),” Alastair Campbell\r\n\r\n---\r\n\r\n## 7. 盒模型的生成（box generation）\r\n\r\n你写在网页里的任何东西都会生成一个盒子（box），这篇文章讨论的所有东西其实都是如何能够使用CSS来按照你的设计布局这些盒子。然而，在某些情况下，你可能根本不想创建一个盒子。有两个`display`的属性值会帮你处理这种情况。\r\n\r\n### 7.1. 不生成盒子或内容（`display: none`）\r\n\r\n如果你希望元素以及它所有的内容（包括所有子元素）都不会生成，你可以使用`display: none`。这样元素就不会被展示，并且不会保留其本该占有的空间。\r\n\r\n```css\r\n.item {\r\n    display: none;\r\n}\r\n```\r\n\r\n### 7.2 不生成该元素，但是生成其所有子元素（`display: contents`）\r\n\r\n`display: content`是`display`的一个新的属性值。为一个元素应用`display: content`属性会导致其自身的盒子不生成但所有的子元素都会照常生成。这有什么用呢？试想一下，如果你希望一个弹性布局或网格布局中的非直接子元素能应用这些布局，这就会非常有用。\r\n\r\n在下面这个例子里，第一个弹性项包含了两个子元素，由于它被设为`display: contents`，它的盒子不会生成并且它的两个子元素会成为弹性项，并被当作弹性盒子容器的直接子元素来布局。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"item\">\r\n    <div class=\"subitem\">A</div>\r\n    <div class=\"subitem\">B</div>\r\n  </div>\r\n  <div class=\"item\">2</div>\r\n  <div class=\"item\">3</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: flex;\r\n}\r\n\r\n.item {\r\n  flex: 1 1 200px;\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n\r\n.subitem {\r\n  padding: 10px;\r\n  background-color: rgba(193,225,237,.3);\r\n  border: 2px solid rgba(193,225,237,.5);\r\n}\r\n\r\n.container .item:first-child {\r\n  display: contents;\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/3/1646049946695d35?w=535&h=101&f=png&s=791)\r\n\r\n> example: [Smashing Guide to Layout: display: contents](https://codepen.io/rachelandrew/pen/GdLBRR) on Codepen\r\n\r\n### 7.3. 关于box generation的其他阅读资料\r\n\r\n- “[Vanishing Boxes With display: contents](https://rachelandrew.co.uk/archives/2016/01/29/vanishing-boxes-with-display-contents/),” Rachel Andrew\r\n- [How display: contents; Works](https://bitsofco.de/how-display-contents-works/),” Ire Aderinokun,\r\n- [CSS display: contents](https://caniuse.com/#feat=css-display-contents),” Browser support information, caniuse\r\n\r\n---\r\n\r\n## 8. 对齐\r\n\r\n在以前，要实现对齐往往会用到一些很\"tricky\"的方式，并且能够使用的方法也非常有限。随着CSS盒模型对齐（box alignment module）的出现，这一切都发生了变化。你将会使用它来控制网格容器与弹性盒子容器中的对齐。未来其他的各种布局方法都会应用这些对齐属性。盒模型对齐（box alignment specification）规范中的一系列详细属性如下：\r\n\r\n- `justify-content`\r\n- `align-content`\r\n- `place-content`\r\n- `justify-items`\r\n- `align-items`\r\n- `place-items`\r\n- `justify-self`\r\n- `align-self`\r\n- `place-self`\r\n- `row-gap`\r\n- `column-gap`\r\n- `gap`\r\n\r\n由于不同的布局模型有不同的特性，因此用于不同布局模型的对齐属性会有一些表现上的差异。让我们来看看在一些简单的网格与弹性布局中对齐是如何工作的。\r\n\r\n`align-items`和`justify-items`属性相对是`align-self`和`justify-self`属性的一种批量形式。这些属性会控制与元素在其网格区域（grid area）中的对齐情况。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div>1</div>\r\n  <div>2</div>\r\n  <div>3</div>\r\n  <div>4</div>\r\n  <div class=\"special\">5</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr 1fr;\r\n  grid-auto-rows: minmax(100px, auto);\r\n  grid-gap: 20px;\r\n  align-items: center;\r\n  justify-items: start;\r\n}\r\n\r\n.special {\r\n  grid-column: 2 / 4;\r\n  align-self: end;\r\n  justify-self: end;\r\n}\r\n\r\n.container > div {\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/4/164653c5e7a035d4?w=530&h=275&f=png&s=1063)\r\n\r\n> example: [Smashing Guide to Layout: Grid align-items, justify-items, align-self, justify-self](https://codepen.io/rachelandrew/pen/WJWKgd) on Codepen\r\n\r\n`align-content`和`justify-content`属性则会对网格中的行/列（tracks）进行对齐控制（网格容器中需要在排列完行/列元素后有多余的空间）。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div>1</div>\r\n  <div>2</div>\r\n  <div>3</div>\r\n  <div>4</div>\r\n  <div>5</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  height: 300px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: grid;\r\n  grid-template-columns: 100px 100px 100px;\r\n  grid-auto-rows: minmax(100px, auto);\r\n  grid-gap: 20px;\r\n  align-content: space-between;\r\n  justify-content: end;\r\n}\r\n\r\n.container > div {\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/4/1646547a0ff1dacb?w=527&h=323&f=png&s=1229)\r\n\r\n> example: [Smashing Guide to Layout: Grid align-content, justify-content](https://codepen.io/rachelandrew/pen/mLgGym) on Codepen\r\n\r\n在弹性盒子中，`align-items`和`align-self`用来解决交叉轴上的对齐问题，而`justify-content`则用于解决主轴上空间的分配。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div>1</div>\r\n  <div>2</div>\r\n  <div class=\"special\">3</div>\r\n  <div>4</div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  height: 300px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: flex-end;\r\n}\r\n\r\n.special {\r\n  align-self: stretch;\r\n}\r\n\r\n.container > div {\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/4/1646549cd671d30a?w=529&h=325&f=png&s=1157)\r\n\r\n> example: [Smashing Guide to Layout: Flex justify-content, align-items, align-self](https://codepen.io/rachelandrew/pen/ZoZMQZ) on Codepen\r\n\r\n在交叉轴上，把弹性行（flex line）和额外空间包裹在弹性容器中之后，你就可以使用`align-content`了。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div>1</div>\r\n  <div>2</div>\r\n  <div>3</div>\r\n  <div>4</div>\r\n  <div>5</div>\r\n</div>\r\n```\r\n\r\n```css\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  height: 300px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  align-content: space-between;\r\n}\r\n\r\n.container > div {\r\n  flex: 1 1 200px;\r\n  padding: 10px;\r\n  background-color: rgba(111,41,97,.3);\r\n  border: 2px solid rgba(111,41,97,.5);\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/4/1646550a7f945c10?w=521&h=324&f=png&s=1158)\r\n\r\n> example: [Smashing Guide to Layout: Flex align-content](https://codepen.io/rachelandrew/pen/QrPVjB) on Codepen\r\n\r\n下面的一些链接更细节地讨论了各类布局方法中的盒模型对齐。花些时间去理解对齐的工作原理是非常值得的，它对理解弹性盒子、网格布局以及未来的一些布局方法都会很有帮助。\r\n\r\n### 8.1. 行/列的间隔\r\n一个多栏布局具有`column-gap`属性，到目前位置，网格布局具有`grid-column-gao`、`grid-row-gap`和`grid-grid`。这些现在都被从grid标准中删除而被添加进盒模型对齐中了。与此同时，`grid-`的前缀属性被重命名为`column-gap`、`row-gap`和`gap`。浏览器会将带有前缀的属性换为新的重命名属性，所以如果你在目前的代码中使用兼容性更好的老名字也不用担心。\r\n\r\n重命名意味着这些属性也能被应用于其他布局方法，一个明显的备选就是弹性盒子。虽然目前没有浏览器支持盒子模型中的gap属性，但是在未来我们应该可以使用`column-gap`和`row-gap`来创建弹性项目元素间的间距。\r\n\r\n### 8.2. 关于box generation的其他阅读资料\r\n\r\n- “[CSS Box Alignment](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Alignment),” CSS: Cascading Style Sheets, MDN web docs, Mozilla\r\n- “[Box Alignment in Flexbox](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Box_Alignment_in_Flexbox),” CSS Flexible Box Layout, MDN web docs, Mozilla\r\n- “[Box Alignment in CSS Grid Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Box_Alignment_in_CSS_Grid_Layout),” CSS Grid Layout, MDN web docs, Mozilla\r\n- “[The New Layout Standard For The Web: CSS Grid, Flexbox And Box Alignment](https://www.smashingmagazine.com/2016/11/css-grids-flexbox-box-alignment-new-layout-standard/),” Rachel Andrew, Smashing Magazine\r\n- “[Box Alignment Cheatsheet](https://rachelandrew.co.uk/css/cheatsheets/box-alignment),” Rachel Andrew\r\n\r\n---\r\n\r\n## 9. 多栏布局（多列布局）\r\n\r\n多栏布局（multi-column layout）是一种支持创建多栏的布局类型，如同报纸上那样。每一块都被分割成栏（column），你会按照块方向在栏中往下读然后会在回到下一栏的顶部。然而用这种方式阅读在网页内容中并不总是有效，因为人们并不想去让滚动条滚动来、滚动去地去阅读。当需要展示少部分内容、折叠一组复选框或者其他一些小的UI组件时会非常有用。\r\n\r\n当展示一组高度不同的卡片或产品时多栏布局也非常有用。\r\n\r\n### 9.1. 设置栏的宽度\r\n\r\n要设置一个最有的栏宽，并通知浏览器依此宽度展示尽可能多的栏可以使用下面的CSS：\r\n\r\n```css\r\n.container {\r\n    column-width: 300px;\r\n}\r\n```\r\n\r\n这会创建尽可能多的300px的栏，所有剩下的空间会被所有栏共享。因此，除非空间被划分为300px时没有剩余，否则你的栏会比300px稍多一些。\r\n\r\n### 9.2. 设置栏的数目\r\n\r\n除了设置宽度，你可以使用`column-count`来设置栏的数目。在这种情况下，浏览器会将空间均分给你需要的数目的栏。\r\n\r\n```css\r\n.container {\r\n    column-count: 3;\r\n}\r\n```\r\n\r\n如果你同时添加了`column-width`和`column-count`，那么`column-count`属性会作为一个最大值限制。在下面的代码里，栏会被添加直到达到三个，此时任何额外的空间都会被分给三栏，即使空间足够成为一个额外的新栏。\r\n\r\n```css\r\n.container {\r\n    column-width: 300px;\r\n    column-count: 3;\r\n}\r\n```\r\n\r\n### 9.3. 间距和栏规则\r\n\r\n你无法为单个栏盒子添加外边距和内边距，需要用`column-gap`属性来设置间距。如果你不具体指定`column-gap`的值，它会默认为1em来防止栏间碰撞。这和其他布局方法中`column-gap`的行为不一样，其他布局中默认为0。你可以在间距上使用任意的长度单元，包括0（如果你不希望有栏间距）。\r\n\r\n`column-rule`属性让你有能力向两栏间添加规则。它是`column-rule-width`、`column-rule-color`和`column-rule-style`的简写形式，可border行为类似。注意，一个规则自身不会占用任何空间。它会占据在间距的顶部，从而增加或减少那些你设置`column-gap`的规则与内容间的空间。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra. Kohlrabi radish okra azuki bean corn fava bean mustard tigernut jícama green bean celtuce. </p>\r\n  <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  column-width: 120px;\r\n  column-gap: 20px;\r\n  column-rule: 4px dotted #000;\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/7/164723a815c7d001?w=1048&h=570&f=png&s=144889)\r\n\r\n> example: [Smashing Guide to Layout: multicol](https://codepen.io/rachelandrew/pen/ELJdOQ) on Codepen\r\n\r\n### 9.4. 允许元素横跨多栏\r\n\r\n你可以使用`column-span`属性让多栏容器内的元素横跨多栏，类似通栏。\r\n\r\n```css\r\nh3 {\r\n    column-span: all;\r\n}\r\n```\r\n\r\n当`column-span`出现时，多栏容器分栏会在这个元素上放停下，因此，容器里的内容会在元素上方形成多栏样式，然后在横跨元素（spanning element）的下方形成一组新的栏盒子（column box）。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra. Kohlrabi radish okra azuki bean corn fava bean mustard tigernut jícama green bean celtuce. </p>\r\n  <h2>Veggies!</h2>\r\n  <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. </p>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  column-width: 120px;\r\n  column-gap: 20px;\r\n  column-rule: 4px dotted #000;\r\n}\r\n\r\n.container h2 {\r\n  column-span: all;\r\n  background-color: rgba(193,225,237,.6);\r\n  border:2px solid rgba(193,225,237,.6);\r\n  margin: 1em 0;\r\n  padding: .5em;\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/7/16472418608ef0d4?w=1048&h=708&f=png&s=122703)\r\n\r\n> example: [Smashing Guide to Layout: multicol span](https://codepen.io/rachelandrew/pen/gzyBQV) on Codepen\r\n\r\n你只可以使用`column-span: all`或`column-span: none`，并不能让元素横跨某几个栏（非通栏）。在文章写作时，Firefox还不支持`column-span`属性。\r\n\r\n### 9.5. 关于多栏布局的其他阅读资料\r\n\r\n- “[Using Multi-Column Layouts](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns/Using_multi-column_layouts),” CSS Multi-column Layout, MDN web docs, Mozilla\r\n\r\n---\r\n\r\n## 10. 碎片化（Fragmentation）\r\n\r\n多栏布局是碎片化（fragmentation）的一个例子，页面内容会被拆分成栏。这和打印时内容被分到不同页非常类似。这个过程是碎片化规范（Fragmentation specification）处理的。这个规范包括了一些帮助控制内容切分的属性。\r\n\r\n例如，如果你有一组置于多栏中的卡片，并且你想确保卡片不会被截为两半分到不同的栏，你可以使用`break-inside`属性的`avoid`值。考虑浏览器兼容性的因素，你也可能会想使用遗留的`page-break-inside`属性。\r\n\r\n```css\r\n.card {\r\n    page-break-inside: avoid;\r\n    break-inside: avoid;\r\n}\r\n```\r\n\r\n如果你想在heading元素后禁止断行，你可以使用`break-after`属性。\r\n\r\n```css\r\n.container h2 {\r\n    page-break-after: avoid;\r\n    break-after: avoid;\r\n}\r\n```\r\n\r\n这些属性可以被用在打印样式或多栏样式中。在下面的例子里，在多栏容器中的三个段落被拆分到了三栏之中。我为`p`元素设置了`break-inside: avoid`，这意味着每个多栏会在自己的栏中结束（即使这会使各栏长度不同）。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <p>Pea horseradish azuki bean lettuce avocado asparagus okra. Kohlrabi radish okra azuki bean corn fava bean mustard tigernut jícama green bean celtuce. </p>\r\n  <p>Grape silver beet  collard greens avocado quandong fennel gumbo black-eyed pea watercress potato tigernut corn groundnut. Chickweed okra pea winter purslane coriander yarrow sweet pepper radish garlic brussels sprout</p>\r\n  \r\n  <p>Groundnut summer purslane earthnut pea tomato spring onion azuki bean gourd. Gumbo kakadu plum komatsuna black-eyed pea green bean zucchini gourd winter purslane silver beet rock melon radish asparagus spinach.</p>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  padding: 20px;\r\n  font: 1em Helvetica Neue, Helvetica, Arial, sans-serif;\r\n}\r\n\r\n* {box-sizing: border-box;}\r\n\r\np {\r\n  margin: 0 0 1em 0;\r\n}\r\n\r\n.container {\r\n  width: 500px;\r\n  border: 5px solid rgb(111,41,97);\r\n  border-radius: .5em;\r\n  padding: 10px;\r\n  column-width: 120px;\r\n  column-gap: 20px;\r\n  column-rule: 4px dotted #000;\r\n}\r\n\r\n.container p {\r\n  page-break-inside: avoid;\r\n  break-inside: avoid;\r\n}\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/7/164725a874c0a4bd?w=1048&h=612&f=png&s=147592)\r\n\r\n> example: [Smashing Guide to Layout: multicol fragmentation](https://codepen.io/rachelandrew/pen/wjZYOK) on Codepen\r\n\r\n### 10.1. 关于碎片化的其他阅读资料\r\n\r\n- “[A Guide To The State Of Print Stylesheets In 2018](https://www.smashingmagazine.com/2018/05/print-stylesheets-in-2018/),” Rachel Andrew, Smashing Magazine\r\n- “[Column Breaks](https://www.quirksmode.org/css/columns/breaks.html),” QuirksMode.org\r\n\r\n---\r\n\r\n## 11. 如何选择布局类型？\r\n\r\n大多数的网页会混合使用多种布局类型。各布局规范都准确定义了它们之间是如何相互作用的。例如，你可能会在网格布局的网格项中使用弹性布局。一些弹性容器可能具有定位属性或浮动。这些规范根据最优的布局方式已经包含了布局模型的混合使用。在这篇指南中，我尝试概述了这种布局类型的基本使用方式，来帮助你了解实现一个效果可能的最好方法。\r\n\r\n然而，别害怕去运用多种方式来实现布局设计。担心你的选择会不会造成实际问题的情况比你想象中要少很多。所以请在开始就组织好你的文档结构，并且注意你文档内容的可视展示顺序。剩下的大部分工作就是在浏览器中试试你的布局方式是否符合预期。\r\n\r\n---\r\n\r\n原文：[Getting Started With CSS Layout](https://www.smashingmagazine.com/2018/05/guide-css-layout/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more)，感谢作者Rachel Andrew。","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/12","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/12/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/12/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/12/events","html_url":"https://github.com/alienzhou/blog/issues/12","id":390624888,"node_id":"MDU6SXNzdWUzOTA2MjQ4ODg=","number":12,"title":"MongoDB高可用__使用Replica Set","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159855196,"node_id":"MDU6TGFiZWwxMTU5ODU1MTk2","url":"https://api.github.com/repos/alienzhou/blog/labels/%E6%9C%8D%E5%8A%A1%E7%AB%AF","name":"服务端","color":"0bbaae","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T10:58:08Z","updated_at":"2018-12-13T10:58:08Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 1. 引言\r\n使用MongoDB，可以以单机模式提供服务。但在实际的生产环境中，单机模式将面临很大的风险，一旦单点数据库服务出现故障，就会导致服务调用出现错误甚至崩溃。因此，在实际生产环境下，需要对MongoDB做相应的主备处理，提高数据库服务的可用性。\r\n\r\n对于提高可用性，一些博文里提到了使用[主从模式（master-slaver）](https://docs.mongodb.com/manual/core/master-slave/)。\r\n\r\n> WARNING:\r\nDeprecated since version 3.2: MongoDB 3.2 deprecates the use of master-slave replication for components of sharded clusters.\r\n\r\n主从模式是高可用的一种方案。**然而上面这段警告里提到，在高版本的MongoDB（3.2以上）的一些场景中，官方已经不推荐使用主从模式，取而代之的，是使用复制集（Replica Set）的方式做主备处理。**\r\n\r\n> IMPORTANT:\r\nReplica sets replace master-slave replication for most use cases. If possible, use replica sets rather than master-slave replication for all new production deployments. This documentation remains to support legacy deployments and for archival purposes only.\r\n\r\n因此，本文将介绍如何将单机MongoDB数据库拓展为主备模式的复制集，以提高可用性。\r\n\r\n## 2. 复制集 Replica Set\r\n在复制集中，有且只有一个主节点(primary)，可以包含一个或多个从节点(secondary)，主从节点通过心跳检测来确定节点是否健康或存活。所有的读写操作都是在主节点上进行的，如果要实现读写分离，需要进行相应的处理。从节点会根据oplog来复制主节点的数据。\r\n\r\n![MongoDB复制集](https://user-gold-cdn.xitu.io/2018/5/3/163266184cbe4acd?w=740&h=280&f=png&s=27146)\r\n\r\n除了主从节点外，MongoDB的复制集中还存在着一种叫仲裁者(Arbiter)的角色。一个仲裁者节点是比较轻量级的，它不会去复制主库的数据，因此也就不会成为主节点；它是在投票选举阶段起作用的——当主节点故障时，仲裁者可以进行投票。一般来说，不建议一个复制集中包含超过一个仲裁者。\r\n\r\n当主节点突然故障后，MongoDB有自己的机制，会自动切换，通过选举，在从节点中选出一个节点作为新的主节点。\r\n\r\n![MongoDB复制集故障处理](https://user-gold-cdn.xitu.io/2018/5/3/163266184cd3012c?w=660&h=500&f=png&s=38665)\r\n\r\n\r\n## 3. 如何使用复制集\r\n### 3.1. 创建复制集\r\n首先，需要在MongoDB实例的启动参数中加入replSet，指定复制集的名称。\r\n\r\n```bash\r\nmongod --port 8017 --dbpath /home/work/data/db1 --replSet rstest\r\n```\r\n\r\n对于已有的单机实例，也可以加入该参数并进行重启。此外，我们还需要另外启动两个MongoDB实例作为从节点，注意replSet参数指定的名称需要相同。\r\n\r\n```bash\r\nmongod --port 8016 --dbpath /home/work/data/db2 --replSet rstest\r\nmongod --port 8015 --dbpath /home/work/data/db2 --replSet rstest\r\n```\r\n\r\n然后，可以通过mongo命令连接MongoDB服务，进入主节点进行初始化。\r\n\r\n```bash\r\nmongo 127.0.0.1:8017\r\n```\r\n\r\n```javascript\r\nrs.initiate({\r\n  _id:\"rstest\", // replSet指定的名称\r\n  members:[{\r\n    _id:0,\r\n    host:\"127.0.0.1:8017\" // 主节点ip与端口\r\n  }]\r\n})\r\n```\r\n需要注意的是，如果是将已有单机拓展为复制集，要在连接原单机的实例并在其中运行使其作为主节点。\r\n\r\n最后，再将其他两个从节点加入到该复制集中。\r\n\r\n```javascript\r\nrs.add(\"127.0.0.1:8016\")\r\nrs.add(\"127.0.0.1:8015\")\r\n```\r\n\r\n通过`rs.status()`查看效果，可以看到`rstest`这个复制集中已经有了三个节点，`stateStr `指明了节点的类型，`health`为1表明该节点是健康的。\r\n\r\n```javascript\r\n{\r\n    \"set\" : \"rstest\",\r\n    \"date\" : ISODate(\"2017-10-31T13:04:16.704Z\"),\r\n    \"myState\" : 1,\r\n    \"members\" : [\r\n        {\r\n            \"_id\" : 0,\r\n            \"name\" : \"127.0.0.1:8017\",\r\n            \"health\" : 1,\r\n            \"state\" : 1,\r\n            \"stateStr\" : \"PRIMARY\", // 节点的类型，主节点\r\n            \"uptime\" : 1508,\r\n            \"optime\" : Timestamp(1509455043, 1),\r\n            \"optimeDate\" : ISODate(\"2017-10-31T13:04:03Z\"),\r\n            \"electionTime\" : Timestamp(1509454568, 2),\r\n            \"electionDate\" : ISODate(\"2017-10-31T12:56:08Z\"),\r\n            \"configVersion\" : 3,\r\n            \"self\" : true\r\n        },\r\n        {\r\n            \"_id\" : 1,\r\n            \"name\" : \"127.0.0.1:8016\",\r\n            \"health\" : 1,\r\n            \"state\" : 2,\r\n            \"stateStr\" : \"SECONDARY\",\r\n            \"uptime\" : 25,\r\n            \"optime\" : Timestamp(1509455043, 1),\r\n            \"optimeDate\" : ISODate(\"2017-10-31T13:04:03Z\"),\r\n            \"lastHeartbeat\" : ISODate(\"2017-10-31T13:04:15.657Z\"),\r\n            \"lastHeartbeatRecv\" : ISODate(\"2017-10-31T13:04:15.108Z\"),\r\n            \"pingMs\" : 0,\r\n            \"syncingTo\" : \"127.0.0.1:8017\",\r\n            \"configVersion\" : 3\r\n        },\r\n        {\r\n            \"_id\" : 2,\r\n            \"name\" : \"127.0.0.1:8015\",\r\n            \"health\" : 1,\r\n            \"state\" : 2,\r\n            \"stateStr\" : \"SECONDARY\",\r\n            \"uptime\" : 13,\r\n            \"optime\" : Timestamp(1509455043, 1),\r\n            \"optimeDate\" : ISODate(\"2017-10-31T13:04:03Z\"),\r\n            \"lastHeartbeat\" : ISODate(\"2017-10-31T13:04:15.657Z\"),\r\n            \"lastHeartbeatRecv\" : ISODate(\"2017-10-31T13:04:15.661Z\"),\r\n            \"pingMs\" : 0,\r\n            \"configVersion\" : 3\r\n        }\r\n    ],\r\n    \"ok\" : 1\r\n}\r\n```\r\n\r\n### 3.2. 连接复制集\r\n由于复制集存在灾备时中的切换机制，在主节点故障的情况下，集群内其他从节点会通过投票方式产生新的主节点，因此，不能像单机情况下那样，直接连接主节点。否则，在MongoDB复制集中主节点故障，自动切换主节点时，数据库访问就会出问题。因此连接复制集需要特定的连接方式。\r\n\r\n在MongoDB的连接字符串(connection url)中可以进行指定。\r\n\r\n```\r\nmongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]\r\n```\r\n\r\n其中可以指定多个host:port，用英文逗号连接，并在最后的option中支持replicaSet参数，用于指定连接的复制集。例如：\r\n\r\n```\r\nmongodb://127.0.0.1:8017,127.0.0.1:8016,127.0.0.1:8015/books?replicaSet=rstest\r\n```\r\n\r\n这样就可以连接上复制集中的books这个数据库。\r\n\r\n## 4. 总结\r\nMongoDB复制集的故障机制切换是它自身来保障，在部署好上面一系列的服务后，我们可以测试一下当主节点故障时，集群中的节点状态与服务可用性。\r\n\r\n通过kill主节点MongoDB进程，使用`rs.status()`可以发现，其中一个从节点已经升级为了主节点（这部分在从节点的日志中也有体现）。此外，数据查询依然可以进行，不会因为主节点的宕机而导致数据服务不可用。","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/11","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/11/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/11/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/11/events","html_url":"https://github.com/alienzhou/blog/issues/11","id":390624209,"node_id":"MDU6SXNzdWUzOTA2MjQyMDk=","number":11,"title":"【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T10:56:24Z","updated_at":"2018-12-13T10:56:33Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第十篇文章。也许你还没有听说过或不了解Resource Hint，但是通过本文，你会快速学习到这一件**页面加载性能利器**。本系列相关demo的代码都可以在[github repo](https://github.com/alienzhou/learning-pwa)中找到。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n---\r\n\r\n> 对之前的文章感兴趣的话，可以从这里找到：\r\n> - [第一篇：2018，开始你的PWA学习之旅](https://github.com/alienzhou/blog/issues/2)\r\n> - [第二篇：10分钟学会使用Manifest，让你的WebApp更“Native”](https://github.com/alienzhou/blog/issues/3)\r\n> - [第三篇：从今天起，让你的WebApp离线可用](https://github.com/alienzhou/blog/issues/4)\r\n> - [第四篇：TroubleShooting: 解决FireBase login验证失败问题](https://github.com/alienzhou/blog/issues/5)\r\n> - [第五篇：与你的用户保持联系: Web Push功能](https://github.com/alienzhou/blog/issues/6)\r\n> - [第六篇：How to Debug? 在chrome中调试你的PWA](https://github.com/alienzhou/blog/issues/7)\r\n> - [第七篇：增强交互：使用Notification API来进行提醒](https://github.com/alienzhou/blog/issues/8)\r\n> - [第八篇：使用Service Worker进行后台数据同步](https://github.com/alienzhou/blog/issues/9)\r\n> - [第九篇：PWA实践中的问题与解决方案](https://github.com/alienzhou/blog/issues/10)\r\n\r\n---\r\n\r\n## 引言\r\n\r\n我们知道，在没有缓存的情况下，无论是HTML、javascript还是一些API数据，页面的每一个请求都需要从客户端发起后经由服务端返回。在这种情况下，我们每一次涉及远程请求的交互（打开一个页面、查询列表数据、动态加载js脚本等）都会有网络延迟。如果我们能够预测或指定页面预先进行一些网络操作，例如DNS解析或者预加载资源，那么当我们在之后的操作中涉及到这部分资源时，加载会更迅速，交互也会更加流畅。\r\n\r\n当然，目前已经有一些技术手段来帮助我们实现资源的预加载，例如常见的使用XMLHttpRequest来获取资源并进行缓存。然而，这些技术都是应用层面的，并非Web标准，某些需求也无法准确实现。同时，在性能方面也存在着问题。好在目前已有相关的Web标准（Resource Hint）涉及到这一部分，通过它，可以在浏览器原生层面实现这些功能，同时提供性能保证。下面我们来了解一下Resource Hint相关技术。\r\n\r\n## 1. Resource Hint\r\n\r\nResource Hint是一系列相关标准，来告诉浏览器哪些源（origin）下的资源我们的Web App想要获取，哪些资源在之后的操作或浏览时需要被使用，以便让浏览器能够进行一些预先连接或预先加载等操作。Resource Hint有DNS Prefetch、Preconnect、Prefetch和Prerender这四种。\r\n\r\n### 1.1. DNS Prefetch\r\n当我们在注重前端性能优化时，可能会忽略了DNS解析。然而DNS的解析也是有耗时的。在Chrome的Timing Breakdown Phase中，第三阶段就是DNS查询。DNS Prefetch就是帮助我们告知浏览器，某个源下的资源在之后会要被获取，这样浏览器就会（Should）尽早解析它。\r\n\r\nResource Hint主要通过使用`link`标签。`rel`属性确定类型，`href`属性则指定相应的源或资源URL。DNS Prefetch可以像下面这样使用：\r\n\r\n```html\r\n<link rel=\"dns-prefetch\" href=\"//yourwebsite.com\">\r\n```\r\n\r\n### 1.2. Preconnect\r\n我们知道，建立连接不仅需要DNS查询，还需要进行TCP协议握手，有些还会有TLS/SSL协议，这些都会导致连接的耗时。因此，使用Preconnect可以帮助你告诉浏览器：“我有一些资源会用到某个源，可以帮我预先建立连接。”\r\n\r\n根据规范，当你使用Preconnect时，浏览器大致做了如下处理：\r\n\r\n- 首先，解析Preconnect的URL\r\n- 其次，根据当前link元素中的属性进行cors的设置\r\n- 默认先将credential设为true；如果cors为Anonymous并且存在跨域，则将credential置为false\r\n- 最后进行连接\r\n\r\n使用Preconnect只需要将`rel`属性设为`preconnect`即可：\r\n\r\n```html\r\n<link rel=\"preconnect\" href=\"//yourwebsite.com\">\r\n```\r\n\r\n当然，你也可以设置CORS\r\n\r\n```html\r\n<link rel=\"preconnect\" href=\"//yourwebsite.com\" crossorigin>\r\n```\r\n\r\n需要注意的是，标准并没有硬性规定浏览器一定要（而是SHOULD）完成整个连接过程，浏览器可以视情况完成部分工作。\r\n\r\n### 1.3. Prefetch\r\n\r\n你可以把Prefetch理解为资源预获取。一般来说，可以用Prefetch来指定在紧接着之后的操作或浏览中需要使用到的资源，让浏览器提前获取。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，并且像CSS样式表、JavaScript脚本这样的资源是不会自动执行并应用于当前文档的。\r\n\r\n需要注意的是，和DNS Prefetch、Preconnect使用不太一样的地方是，Prefetch有一个`as`的可选属性，用来指定获取资源的类型。由于不同的资源类型会具有不同的优先级、[CSP](https://www.w3.org/TR/CSP3/)、请求头等，因此该属性很重要。下表列出了一些常用资源的`as`属性值：\r\n\r\n| 资源使用者 | 写法 |\r\n|---|---|\r\n| `<audio>` | `<link rel=preload as=audio href=...>` |\r\n| `<video>` | `<link rel=preload as=video href=...>` |\r\n| `<track>` | `<link rel=preload as=track href=...>` |\r\n| `<script>`, Worker's importScripts | `<link rel=preload as=script href=...>` |\r\n|` <link rel=stylesheet>`, CSS @import | `<link rel=preload as=style href=...>` |\r\n| CSS @font-face | `<link rel=preload as=font href=...>` |\r\n| `<img>`, `<picture>`, srcset, imageset | `<link rel=preload as=image href=...>` |\r\n| SVG's `<image>`, CSS *-image | `<link rel=preload as=image href=...>` |\r\n| XHR, fetch | `<link rel=preload as=fetch crossorigin href=...>` |\r\n| Worker, SharedWorker | `<link rel=preload as=worker href=...>` |\r\n| `<embed>` | `<link rel=preload as=embed href=...>` |\r\n| `<object>` | `<link rel=preload as=object href=...>` |\r\n| `<iframe>`, `<frame>` | `<link rel=preload as=document href=...>` |\r\n| HTML | `<link rel=preload as=html href=...>` |\r\n\r\n可以看到，Prefetch的可选资源类型非常丰富，除了我们常用的`script`和`style`，甚至还包括XHR、video、img等，基本涵盖了Web中的各类资源。为了解决Prefetch中某些资源（例如XHR）的跨域问题，可以为其应用CORS属性。一个基本的Prefetch写法也很简单：\r\n\r\n```html\r\n<link rel=\"prefetch\" href=\"/my.little.script.js\" as=\"script\">\r\n```\r\n\r\n### 1.4. Prerender\r\n\r\n上一部分我们讲了Prefetch，而Prerender则是Prefetch的更进一步。可以粗略地理解为“预处理”（预执行）。\r\n\r\n通过Prerender“预处理”的资源，浏览器都会作为HTML进行处理。浏览器除了会去获取资源，还可能会预处理（MAY preprocess）该资源，而该HTML页面依赖的其他资源，像`<script>`、`<style>`等页面所需资源也可能会被处理。但是预处理会由于浏览器或当前机器、网络情况的不同而被不同程度地推迟。例如，会根据CPU、GPU和内存的使用情况，以及请求操作的幂等性而选择不同的策略或阻止该操作。\r\n\r\n注意，由于这些预处理操作的不可控性，当你只是需要能够预先获取部分资源来加速后续可能出现的网络请求时，建议使用Prefetch。当使用Prerender时，为了保证兼容性，目标页面可以监听`visibilitychange`事件并使用`document.visibilityState`来判断页面状态。\r\n\r\n> When prerendering a document the user agent MUST set the document's visibilityState value to prerender. —— W3C Working Draft\r\n\r\nPrerender的使用方式非常简单，与DNS Prefetch和Preconnect类似，指定`rel`属性为`prerender`：\r\n\r\n```html\r\n<link rel=\"prerender\" href=\"//yourwebsite.com/nextpage.html\">\r\n```\r\n## 2. Resource Hint的具体使用方式\r\n\r\n在上面的部分里，我主要介绍了DNS Prefetch、Preconnect、Prefetch和Prerender这四种RHL（Resource Hint Link），并且简单介绍了如何在`link`中使用它们。然而除了直接在HTML中加入对应`link`标签外，还可以通过其他几种方式触发浏览器的Resource Hint。为了更加直观，下面我们还是以[图书搜索这个demo](https://github.com/alienzhou/learning-pwa/tree/resource-hint)为例来看看可以通过哪些方法来使用Resource Hint。\r\n\r\n> 假设已经为该demo添加详情页`nextpage.html`及其依赖的`nextpage.js`，当点击列表中的图书时会进行跳转。\r\n\r\n### 2.1. 文档head中的link元素\r\n\r\n这是Resource Hint最常用的一种方式，我们上面介绍的各种示例也就是使用的这种方式。例如想要指定Prefetch `nextpage.js`脚本可以这么写：\r\n\r\n```html\r\n<link rel=\"prefetch\" href=\"./nextpage.js\" as=\"script\">\r\n```\r\n\r\n### 2.2. HTTP Link头字段\r\n\r\n可以通过[Link HTTP header](https://tools.ietf.org/html/rfc5988)来使用Resource Hint。Link HTTP header和`link`元素是等价的。\r\n \r\n> The Link entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the <LINK> element in HTML, as well as the atom:link feed-level element in Atom. —— RFC5988\r\n\r\n[`Link`主要由两部分组成](https://tools.ietf.org/html/rfc5988#page-7)——`URI-Reference`和`link-param`。`URI-Reference`相当于`link`元素中的`href`属性；`link-param`则包括了`rel`、`title`、`type`等一系列元素属性，使用`;`分割。因此可以在响应头中添加以下部分：\r\n\r\n```text\r\nLink: </nextpage.js>; rel=\"prefetch\"; as=\"script\"\r\n```\r\n\r\n[我们的demo](https://github.com/alienzhou/learning-pwa/tree/resource-hint)使用了koa-static这个中间件，只要做如下修改即可：\r\n\r\n```javascript\r\n// app.js\r\napp.use(serve(__dirname + '/public', {\r\n    maxage: 1000 * 60 * 60,\r\n    setHeaders: (res, path, stats) => {\r\n        if (/index.html/.test(path)) {\r\n            res.setHeader('Link', '</nextpage.js>; rel=\"prefetch\"; as=\"script\"');\r\n        }\r\n    }\r\n}));\r\n```\r\n\r\n你会发现，在访问`index.html`时，浏览器就会向服务器请求`nextpage.js`这个页面本身并“不需要”用到的资源。\r\n\r\n\r\n### 2.3. 向文档动态添加link元素\r\n\r\n`link`元素也支持我们通过js动态向文档添加。对于动态添加的RHL，浏览器也会对其应用Resource Hint策略。添加`link`的方式和添加普通dom元素一致。\r\n\r\n```js\r\nvar hint = document.createElement('link');\r\nhint.rel = 'prefetch';\r\nhint.as = 'script';\r\nhint.href = '/nextpage.js';\r\ndocument.head.appendChild(hint);\r\n```\r\n\r\n### 2.4. 改变已有link元素的href属性\r\n\r\n当你改变页面中原有RHL的`href`属性（或者prefetch时的`as`属性）时，会立即触发对新资源的Resource Hint。例如在如下代码执行后\r\n\r\n```js\r\nvar hint = document.querySelector('[rel=\"prefetch\"]');\r\nhint.href = './the.other.nextpage.js';\r\n```\r\n\r\n浏览器相当于接收到了新的Resource Hint“指示”，并在合适的时机向服务端请求`the.other.nextpage.js`这个资源。注意，当你修改`as`属性时，也会触发Resource Hint。\r\n\r\n注意，如果你想通过修改已有`link`元素预获取`nextpage.html`这个资源，然后像下面这样写会触发两次请求。\r\n\r\n```js\r\nvar hint = document.querySelector('[rel=\"prefetch\"]');\r\nhint.as = 'html'; // 触发第一次请求，再次请求./nextpage.js\r\nhint.href = './nextpage.html'; // 请求./nextpage.html\r\n```\r\n\r\n## 2. Preload\r\n既然提到了Resource Hint，那么不得不介绍一下与其类似的Preload。在遇到需要Preload的资源时，浏览器会 **立刻** 进行预获取，并将结果放在内存中，资源的获取不会影响页面parse与load事件的触发。直到再次遇到该资源的使用标签时，才会执行。\r\n\r\n> (Preload) Initiating an early fetch and separating fetching from resource execution.\r\n\r\n例如下面这个HTML片段：\r\n\r\n```html\r\n<head>\r\n    <link rel=\"preload\" href=\"./nextpage.js\" as=\"script\">\r\n    <script type=\"text/javascript\" src=\"./current.js\"></script>\r\n    <script type=\"text/javascript\" src=\"./nextpage.js\"></script>\r\n<head>\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/23/164c687371151554?w=1337&h=583&f=gif&s=1585124)\r\n\r\n浏览器首先会去获取`nextpage.js`，然后获取并执行`current.js`，最后，遇到使用`nextpage.js`资源的`script`标签时，将已经获取的`nextpage.js`执行。由于我们会将`script`标签置于body底部来保证性能，因此可以考虑在head标签中添加这些资源的Preload来加速页面的加载与渲染。\r\n\r\n更进一步，我们还可以监听Preload的情况，并触发自定以操作\r\n\r\n```html\r\n<script>\r\n  function preloadFinished(e) { ... }\r\n  function preloadError(e)  { ... }\r\n</script>\r\n<!-- listen for load and error events -->\r\n<link rel=\"preload\" href=\"app.js\" as=\"script\" onload=\"preloadFinished()\" onerror=\"preloadError()\">\r\n```\r\n\r\n正如在引言中所提到的，在过去如果我们想预加载一些资源都会用一些应用层面的技术手段，但往往会遇到两个问题：\r\n\r\n- 我们需要先获取资源，然后在适当时执行，但两者并不易于分离\r\n- 无论哪种技术实现，都会带来一定的性能与体验损伤\r\n\r\nPreload（包括前文提到的Prefetch等RHL）给我们带来的价值就是从浏览器层面很好地将资源的加载与执行分离了，并在浏览器层面来保证良好的性能体验。\r\n\r\n看到这里，也许你会疑惑，都是会预获取资源，都是资源的获取与执行分离，那么Preload与Prefetch有什么区别呢？\r\n\r\n这是它最容易与Prefetch混淆的地方。在标准里有这么一段话解释两者区别：\r\n\r\n> The application can use the preload keyword to initiate <u>**early, high-priority, and non-render-blocking**</u> fetch of a CSS resource that can then be applied by the application at appropriate time\r\n\r\n与Prefetch相比，Preload会[强制浏览器立即获取资源，并且该请求具有较高的优先级](https://www.w3.org/TR/preload/#x2.link-type-preload)（mandatory and high-priority），因此建议对一些**当前页面会马上用到**资源使用Preload；相对的，Prefetch的资源获取则是可选与较低优先级的，其是否获取完全取决于浏览器的决定，适用于预获取**将来可能会用到**的资源。\r\n\r\n为了节省不必要的带宽消耗，如果Preload的资源在3s内没有被使用，Chrome控制台会出现类似下图的警告。这时你就需要仔细思考，该资源是否有必要Preload了。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/7/23/164c675aabb374df?w=1536&h=98&f=png&s=52630)\r\n\r\n更多Preload与Prefetch的细节差异可以看这里 —— [Preload, Prefetch And Priorities in Chrome](https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf)。\r\n\r\n## 3. 写在最后\r\n\r\n本文介绍了如何使用Resource Hint（以及Preload）来提升页面加载性能与体验，简单来说：\r\n\r\n- DNS Prefetch 可以帮助我们进行DNS预查询；\r\n- Preconnect 可以帮助我们进行预连接，例如在一些重定向技术中，可以让浏览器和最终目标源更早建立连接；\r\n- Prefetch 可以帮助我们预先获取所需资源（并且不用担心该资源会被执行），例如我们可以根据用户行为猜测其下一步操作，然后动态预获取所需资源；\r\n- Prerender 则会更进一步，不仅获取资源，还会预加载（执行）部分资源，因此如果我们Prerender下一个页面，打开该页面时会让用户感觉非常流畅；\r\n- Preload 则像是 Prefetch的升级版，会强制立即高优获取资源，非常适合Preload（尽早获取）一些关键渲染路径中的资源。\r\n\r\n虽然，大部分PWA相关资料中并不会提及Resource Hint，但是正如我在[第一篇文章](https://github.com/alienzhou/blog/issues/2)中提到的\r\n\r\n> PWA本身其实是一个概念集合，它不是指某一项技术，而是通过一系列的Web技术与Web标准来优化Web App的安全、性能和体验。\r\n\r\nResource Hint显然符合这一点。\r\n\r\n我们不应该将PWA局限在Service Worker离线缓存、提醒通知这些常见的PWA内容中，希望读者也能开阔思维，理解PWA背后的概念与思想。因此，在后续文章中我也会介绍前端存储(sessionStorage/localStorage/indexDB)、HTTP/2.0以及PWA进展等相关内容。\r\n\r\n在下一篇里，我们会一起来学习Google开源的PWA离线工具集 —— workbox。通过workbox，我们可以学习<u>**各类离线策略**</u>，并且了解一些生产环境中需要考虑的问题。部分开源PWA解决方案也是基于workbox进行封装的。\r\n\r\n## 参考资料\r\n\r\n- [Resource Hints W3C Working Draft 15 January 2018](https://www.w3.org/TR/resource-hints/)\r\n- [Preload W3C Candidate Recommendation 26 October 2017](https://www.w3.org/TR/preload/)\r\n- [Preload, Prefetch And Priorities in Chrome](https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf)\r\n- [Web Linking](https://tools.ietf.org/html/rfc5988)\r\n- [Page Visibility Level 2 W3C Proposed Recommendation 17 October 2017](https://www.w3.org/TR/page-visibility/)\r\n- [CORS settings attributes](https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes)\r\n- [Content Security Policy Level 3 W3C Working Draft, 13 September 2016](https://www.w3.org/TR/CSP3/)\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/10","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/10/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/10/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/10/events","html_url":"https://github.com/alienzhou/blog/issues/10","id":390623297,"node_id":"MDU6SXNzdWUzOTA2MjMyOTc=","number":10,"title":"【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T10:53:55Z","updated_at":"2018-12-13T10:54:16Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第九篇文章。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n## 引言\r\n在前八篇文章中，我已经介绍了一些PWA中的常见技术与使用方式。虽然我们已经学习了很多相关知识，但是，还是有很多问题在实践时才会暴露出来。这篇文章是一篇TroubleShooting，总结了我近期在PWA实践过程中遇到了一些问题，以及这些问题的解决方案。希望能帮助一些遇到类似问题的朋友。\r\n\r\n## 1. Service Worker Scope\r\n\r\n> 注意Service Worker注册时的作用范围（scope）\r\n\r\n### 1.1. 遇到的问题\r\n我在页面`/home`下注册了Service Worker：\r\n\r\n```javascript\r\nnavigator.serviceWorker.register('/static/home/js/sw.js')\r\n```\r\n\r\n通过在`.then()`中调用`console.log()`可以发现Service Worker其实注册成功了，但是在页面中却不生效。这是为什么呢？\r\n\r\n### 1.2. 产生的原因\r\n\r\n我在前几篇介绍Service Worker的文章中没有过多强调Scope的概念：\r\n\r\n> scope: A USVString representing a URL that defines a service worker's registration scope; what range of URLs a service worker can control. This is usually a relative URL. The default value is the URL you'd get if you resolved './' using the service worker script's location as the base.\r\n\r\nScope规定了Service Worker的作用（URL）范围。例如，一个注册在`https://www.sample.com/list`路径下的Service Worker，其作用的范围只能是它本身与它的子路径：\r\n\r\n- `https://www.sample.com/list`\r\n- `https://www.sample.com/list/book`\r\n- `https://www.sample.com/list/book/comic`\r\n\r\n而在`https://www.sample.com`、`https://www.sample.com/book`这些路径下则是无效的。\r\n\r\n同时，scope的默认值为`./`（注意，这里所有的相对路径不是相对于页面，而是相对于sw.js脚本的）。因此，`navigator.serviceWorker.register('/static/home/js/sw.js')`代码中的scope实际上是`/static/home/js`，Service Worker也就注册在了`/static/home/js`路径下，显然无法在`/home`下生效。\r\n\r\n这种情况非常常见：我们会把`sw.js`这样的文件放置在项目的静态目录下（例如文中的`/static/home/js`），而并非页面路径下。显然，要解决这个问题需要设置相应的scope。\r\n\r\n然而，另一个问题出现了。如果你直接将scope设置为`/home`：\r\n\r\n```javascript\r\nnavigator.serviceWorker.register('/static/home/js/sw.js', {scope: '/home'})\r\n```\r\n\r\n在chrome控制台会看到如下的错误提示：\r\n\r\n```\r\nUncaught (in promise) DOMException: Failed to register a ServiceWorker: The path of the provided scope ('/home') is not under the max scope allowed ('/static/home/js/'). \r\nAdjust the scope, move the Service Worker script, or use the Service-Worker-Allowed HTTP header to allow the scope.\r\n```\r\n\r\nStackOverflow上对此的解释是：\r\n\r\n> Service workers can only intercept requests originating in the scope of the current directory that the service worker script is located in and its subdirectories.\r\n\r\n简单来说，Service Worker只允许注册在Service Worker脚本所处的路径及其子路径下。显然，我上面的代码触碰到了这个规则。那怎么办呢？\r\n\r\n### 1.3. 解决方案\r\n\r\n解决这个问题的方式主要有两种。\r\n\r\n#### 方法一：修改路由，让sw.js的访问路径处于合适的位置\r\n\r\n```javascript\r\nrouter.get('/sw.js', function (req, res) {\r\n    res.sendFile(path.join(__dirname, '../../static/kspay-home/static/js/sw/', 'sw.js'));\r\n});\r\n```\r\n\r\n以上是一个express中简单的路由。通过路由设置，我们将Service Worker脚本路径置于根目录下，这样就可以设置scope为`/home`而不会违反其规则了：\r\n\r\n```javascript\r\nnavigator.serviceWorker\r\n    .register('/static/home/js/sw.js', {\r\n        scope: '/home'\r\n    })\r\n```\r\n\r\n#### 方法二：添加`Service-Worker-Allowed`响应头\r\n\r\nscope的规范有时候过于严格了。因此，浏览器也提供了一种方式来使我们可以越过这种限制。方法就是设置`Service-Worker-Allowed`响应头。\r\n\r\n以express中的静态服务中间件serve-static为例，[进行相应配置](https://github.com/expressjs/serve-static#options)：\r\n\r\n```javascript\r\noptions: {\r\n    maxAge: 0,\r\n    setHeaders: function (res, path, stat) {\r\n        // 添加Service-Worker-Allowed，扩展service worker的scope\r\n        if (/\\/sw\\/.+\\.js/.test(path)) {\r\n            res.set({\r\n                'Content-Type': 'application/javascript',\r\n                'Service-Worker-Allowed': '/home'\r\n            });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 2. CORS\r\n\r\n> 跨域资源的缓存报错\r\n\r\n### 2.1. 遇到的问题\r\n\r\n在《【PWA学习与实践】(3) 让你的WebApp离线可用》中我介绍了如何用Service Worker进行缓存以实现离线功能。其中，为了提高体验，我们会在Service Worker安装时缓存静态文件，实现这一功能的部分代码如下：\r\n\r\n```javascript\r\n// 监听install事件，安装完成后，进行文件缓存\r\nself.addEventListener('install', e => {\r\n    var cacheOpenPromise = caches.open(cacheName).then(function (cache) {\r\n        return cache.addAll(cacheFiles);\r\n    });\r\n    e.waitUntil(cacheOpenPromise);\r\n});\r\n```\r\n\r\n`cacheFiles`就是需要缓存的静态文件列表。然而Service Worker运行后，在application tab中发现`cacheFiles`的静态资源并未被缓存下来。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/26/1639b2f3954721b0?w=620&h=200&f=png&s=18505)\r\n\r\n### 2.2. 产生的原因\r\n\r\n切换到Console可以看到类似如下的报错信息：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/26/1639b385aac7ce3c?w=757&h=69&f=png&s=32044)\r\n\r\n前端同学对这个问题非常熟悉：**跨域问题**。\r\n\r\n为了使我们的页面能够顺利加载CDN等外站资源，浏览器在`script`、`link`、`img`等标签上放松了跨域限制。这使得我们在页面中通过`script`标签来加载javascript脚本是不会导致跨域问题的（经典的jsonp就是以此为基础实现的）。\r\n\r\n然而在Service Worker中使用`cache.addAll()`则会通过类似fetch请求的方式来获取资源（类似在页面中使用XHR请求外站脚本），是会受到跨域资源策略限制而无法缓存到本地的。\r\n\r\n在实际生产环境中，为了缩短请求的响应时间与、减轻服务器压力，通常我们都会将javascript、css、image这些静态资源通过CDN进行分发，或者将其放置在一些独立的静态服务集群中。所以线上的静态资源基本都是“跨站资源”。\r\n\r\n### 2.3. 解决方案\r\n\r\n该问题其实不算是Service Worker中的特定问题，解决方式和处理一般的跨域问题类似，可以设置`Access-Control-Allow-Origin`响应头来解决。\r\n\r\n- 如果使用CDN，可以在CDN服务中进行配置。一般的CDN服务是会支持配置HTTP响应头的；\r\n- 如果使用自己搭建的静态服务器集群，可以对服务器进行相应配置。这里有一个[仓库](https://github.com/h5bp/server-configs)包含ngix、apache、iis等常用服务器的配置，可以参考。\r\n\r\n## 3. iOS standalone 模式\r\n\r\n> iOS standalone模式下的特殊处理\r\n\r\n### 3.1. 遇到的问题\r\n\r\n今年年初Apple宣布在iOS safari 11.3中支持Service Worker，这对PWA的推广起到了重要的作用，让我们可以“跨平台”来实现PWA技术。\r\n\r\n虽然，iOS safari不支持manifest配置来实现添加到桌面，但是我在《【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”》中介绍了如何用safari自有的meta标签来实现standalone模式。\r\n\r\n不过，问题就出在了standalone模式上。抛开iOS safari standalone模式现有的一些其他小bug（包括状态栏的显示、白屏、重复添加等），iOS safari standalone模式有一个无法回避的重大问题。其源于iOS与android的一个重要区别：\r\n\r\niOS没有后退键，而一般android机都有。\r\n\r\n在iOS上使用standalone模式添加的应用，由于没有浏览器的工具栏，所以无法进行后退。例如我打开首页，然后点击首页课程列表中的一门课程后，浏览器跳转到课程页，由于iOS没有后退键，所以你无法再回到首页，除非杀死“应用”重新启动。\r\n\r\n### 3.2. 产生的原因\r\n\r\n正如上面所提到的，由于iOS没有后退键，而standalone模式会隐藏浏览器工具条和导航条，因此，在iOS中使用保存到桌面的WebApp，就像是一次不能回头的旅行……\r\n\r\n### 3.3. 解决方案\r\n\r\n显然，这种体验是无法接受的。目前我采用的解决方案非常简单，在打开页面时进行判断，如果是iOS中的standalone模式，则在页面右上角显示一个“返回”小图标。点击图标返回上一个页面。\r\n\r\niOS中有一个专门的属性来判断是否为standalone模式：\r\n\r\n```javascript\r\nif ('standalone' in window.navigator && window.navigator.standalone) {\r\n    // standalone模式进行特殊处理，例如展示返回按钮\r\n    backBtn.show();\r\n}\r\n```\r\n\r\n使用history API即可实现按钮的后退功能：\r\n\r\n```javascript\r\nbackBtn.addEventListener('click', function () {\r\n    window.history.back();\r\n});\r\n```\r\n\r\n## 4. 图片策略\r\n\r\n> 解决PWA离线资源中非缓存图片资源的展示\r\n\r\n### 4.1. 遇到的问题\r\n在实际使用中，为了满足一定的离线功能，我缓存了一些变化频率极小的API数据，例如个人中心里的列表信息。而列表中包含了较多的图片。为了节省了用户的存储空间，对于图片资源我并未选择缓存。\r\n\r\n这导致了一个问题：离线情况下，虽然用户能正常看到列表信息，但是其中的图片部分都是类似下面这种“图裂了”的情况，体验不太好。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/25/16397f563295ef0e?w=1422&h=470&f=png&s=27924)\r\n\r\n### 4.2. 产生的原因\r\n\r\n原因上面已经解释了，离线状态下无法请求到图片资源，所以在一些浏览器中就会表现出这种“图挂了”的状态。\r\n\r\n### 4.3. 解决方案\r\n\r\n解决这个体验问题的大致思路如下：\r\n\r\n1. 首先，需要在本地缓存占位图资源\r\n2. 其次，在获取图片时判断是否出现错误\r\n3. 最后，在错误时使用占位图进行替换\r\n\r\n由于只是缓存占位图，而占位图一般较为固定，只会有有限的几种尺寸样式，因此不会产生太多缓存空间的占用。占位图的缓存完全可以在缓存静态资源时一起进行。\r\n\r\n而图片获取出错（可能是网络原因，也可能是URL错误）时，进行占位图的替换有两种简单的方式：\r\n\r\n**方法一：在fetch事件中监听图片资源，出错时使用占位图**\r\n\r\n```javascript\r\nself.addEventListener('fetch', e => {\r\n    if (/\\.png|jpeg|jpg|gif/i.test(e.request.url)) {\r\n        e.respondWith(\r\n            fetch(e.request).then(response => {\r\n                return response;\r\n            }).catch(err => {\r\n                // 请求错误时使用占位图\r\n                return caches.match(placeholderPic).then(cache => cache);\r\n            })\r\n        );\r\n        return;\r\n    }\r\n```\r\n\r\n**方法二：通过img标签的onerror属性来请求占位图**\r\n\r\n先将img标签改为\r\n\r\n```HTML\r\n<img class=\"list-cover\"\r\n    src=\"//your.sample.com/1234.png\"\r\n    alt=\"{{ item.desc }}\"\r\n    onerror=\"javascript:this.src='https://your.sample.com/placeholder.png'\"/>   \r\n```\r\n\r\n`onerror`属性中指定的方法会在图片加载错误时替换`src`；同时我们将Service Worker中的代码进行调整：\r\n\r\n```javascript\r\nself.addEventListener('fetch', e => {\r\n    if (/\\.png|jpeg|jpg|gif/i.test(e.request.url)) {\r\n        e.respondWith(\r\n            fetch(e.request).then(response => {\r\n                return response;\r\n            // 触发onerror后，img会再次请求图片placeholder.png\r\n            // 由于无网络连接，此fetch依然会出错\r\n            }).catch(err => {\r\n                // 由于我们事先缓存了placeholder.png，这里会返回缓存结果\r\n                return caches.match(e.request).then(cache => cache);\r\n            })\r\n        );\r\n        return;\r\n    }\r\n```\r\n\r\n## 5. 写在最后\r\n\r\n本文总结了一些我在进行PWA升级实践中遇到的问题，希望对遇到类似问题的朋友能够有一些启发或帮助。\r\n\r\n在下一篇文章中，我会回到PWA相关技术，介绍Resource Hint，以及如何使用Resource Hint来提高页面的加载性能，提升用户体验。\r\n\r\n## 参考资料\r\n### Service Worker Scope\r\n- [Service Worker Scope (MDN)](https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer/register#%E5%8F%82%E6%95%B0)\r\n- [Understanding Service Worker scope](https://stackoverflow.com/questions/35780397/understanding-service-worker-scope)\r\n- [How exactly add “Service-Worker-Allowed” to register service worker scope in upper folder](https://stackoverflow.com/questions/49084718/how-exactly-add-service-worker-allowed-to-register-service-worker-scope-in-upp)\r\n\r\n### CORS\r\n- [What limitations apply to opaque responses?](https://stackoverflow.com/questions/39109789/what-limitations-apply-to-opaque-responses)\r\n- [Handle Third Party Requests](https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests)\r\n- [CORS settings attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes)\r\n- [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)\r\n- [Git Repo: server configs](https://github.com/h5bp/server-configs)\r\n\r\n### iOS standalone\r\n- [Don’t use iOS meta tags irresponsibly in your Progressive Web Apps](https://medium.com/@firt/dont-use-ios-web-app-meta-tag-irresponsibly-in-your-progressive-web-apps-85d70f4438cb)\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/9","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/9/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/9/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/9/events","html_url":"https://github.com/alienzhou/blog/issues/9","id":390622897,"node_id":"MDU6SXNzdWUzOTA2MjI4OTc=","number":9,"title":"【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T10:52:49Z","updated_at":"2018-12-13T10:52:49Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第八篇文章。本文中的代码可以在[learning-pwa的sync分支](https://github.com/alienzhou/learning-pwa/tree/sync)上找到（`git clone`后注意切换到sync分支）。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n\r\n## 1. 引言\r\n生活中经常会有这样的场景：\r\n\r\n用户拿出手机，浏览着我们的网站，发现了一个很有趣的信息，点击了“提交”按钮。然而不幸的是，这时用户到了一个网络环境极差的地方，或者是根本没有网络。他能够做的只有看着页面上的提示框和不断旋转的等待小圆圈。1s、5s、30s、1min……无尽的等待后，用户将手机放回了口袋，而这一次的请求也被终止了——由于当下极差的网络终止在了客户端。\r\n\r\n上面的场景其实暴露了两个问题：\r\n\r\n1. 普通的页面发起的请求会随着浏览器进程的结束/或者Tab页面的关闭而终止；\r\n2. 无网环境下，没有一种机制能“维持”住该请求，以待有网情况下再进行请求。\r\n\r\n然而，Service Worker的后台同步功能规避了这些缺陷。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/13/163598ca174364ed?w=800&h=499&f=gif&s=2269837)\r\n\r\n下面就让我们先来了解下后台同步（Background Sync）的工作原理。\r\n\r\n## 2. 后台同步(Background Sync)是如何工作的？\r\n\r\n后台同步应该算是Service Worker相关功能（API）中比较易于理解与使用的一个。\r\n\r\n其大致的流程如下：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/13/1635905056b125a7?w=573&h=129&f=png&s=8623)\r\n\r\n1. 首先，你需要在Service Worker中监听sync事件；\r\n2. 然后，在浏览器中发起后台同步sync（图中第一步）；\r\n3. 之后，会触发Service Worker的sync事件，在该监听的回调中进行操作，例如向后端发起请求（图中第二步）\r\n4. 最后，可以在Service Worker中对服务端返回的数据进行处理。\r\n\r\n由于Service Worker在用户关闭该网站后仍可以运行，因此该流程名为“后台同步”实在是非常贴切。\r\n\r\n怎么样，在我们已经有了一定的Service Worker基础之后，后台同步这一功能相比之前的功能，是不是非常易于理解？\r\n\r\n## 3. 如何使用后台同步功能？\r\n\r\n既然已经理解了该功能的大致流程，那么接下来就让我们来实际操作一下吧。\r\n\r\n### 3.1 client触发sync事件\r\n\r\n```javascript\r\n// index.js\r\nnavigator.serviceWorker.ready.then(function (registration) {\r\n    var tag = \"sample_sync\";\r\n    document.getElementById('js-sync-btn').addEventListener('click', function () {\r\n        registration.sync.register(tag).then(function () {\r\n            console.log('后台同步已触发', tag);\r\n        }).catch(function (err) {\r\n            console.log('后台同步触发失败', err);\r\n        });\r\n    });\r\n});\r\n```\r\n由于后台同步功能需要在Service Worker注册完成后触发，因此较好的一个方式是在`navigator.serviceWorker.ready`之后绑定相关操作。例如上面的代码中，我们在ready后绑定了按钮的点击事件。当按钮被点击后，会使用`registration.sync.register()`方法来触发Service Worker的sync事件。\r\n\r\n`registration.sync`返回一个[`SyncManager`对象](https://developer.mozilla.org/en-US/docs/Web/API/SyncManager)，其上包含`register`和`getTags`两个方法：\r\n\r\n> `register()` Create a new sync registration and return a Promise. \r\n\r\n> `getTags()` Return a list of developer-defined identifiers for SyncManager registration.\r\n\r\n`register()`方法可以注册一个后台同步事件，其中接收的参数`tag`用于作为这个后台同步的唯一标识。\r\n\r\n当然，如果想要代码更健壮的话，我们还需要在调用前进行特性检测：\r\n\r\n```javascript\r\n// index.js\r\nif ('serviceWorker' in navigator && 'SyncManager' in window) {\r\n    // ……\r\n}\r\n```\r\n\r\n### 3.2 在Service Worker中监听sync事件\r\n当client触发了sync事件后，剩下的就交给Service Worker。理论上此时就不需要client（前端站点）参与了。例如另一个经典场景：用户离开时页面（unload）时在client端触发sync事件，剩下的操作交给Service Worker，Service Worker的操作可以在离开页面后正常进行。\r\n\r\n像添加fetch和push事件监听那样，我们可以为Service Worker添加sync事件的监听：\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('sync', function (e) {\r\n    // ……\r\n});\r\n```\r\n\r\n在sync事件的event对象上可以取到tag值，该值就是我们在上一节注册sync时的唯一标识。通过这个tag就可以区分出不同的后台同步事件。例如，当该值为'sample_sync'时我们向后端发送一个请求：\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('sync', function (e) {\r\n    console.log(`service worker需要进行后台同步，tag: ${e.tag}`);\r\n    var init = {\r\n        method: 'GET'\r\n    };\r\n    if (e.tag === 'sample_sync') {\r\n        var request = new Request(`sync?name=AlienZHOU`, init);\r\n        e.waitUntil(\r\n            fetch(request).then(function (response) {\r\n                response.json().then(console.log.bind(console));\r\n                return response;\r\n            })\r\n        );\r\n    }\r\n});\r\n```\r\n这里我通过`e.tag`来判断client触发的不同sync事件，并在监听到tag为'sample_sync'的sync事件后，构建了一个request对象，使用fetch API来进行后端请求。\r\n\r\n需要特别注意的是，fetch请求一定要放在`e.waitUntil()`内。因为我们要保证“后台同步”，将Promise对象放在`e.waitUntil()`内可以确保在用户离开我们的网站后，Service Worker会持续在后台运行，等待该请求完成。\r\n\r\n### 3.3 完善我们的后端服务\r\n实际上，经过上面两小节，我们的大致工作已经完成。不过还缺少一个小环节：我们的KOA服务器上还没有sync路由和接口。添加一下，以保证demo可以正常运行：\r\n\r\n```javascript\r\n// app.js\r\nrouter.get('/sync', async (ctx, next) => {\r\n    console.log(`Hello ${ctx.request.query.name}, I have received your msg`);\r\n    ctx.response.body = {\r\n        status: 0\r\n    };\r\n});\r\n```\r\n\r\n### 3.4 Demo效果展示\r\n\r\n下面就来看一下这个demo的运行效果：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/13/1635975104e68836?w=800&h=499&f=gif&s=1947627)\r\n\r\n可以看到，在网络环境正常的情况下，点击“同步”按钮会立即触发Service Worker中的sync事件监听，并向服务端发送请求；而在断网情况下，点击“同步”按钮，控制台虽然显示注册了同步事件，但是并不会触发Service Worker的sync监听回调，指到恢复网络连接，才会在后台（Service Worker）中进行相关处理。\r\n\r\n下面再来看一下触发sync事件后，关闭网站的效果：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/13/163598ca174364ed?w=800&h=499&f=gif&s=2269837)\r\n\r\n可以看到，即使在关闭网站后再重新连接网络，服务端依然可以收到来自客户端的请求（说明Service Worker在后台进行了相关处理）。\r\n\r\n## 4. 如何在后台同步时获取所需的数据？\r\n\r\n其实上一节结束，我们就已经可以了解最基础的后台同步功能了。而这部分则会进一步探讨后台同步中的一个重要问题：如何在后台同步时获取并发送client中的数据？\r\n\r\n例如在我们的上一个Demo中，用户的姓名name是硬编码在Service Worker中的，而实际上，我们希望能在页面上提供一个输入框，将用户的输入内容在后台同步中进行发送。\r\n\r\n实现的方式有两种：使用postMessage或使用indexedDB。\r\n\r\n### 4.1 使用postMessage\r\n\r\n我们知道，在浏览器主线程与Web Worker线程之间可以通过postMessage来进行通信。因此，我们也可以使用这个方法来向Service Worker“传输”数据。\r\n\r\n大致思路如下：\r\n\r\n1. client触发sync事件；\r\n2. 在sync注册完成后，使用postMessage和Service Worker通信；\r\n3. 在Service Worker的sync事件回调中等待message事件的消息；\r\n4. 收到message事件的消息后，将其中的信息提交到服务端。\r\n\r\n```javascript\r\n// index.js\r\n// 使用postMessage来传输sync数据\r\nnavigator.serviceWorker.ready.then(function (registration) {\r\n    var tag = 'sample_sync_event';\r\n\r\n    document.getElementById('js-sync-event-btn').addEventListener('click', function () {\r\n        registration.sync.register(tag).then(function () {\r\n            console.log('后台同步已触发', tag);\r\n\r\n            // 使用postMessage进行数据通信\r\n            var inputValue = document.querySelector('#js-search-input').value;\r\n            var msg = JSON.stringify({type: 'bgsync', msg: {name: inputValue}});\r\n            navigator.serviceWorker.controller.postMessage(msg);\r\n        }).catch(function (err) {\r\n            console.log('后台同步触发失败', err);\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n在`registration.sync.register`完成后，调用`navigator.serviceWorker.controller.postMessage`来向Service Worker Post数据。\r\n\r\n为了提高代码的可维护性，我在sw.js中创建了一个`SimpleEvent`类，你可以把它看做一个最简单的EventBus。用来解耦Service Worker的message事件和sync事件。\r\n\r\n```javascript\r\n// sw.js\r\nclass SimpleEvent {\r\n    constructor() {\r\n        this.listenrs = {};\r\n    }\r\n\r\n    once(tag, cb) {\r\n        this.listenrs[tag] || (this.listenrs[tag] = []);\r\n        this.listenrs[tag].push(cb);\r\n    }\r\n\r\n    trigger(tag, data) {\r\n        this.listenrs[tag] = this.listenrs[tag] || [];\r\n        let listenr;\r\n        while (listenr = this.listenrs[tag].shift()) {\r\n            listenr(data)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在message事件中监听client发来的消息，并通过SimpleEvent通知所有监听者。\r\n\r\n```javascript\r\n// sw.js\r\nconst simpleEvent = new SimpleEvent();\r\nself.addEventListener('message', function (e) {\r\n    var data = JSON.parse(e.data);\r\n    var type = data.type;\r\n    var msg = data.msg;\r\n    console.log(`service worker收到消息 type：${type}；msg：${JSON.stringify(msg)}`);\r\n\r\n    simpleEvent.trigger(type, msg);\r\n});\r\n```\r\n\r\n在sync事件中，使用SimpleEvent监听bgsync来获取数据，然后再调用fetch方法。注意，由于`e.waitUntil()`需要接收Promise作为参数，因此需要对`SimpleEvent.once`进行Promisfy。\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('sync', function (e) {\r\n    if (e.tag === xxx) {\r\n        // ……\r\n    }\r\n\r\n    // sample_sync_event同步事件，使用postMessage来进行数据通信\r\n    else if (e.tag === 'sample_sync_event') {\r\n        // 将SimpleEvent.once封装为Promise调用\r\n        let msgPromise = new Promise(function (resolve, reject) {\r\n            // 监听message事件中触发的事件通知\r\n            simpleEvent.once('bgsync', function (data) {\r\n                resolve(data);\r\n            });\r\n            // 五秒超时\r\n            setTimeout(resolve, 5000);\r\n        });\r\n\r\n        e.waitUntil(\r\n            msgPromise.then(function (data) {\r\n                var name = data && data.name ? data.name : 'anonymous';\r\n                var request = new Request(`sync?name=${name}`, init);\r\n                return fetch(request)\r\n            }).then(function (response) {\r\n                response.json().then(console.log.bind(console));\r\n                return response;\r\n            })\r\n        );\r\n    }\r\n});\r\n```\r\n\r\n是不是非常简单？\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/14/1635a5723bed476c?w=800&h=499&f=gif&s=2772919)\r\n\r\n进行后台同步时，使用postMessage来实现client向Service Worker的传输数据，方便与直观，是一个不错的方法。\r\n\r\n### 4.2 使用indexedDB\r\n\r\n在client与Servcie Worker之间同步数据，还有一个可行的思路：client先将数据存在某处，待Servcie Worker需要时再读取使用即可。\r\n\r\n为此需要找一个存数据的地方。你第一个想到的可能就是localStorage了。\r\n\r\n然而，不知道你是否还记得我在最开始介绍Service Worker时所提到的，为了保证性能，实现部分操作的非阻塞，在Service Worker中我们经常会碰到异步操作（因此大多数API都是Promise形式的）。那么像localStorage这样的同步API会变成异步化么？答案很简单：不会，并且localStorage在Servcie Worker中无法调用。\r\n\r\n不过不要气馁，我们还另一个强大的数据存储方式——indexedDB。它是可以在Service Worker中使用的。对于indexedDB的使用方式，本系列后续会有文章具体介绍，因此在这里的就不重点讲解indexedDB的使用方式了。\r\n\r\n首先，需要一个方法用于连接数据库并创建相应的store：\r\n\r\n```javascript\r\n// index.js\r\nfunction openStore(storeName) {\r\n    return new Promise(function (resolve, reject) {\r\n        if (!('indexedDB' in window)) {\r\n            reject('don\\'t support indexedDB');\r\n        }\r\n        var request = indexedDB.open('PWA_DB', 1);\r\n        request.onerror = function(e) {\r\n            console.log('连接数据库失败');\r\n            reject(e);\r\n        }\r\n        request.onsuccess = function(e) {\r\n            console.log('连接数据库成功');\r\n            resolve(e.target.result);\r\n        }\r\n        request.onupgradeneeded = function (e) {\r\n            console.log('数据库版本升级');\r\n            var db = e.srcElement.result;\r\n            if (e.oldVersion === 0) {\r\n                if (!db.objectStoreNames.contains(storeName)) {\r\n                    var store = db.createObjectStore(storeName, {\r\n                        keyPath: 'tag'\r\n                    });\r\n                    store.createIndex(storeName + 'Index', 'tag', {unique: false});\r\n                    console.log('创建索引成功');\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n然后，在`navigator.serviceWorker.ready`中打开该数据库连接，并在点击按钮时，先将数据存入indexedDB，再注册sync：\r\n\r\n```javascript\r\n// index.js\r\nnavigator.serviceWorker.ready.then(function (registration) {\r\n    return Promise.all([\r\n        openStore(STORE_NAME),\r\n        registration\r\n    ]);\r\n}).then(function (result) {\r\n    var db = result[0];\r\n    var registration = result[1];\r\n    var tag = 'sample_sync_db';\r\n\r\n    document.getElementById('js-sync-db-btn').addEventListener('click', function () {\r\n        // 将数据存储进indexedDB\r\n        var inputValue = document.querySelector('#js-search-input').value;\r\n        var tx = db.transaction(STORE_NAME, 'readwrite');\r\n        var store = tx.objectStore(STORE_NAME);\r\n        var item = {\r\n            tag: tag,\r\n            name: inputValue\r\n        };\r\n        store.put(item);\r\n\r\n        registration.sync.register(tag).then(function () {\r\n            console.log('后台同步已触发', tag);\r\n        }).catch(function (err) {\r\n            console.log('后台同步触发失败', err);\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n同样的，在Service Worker中也需要相应的数据库连接方法：\r\n\r\n```javascript\r\n// sw.js\r\nfunction openStore(storeName) {\r\n    return new Promise(function (resolve, reject) {\r\n        var request = indexedDB.open('PWA_DB', 1);\r\n        request.onerror = function(e) {\r\n            console.log('连接数据库失败');\r\n            reject(e);\r\n        }\r\n        request.onsuccess = function(e) {\r\n            console.log('连接数据库成功');\r\n            resolve(e.target.result);\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n并且在sync事件的回调中，get到indexedDB中对应的数据，最后再向后端发送请求：\r\n\r\n```javascript\r\n// index.js\r\nself.addEventListener('sync', function (e) {\r\n    if (e.tag === xxx) {\r\n        // ……\r\n    }\r\n    else if (e.tag === yyy) {\r\n        // ……\r\n    }\r\n    \r\n    // sample_sync_db同步事件，使用indexedDB来获取需要同步的数据\r\n    else if (e.tag === 'sample_sync_db') {\r\n        // 将数据库查询封装为Promise类型的请求\r\n        var dbQueryPromise = new Promise(function (resolve, reject) {\r\n            var STORE_NAME = 'SyncData';\r\n            // 连接indexedDB\r\n            openStore(e.tag).then(function (db) {\r\n                try {\r\n                    // 创建事务进行数据库查询\r\n                    var tx = db.transaction(STORE_NAME, 'readonly');\r\n                    var store = tx.objectStore(STORE_NAME);\r\n                    var dbRequest = store.get(e.tag);\r\n                    dbRequest.onsuccess = function (e) {\r\n                        resolve(e.target.result);\r\n                    };\r\n                    dbRequest.onerror = function (err) {\r\n                        reject(err);\r\n                    };\r\n                }\r\n                catch (err) {\r\n                    reject(err);\r\n                }\r\n            });\r\n        });\r\n\r\n        e.waitUntil(\r\n            // 通过数据库查询获取需要同步的数据\r\n            dbQueryPromise.then(function (data) {\r\n                console.log(data);\r\n                var name = data && data.name ? data.name : 'anonymous';\r\n                var request = new Request(`sync?name=${name}`, init);\r\n                return fetch(request)\r\n            }).then(function (response) {\r\n                response.json().then(console.log.bind(console));\r\n                return response;\r\n            })\r\n        );\r\n    }\r\n});\r\n```\r\n\r\n相比于postMessage，使用indexedDB的方案要更复杂一点。它比较适用于一些需要数据持久化的场景。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/14/1635a579ba845ce7?w=800&h=499&f=gif&s=953776)\r\n\r\n## 5. 兼容性\r\n\r\n依照惯例，我们还是来简单看一下文中相关功能的兼容性。\r\n\r\n先是[Background Sync](https://caniuse.com/#search=Background%20Sync%20API)：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/13/16359f504955c8b8?w=1240&h=592&f=png&s=134469)\r\n\r\n令人悲伤的是，基本只有Google自家的Chrome可用。\r\n\r\n然后是[indexedDB](https://caniuse.com/#search=indexedDB)：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/13/16359f671e79ba6b?w=1240&h=580&f=png&s=155435)\r\n\r\n相较于Background Sync还是有着不错的兼容性的。而且在safari（包括iOS safari）中也得到了支持。\r\n\r\n## 6. 写在最后\r\n从文中的内容以及[google developer中的一些实例](https://developers.google.com/web/updates/2015/12/background-sync#the_solution)来看，Background Sync是一个非常有潜力的API。然而令人堪忧的兼容性在一定程度上限制了它的发挥空间。不过，作为一项技术，还是非常值得我们学习与了解的。\r\n\r\n本文中所有的代码示例均可以在[learn-pwa/sync](https://github.com/alienzhou/learning-pwa/tree/sync)上找到。\r\n\r\n如果你喜欢或想要了解更多的PWA相关知识，欢迎关注我，关注《PWA学习与实践》系列文章。我会总结整理自己学习PWA过程的遇到的疑问与技术点，并通过实际代码和大家一起实践。\r\n\r\n到目前为止，我们已经学习了PWA中的多个知识点，在其基础上，已经可以帮助我们进行原有站点的PWA升级。学习是一方面，实践是另一方面。在下一篇文章里，我会整理一些在业务中升级PWA时碰到的问题，以及对应的解决方案。\r\n\r\n## 参考资料\r\n- [Web Background Synchronization](https://wicg.github.io/BackgroundSync/spec/)\r\n- [MDN: SyncManager](https://developer.mozilla.org/en-US/docs/Web/API/SyncManager)\r\n- [MDN: SyncManager.register()](https://developer.mozilla.org/en-US/docs/Web/API/SyncManager/register)\r\n- [MDN: SyncRegistration](https://developer.mozilla.org/en-US/docs/Web/API/SyncRegistration)\r\n- [Introducing Background Sync](https://developers.google.com/web/updates/2015/12/background-sync)\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/8","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/8/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/8/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/8/events","html_url":"https://github.com/alienzhou/blog/issues/8","id":390622345,"node_id":"MDU6SXNzdWUzOTA2MjIzNDU=","number":8,"title":"【PWA学习与实践】(7)使用Notification API来进行消息提醒","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T10:51:21Z","updated_at":"2018-12-13T10:51:45Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第七篇文章。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n本文中的代码可以在[learning-pwa的notification分支](https://github.com/alienzhou/learning-pwa/tree/notification)上找到（`git clone`后注意切换到notification分支）。\r\n\r\n## 1. 引言\r\n在第五篇文章《Web中进行服务端消息推送》中，我介绍了如何使用Push API进行服务端消息推送。提到Push就不得不说与其联系紧密的另一个API——Notification API。它让我们可以在“网站外”显示消息提示：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631a562ba773ddd?w=1275&h=762&f=gif&s=384884)\r\n\r\n即使当你切换到其他Tab，也可以通过提醒交互来快速让用户回到你的网站；甚至当用户离开当前网站，仍然可以收到系统的提醒消息，并且可以通过消息提醒快速打开你的网站。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631b52052cccb59?w=1270&h=676&f=gif&s=2317289)\r\n\r\nNotification的功能本身与Push并不耦合，你完全可以只使用Notification API或者Push API来构建Web App的某些功能。因此，本文会先介绍如何使用Notification API。然后，作为Notification的“黄金搭档”，本文还会介绍如何组合使用Push & Notification（消息推送与提醒）。\r\n\r\n## 2. 使用Notification API\r\n在这第二节里，我们先来了解如何独立使用Notification功能。相较于第五篇中的Push功能，Notification API更加简洁易懂。\r\n\r\n### 2.1. 获取提醒权限\r\n\r\n首先，进行调用消息提醒API需要获得用户的授权。\r\n\r\n在调用Notification相关API之前，需要先使用`Notification`对象上的静态方法`Notification.requestPermission()`来获取授权。由于`Notification.requestPermission()`在某些版本浏览器中会接收一个回调函数（`Notification.requestPermission(callback)`）作为参数，而在另一些浏览器版本中会返回一个promise，因此将该方法进行包装，统一为promise调用：\r\n\r\n```javascript\r\n// index.js\r\nfunction askPermission() {\r\n    return new Promise(function (resolve, reject) {\r\n        var permissionResult = Notification.requestPermission(function (result) {\r\n            resolve(result);\r\n        });\r\n  \r\n        if (permissionResult) {\r\n            permissionResult.then(resolve, reject);\r\n        }\r\n    }).then(function (permissionResult) {\r\n        if (permissionResult !== 'granted') {\r\n            throw new Error('We weren\\'t granted permission.');\r\n        }\r\n    });\r\n}\r\n\r\n\r\nregisterServiceWorker('./sw.js').then(function (registration) {\r\n    return Promise.all([\r\n        registration,\r\n        askPermission()\r\n    ])\r\n })\r\n```\r\n我们创建了一个`askPermission()`方法来统一`Notification.requestPermission()`的调用形式，并在Service Worker注册完成后调用该方法。调用`Notification.requestPermission()`获取的`permissionResult`可能的值为：\r\n\r\n- denied：用户拒绝了通知的显示\r\n- granted：用户允许了通知的显示\r\n- default：因为不知道用户的选择，所以浏览器的行为与denied时相同\r\n\r\nchrome中，可以在`chrome://settings/content/notifications`里进行通知的设置与管理。\r\n\r\n### 2.2. 设置你的提醒内容\r\n获取用户授权后，我们就可以通过`registration.showNotification()`方法进行消息提醒了。\r\n\r\n当我们注册完Service Worker后，`then`方法的回调函数会接收一个`registration`参数，通过调用其上的`showNotification()`方法即可触发提醒：\r\n\r\n```javascript\r\n// index.js\r\nregisterServiceWorker('./sw.js').then(function (registration) {\r\n    return Promise.all([\r\n        registration,\r\n        askPermission()\r\n    ])\r\n}).then(function (result) {\r\n    var registration = result[0];\r\n    /* ===== 添加提醒功能 ====== */\r\n    document.querySelector('#js-notification-btn').addEventListener('click', function () {\r\n        var title = 'PWA即学即用';\r\n        var options = {\r\n            body: '邀请你一起学习',\r\n            icon: '/img/icons/book-128.png',\r\n            actions: [{\r\n                action: 'show-book',\r\n                title: '去看看'\r\n            }, {\r\n                action: 'contact-me',\r\n                title: '联系我'\r\n            }],\r\n            tag: 'pwa-starter',\r\n            renotify: true\r\n        };\r\n        registration.showNotification(title, options);\r\n    });\r\n    /* ======================= */\r\n})\r\n```\r\n\r\n上面这段代码为页面上的button添加了一个click事件监听：当点击后，调用`registration.showNotification()`方法来显示消息提醒，该方法接收两个参数：`title`与`option`。`title`用来设置该提醒的主标题，`option`中则包含了一些其他设置。\r\n\r\n- body：提醒的内容\r\n- icon：提醒的图标\r\n- actions：提醒可以包含一些自定义操作\r\n- tag：相当于是ID，通过该ID标识可以操作特定的notification\r\n- renotify：是否允许重复提醒，默认为false。当不允许重复提醒时，同一个tag的notification只会显示一次\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631a6c6007ffec9?w=800&h=300&f=jpeg&s=114296)\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631a6f12cc17f0c?w=800&h=161&f=jpeg&s=66563)\r\n\r\n> 注意，由于不同浏览器中，对于`option`属性的支持情况并不相同。部分属性在一些浏览器中并不支持。\r\n\r\n### 2.3. 捕获用户的点击\r\n在上一部分中，我们已经为Web App添加了提醒功能。点击页面中的“提醒”按钮，系统就会弹出提醒框，并展示相关提醒消息。\r\n\r\n然而更多的时候，我们并不仅仅希望只展示有限的信息，更希望能引导用户进行交互。例如推荐一本新书，让用户点击阅读或购买。在上一部分我们设置的提醒框中，包含了“去看看”和“联系我”两个按钮选项，那么怎么做才能捕获用户的点击操作，并且知道用户点击了哪个呢？这一小节，就会告诉你如何实现。\r\n\r\n还记的上一部分里我们定义的actions么？\r\n\r\n```javascript\r\n…\r\nactions: [{\r\n    action: 'show-book',\r\n    title: '去看看'\r\n    }, {\r\n    action: 'contact-me',\r\n    title: '联系我'\r\n}]\r\n…\r\n```\r\n为了能够响应用户对于提醒框的点击事件，我们需要在Service Worker中监听`notificationclick`事件。在该事件的回调函数中我们可以获取点击的相关信息：\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('notificationclick', function (e) {\r\n    var action = e.action;\r\n    console.log(`action tag: ${e.notification.tag}`, `action: ${action}`);\r\n    \r\n    switch (action) {\r\n        case 'show-book':\r\n            console.log('show-book');\r\n            break;\r\n        case 'contact-me':\r\n            console.log('contact-me');\r\n            break;\r\n        default:\r\n            console.log(`未处理的action: ${e.action}`);\r\n            action = 'default';\r\n            break;\r\n    }\r\n    e.notification.close();\r\n});\r\n```\r\n\r\n`e.action`获取的值，就是我们在`showNotification()`中定义的actions里的action。因此，通过`e.action`就可以知道用户点击了哪一个操作选项。注意，当用户点击提醒本身时，也会触发`notificationclick`，但是不包含任何action值，所以在代码中将其置于default默认操作中。\r\n\r\n现在试一下，我们就可以捕获用户对于不同选项的点击了。点击后在Console中会有不同的输出。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631a855e6ac1712?w=1120&h=188&f=png&s=52210)\r\n\r\n### 2.4. Service Worker与client通信\r\n到目前为止，我们已经可以顺利得给用户展示提醒，并且在用户操作提醒后准确捕获到用户的操作。然而，还缺最重要的一步——针对不同的操作，触发不同的交互。例如，\r\n- 点击提醒本身会弹出书籍简介；\r\n- 点击“看一看”会给用户展示本书的详情；\r\n- 点击“联系我”会向应用管理者发邮件等等。\r\n\r\n这里有个很重要的地方：我们在Service Worker中捕获用户操作，但是需要在client（这里的client是指前端页面的脚本环境）中触发相应操作（调用页面方法/进行页面跳转…）。因此，这就需要让Service Worker与client进行通信。通信包括下面两个部分：\r\n\r\n1. 在Service Worker中使用Worker的`postMessage()`方法来通知client：\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('notificationclick', function (e) {\r\n    …… // 略去上一节内容\r\n    \r\n    e.waitUntil(\r\n        // 获取所有clients\r\n        self.clients.matchAll().then(function (clients) {\r\n            if (!clients || clients.length === 0) {\r\n                return;\r\n            }\r\n            clients.forEach(function (client) {\r\n                // 使用postMessage进行通信\r\n                client.postMessage(action);\r\n            });\r\n        })\r\n    );\r\n});\r\n```\r\n\r\n2. 在client中监听`message`事件，判断`data`，进行不同的操作：\r\n\r\n```javascript\r\n// index.js\r\nnavigator.serviceWorker.addEventListener('message', function (e) {\r\n    var action = e.data;\r\n    console.log(`receive post-message from sw, action is '${e.data}'`);\r\n    switch (action) {\r\n        case 'show-book':\r\n            location.href = 'https://book.douban.com/subject/20515024/';\r\n            break;\r\n        case 'contact-me':\r\n            location.href = 'mailto:someone@sample.com';\r\n            break;\r\n        default:\r\n            document.querySelector('.panel').classList.add('show');\r\n            break;\r\n    }\r\n});\r\n```\r\n\r\n当用户点击提醒后，我们在`notificationclick`监听中，将action通过`postMessage()`通信给client；然后在client中监听`message`事件，基于action（`e.data`）来进行不同的操作（跳转到图书详情页/发送邮件/显示简介面板）。\r\n\r\n至此，一个比较简单与完整的消息提醒（Notification）功能就完成了。\r\n\r\n然而目前的消息提醒还存在一定的局限性。例如，只有在用户访问网站期间才能有机会触发提醒。正如本文一开始所说，Push & Notification的结合将会帮助我们构筑一个强大推送与提醒功能。下面就来看下它们的简单结合。\r\n\r\n## 3. 消息推送与提醒\r\n在第五篇《Web中进行服务端消息推送》最后，我们通过监听`push`事件来处理服务端推送：\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('push', function (e) {\r\n    var data = e.data;\r\n    if (e.data) {\r\n        data = data.json();\r\n        console.log('push的数据为：', data);\r\n        self.registration.showNotification(data.text);        \r\n    } \r\n    else {\r\n        console.log('push没有任何数据');\r\n    }\r\n});\r\n```\r\n\r\n简单修改以上代码，与我们本文中的提醒功能相结合：\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('push', function (e) {\r\n    var data = e.data;\r\n    if (e.data) {\r\n        data = data.json();\r\n        console.log('push的数据为：', data);\r\n        var title = 'PWA即学即用';\r\n        var options = {\r\n            body: data,\r\n            icon: '/img/icons/book-128.png',\r\n            image: '/img/icons/book-521.png', // no effect\r\n            actions: [{\r\n                action: 'show-book',\r\n                title: '去看看'\r\n            }, {\r\n                action: 'contact-me',\r\n                title: '联系我'\r\n            }],\r\n            tag: 'pwa-starter',\r\n            renotify: true\r\n        };\r\n        self.registration.showNotification(title, options);        \r\n    } \r\n    else {\r\n        console.log('push没有任何数据');\r\n    }\r\n});\r\n```\r\n\r\n使用Push来向用户推送信息，并在Service Worker中直接调用Notification API来展示该信息的提醒框。这样，即使是在用户关闭该Web App时，依然可以收到提醒，类似于Native中的消息推送与提醒。\r\n\r\n我们还可以将这个功能再丰富一些。由于用户在关闭该网站时仍然可以收到提醒，因此加入一些更强大功能：\r\n- 当用户切换到其他Tab时，点击提醒会立刻回到网站的tab；\r\n- 当用户未打开该网站时，点击提醒可以直接打开网站。\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('notificationclick', function (e) {\r\n    var action = e.action;\r\n    console.log(`action tag: ${e.notification.tag}`, `action: ${action}`);\r\n    \r\n    switch (action) {\r\n        case 'show-book':\r\n            console.log('show-book');\r\n            break;\r\n        case 'contact-me':\r\n            console.log('contact-me');\r\n            break;\r\n        default:\r\n            console.log(`未处理的action: ${e.action}`);\r\n            action = 'default';\r\n            break;\r\n    }\r\n    e.notification.close();\r\n\r\n    e.waitUntil(\r\n        // 获取所有clients\r\n        self.clients.matchAll().then(function (clients) {\r\n            if (!clients || clients.length === 0) {\r\n                // 当不存在client时，打开该网站\r\n                self.clients.openWindow && self.clients.openWindow('http://127.0.0.1:8085');\r\n                return;\r\n            }\r\n            // 切换到该站点的tab\r\n            clients[0].focus && clients[0].focus();\r\n            clients.forEach(function (client) {\r\n                // 使用postMessage进行通信\r\n                client.postMessage(action);\r\n            });\r\n        })\r\n    );\r\n});\r\n```\r\n\r\n注意这两行代码，第一行会在网站关闭时打开该网站，第二行会在存在tab时自动切换到网站的tab。\r\n\r\n```javascript\r\nself.clients.openWindow && self.clients.openWindow('http://127.0.0.1:8085');\r\n\r\nclients[0].focus && clients[0].focus();\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631b52052cccb59?w=1270&h=676&f=gif&s=2317289)\r\n\r\n## 4. MacOS Safari中的Web Notification\r\n看一下[Web Notification的兼容性](https://caniuse.com/#search=notification)：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631afa349ff2f0c?w=2344&h=918&f=png&s=222023)\r\n\r\n目前移动端浏览器普遍还不支持该特性。但是在Mac OS上的safari里面是支持该特性的，不过其调用方式与上文代码有些不太一样。在safari中使用Web Notification不是调用`registration.showNotification()`方法，而是需要创建一个Notification对象。\r\n\r\n```javascript\r\n// index.js\r\n……\r\ndocument.querySelector('#js-notification-btn').addEventListener('click', function () {\r\n    var title = 'PWA即学即用';\r\n    var options = {\r\n        body: '邀请你一起学习',\r\n        icon: '/img/icons/book-128.png',\r\n        actions: [{\r\n            action: 'show-book',\r\n            title: '去看看'\r\n        }, {\r\n            action: 'contact-me',\r\n            title: '联系我'\r\n        }],\r\n        tag: 'pwa-starter',\r\n        renotify: true\r\n    };\r\n    // registration.showNotification(title, options);\r\n\r\n    // 使用Notification构造函数创建提醒框\r\n    // 而非registration.showNotification()方法\r\n    var notification = new Notification(title, options);\r\n});\r\n……\r\n```\r\nNotification对象继承自EventTarget接口，因此在safari中需要通过添加click事件的监听来触发提醒框的交互操作：\r\n\r\n```javascript\r\n// index.js\r\nnotification.addEventListener('click', function (e) {\r\n    document.querySelector('.panel').classList.add('show');\r\n});\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/5/1/1631b1ef1e592c36?w=677&h=369&f=gif&s=308375)\r\n\r\n该功能示例可以在[learn-pwa/notify4safari](https://github.com/alienzhou/learning-pwa/tree/notify4safari)中找到。\r\n\r\n## 5. 写在最后\r\nWeb Notification是一个非常强大的API，尤其在和Push结合后，为WebApp带来了类似Native的丰富能力。\r\n\r\n本文中所有的代码示例均可以在[learn-pwa/notification](https://github.com/alienzhou/learning-pwa/tree/notification)上找到。\r\n\r\n到目前为止，我们已经学习了[Manifest](https://github.com/alienzhou/blog/issues/3)、[离线缓存](https://github.com/alienzhou/blog/issues/4)、[消息推送](https://github.com/alienzhou/blog/issues/6)、消息提醒、[Debug](https://github.com/alienzhou/blog/issues/7)等一些基础知识。在下一篇文章里，我们会继续了解与学习PWA中的一个重要功能——后台同步。\r\n\r\n## 参考资料\r\n- [MDN: notification](https://developer.mozilla.org/zh-CN/docs/Web/API/notification)\r\n- [MDN: ServiceWorkerRegistration.showNotification()](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification)\r\n- [MDN: WindowClient](https://developer.mozilla.org/en-US/docs/Web/API/WindowClient)\r\n- [MDN: Clients](https://developer.mozilla.org/en-US/docs/Web/API/Clients)\r\n- [WWDC2013](https://developer.apple.com/videos/play/wwdc2013/614/)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/7","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/7/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/7/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/7/events","html_url":"https://github.com/alienzhou/blog/issues/7","id":390621274,"node_id":"MDU6SXNzdWUzOTA2MjEyNzQ=","number":7,"title":"【PWA学习与实践】(6) 在Chrome中调试你的PWA","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T10:48:31Z","updated_at":"2018-12-13T10:48:39Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第六篇文章。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n前几篇文章介绍了PWA中的一些功能与背后的技术。工欲善其事，必先利其器。这一篇会介绍如何调试我们的PWA。\r\n\r\n## Service Worker\r\n新版的chrome调试工具中集成了Service Worker调试工具。\r\n\r\n开启chrome调试工具，选择Application选项卡。在左侧的列表选择Application --> Service Worker，就会显示当前站点下的Service Worker。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/16310656fb567e8f?w=1196&h=494&f=png&s=88288)\r\n\r\n在Service Worker下有三个复选框：\r\n\r\n- Offline：切换为无网环境。通过勾选可以方便查看应用在无网环境中的表现。\r\n- Update on reload：每次reload都更新Service Worker。一般来说，当访问站点发现Service Worker有更新后，为了保证本次访问，不会立即激活新的Service Worker，只会在安装后进入等待状态，在下一次访问时激活。勾选该选项就可以使每次Reload后都重新安装与激活Service Worker。\r\n- Bypass for network：使用网络请求。我们知道Service Worker可以拦截客户端请求，勾选该选项后所有请求都会直接走网络请求。\r\n\r\n\r\n面板右上角的Upadte按钮可以手动触发Service Worker的更新；而Unregister类似于代码中的unregister，用于注销当前的Service Worker。\r\n\r\n从下方“Service workers from other domain”中，可以查看在这个client上所有注册过的Service Worker：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/163107b914043f63?w=1195&h=894&f=png&s=129528)\r\n\r\nService Worker主面板区域包括了：Source、Status、Clients、Push和Sync五个项目。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/163106e9284cbc26?w=601&h=242&f=png&s=28360)\r\n\r\n- Source：展示了当前注册所使用的Service Worker脚本（sw.js），点击可以查看脚本内容。同时还展示了该Service Worker的安装时间。\r\n- Status：展示Service Worker所处的生命周期。通过点击stop按钮可以暂停该Service Worker。其中，`#1201`表示Service Worker的版本，当sw.js文件未更改时，reload站点该数字是不会增加的；但是当勾选Update on reload后，由于每次reload都会触发Service Worker重新安装，因此该数字会增加。\r\n- Clients：显示了当前Service Worker所作用的root。focus按钮用来帮你快速切换到该Service Worker对应的tab（当你打开多个站点的tab时，点击可以快速切换）。\r\n- Push：用来模拟进行推送。\r\n- Sync：用来模拟进行后台同步。\r\n\r\n在Service Worker中`console.log`的信息也会显示在Console中。此外，由于默认情况下，reload页面会清空console，为了保存一些日志信息，可以打开Preserve log来保留Console信息。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/163108561231f344?w=1195&h=264&f=png&s=73587)\r\n\r\n## Manifest\r\n在Application中，点击Manifest即可看到当前应用所使用的Manifest配置：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/163108efbea4b61d?w=1196&h=748&f=png&s=78387)\r\n\r\n同样，点击manifest.json出链接可以查看manifest文件。点击“Add to homescreen”可以把应用添加到桌面。除了点击“Add to homescreen”，也可以使用chrome中的添加到应用文件夹。\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/1631097d137fb789?w=285&h=437&f=png&s=53243)\r\n\r\n## Cache\r\n除了Service Worker与Manifest，在我们的WebApp中还用到了Cache。在Application中也支持查看Cache：在Cache列表的Cache Storage中查看。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/163109e551b9cd0f?w=1197&h=393&f=png&s=89517)\r\n\r\n其中bs-0-2-0和api-0-1-1就是我们的“图书搜索”Web App所创建与使用的两个cache。在bs-0-2-0中缓存了包括页面、js、css、图片在内的一些静态资源；在而api-0-1-1中则缓存了图书检索的XHR请求。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/16310a142d0c794d?w=1197&h=503&f=png&s=116464)\r\n\r\n如果想删除某些cache，可以右键点击，然后选择Delete；也可以点击上方的×。除了在这里清除cache，还可以在Application下的Clear Storage中清除包括Service Worker、Cache与Storage（cookie/localstorage/IndexedDB……）等数据。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/29/16310a439ef7c605?w=1196&h=664&f=png&s=88822)\r\n\r\n## 写在最后\r\n\r\n在下一篇文章里，我们会继续了解另一个经常与Push API组合在一起的功能——消息提醒，Notification API。\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/6","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/6/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/6/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/6/events","html_url":"https://github.com/alienzhou/blog/issues/6","id":390620823,"node_id":"MDU6SXNzdWUzOTA2MjA4MjM=","number":6,"title":"【PWA学习与实践】(5)在Web中进行服务端消息推送","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2018-12-13T10:47:26Z","updated_at":"2020-07-28T08:59:20Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第五篇文章。文中的代码都可以在[learning-pwa的push分支](https://github.com/alienzhou/learning-pwa/tree/push)上找到（`git clone`后注意切换到push分支）。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n## 1. 引言\r\n在之前的几篇文章中，我和大家分享了如何使用manifest（以及meta标签）让你的Web App更加“native”；以及如何使用Service Worker来cache资源，加速Web App的访问速度，提供部分离线功能。在接下来的内容里，我们会探究PWA中的另一个重要功能——消息推送与提醒（Push & Notification）。这个能力让我们可以从服务端向用户推送各类消息并引导用户触发相应交互。\r\n\r\n![Web Push效果](https://user-gold-cdn.xitu.io/2018/4/13/162bc97ba69e1679?w=1284&h=746&f=gif&s=1843125)\r\n\r\n实际上，消息推送与提醒是两个功能——Push API 和 Notification API。为了大家能够更好理解其中的相关技术，我也会分为Push（推送消息）与Notification（展示提醒）两部分来介绍。在这一篇里，我们先来学习如何使用Push API进行消息推送。\r\n\r\n> Push API 和 Notification API其实是两个独立的技术，完全可以分开使用；不过Push API 和 Notification API相结合是一个常见的模式。\r\n\r\n## 2. 浏览器是如何实现服务器消息Push的\r\nWeb Push的整个流程相较之前的内容来说有些复杂。因此，在进入具体技术细节之前，我们需要先了解一下整个Push的基本流程与相关概念。\r\n\r\n如果你对Push完全不了解，可能会认为，Push是我们的服务端直接与浏览器进行交互，使用长连接、WebSocket或是其他技术手段来向客户端推送消息。然而，这里的Web Push并非如此，它其实是一个三方交互的过程。\r\n\r\n在Push中登场的三个重要“角色”分别是：\r\n- 浏览器：就是我们的客户端\r\n- Push Service：专门的Push服务，你可以认为是一个第三方服务，目前chrome与firefox都有自己的Push Service Service。理论上只要浏览器支持，可以使用任意的Push Service\r\n- 后端服务：这里就是指我们自己的后端服务\r\n\r\n下面就介绍一下这三者在Web Push中是如何交互。\r\n\r\n### 2.1. 消息推送流程\r\n下图来自[Web Push协议草案](https://tools.ietf.org/html/draft-ietf-webpush-protocol-12)，是Web Push的整个流程：\r\n\r\n```\r\n    +-------+           +--------------+       +-------------+\r\n    |  UA   |           | Push Service |       | Application |\r\n    +-------+           +--------------+       |   Server    |\r\n        |                      |               +-------------+\r\n        |      Subscribe       |                      |\r\n        |--------------------->|                      |\r\n        |       Monitor        |                      |\r\n        |<====================>|                      |\r\n        |                      |                      |\r\n        |          Distribute Push Resource           |\r\n        |-------------------------------------------->|\r\n        |                      |                      |\r\n        :                      :                      :\r\n        |                      |     Push Message     |\r\n        |    Push Message      |<---------------------|\r\n        |<---------------------|                      |\r\n        |                      |                      |\r\n```\r\n\r\n该时序图表明了Web Push的各个步骤，我们可以将其分为订阅（subscribe）与推送（push）两部分来看。\r\n\r\n- **subscribe**，首先是订阅：\r\n    1. Ask Permission：这一步不再上图的流程中，这其实是浏览器中的策略。浏览器会询问用户是否允许通知，只有在用户允许后，才能进行后面的操作。\r\n    1. Subscribe：浏览器（客户端）需要向Push Service发起订阅（subscribe），订阅后会得到一个[`PushSubscription`](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)对象\r\n    2. Monitor：订阅操作会和Push Service进行通信，生成相应的订阅信息，Push Service会维护相应信息，并基于此保持与客户端的联系；\r\n    3. Distribute Push Resource：浏览器订阅完成后，会获取订阅的相关信息（存在于`PushSubscription`对象中），我们需要将这些信息发送到自己的服务端，在服务端进行保存。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/12/162ba587f2a42eca?w=832&h=207&f=png&s=28689)\r\n\r\n- **Push Message**，然后是推送：\r\n    1. Push Message阶段一：我们的服务端需要推送消息时，不直接和客户端交互，而是通过Web Push协议，将相关信息通知Push Service；\r\n    2. Push Message阶段二：Push Service收到消息，通过校验后，基于其维护的客户端信息，将消息推送给订阅了的客户端；\r\n    3. 最后，客户端收到消息，完成整个推送过程。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/12/162ba59261481104?w=817&h=218&f=png&s=31789)\r\n\r\n### 2.2. 什么是Push Service\r\n在上面的Push流程中，出现了一个比较少接触到的角色：Push Service。那么什么是Push Service呢？\r\n\r\n> A push service receives a network request, validates it and delivers a push message to the appropriate browser.\r\n\r\nPush Service可以接收网络请求，校验该请求并将其推送给合适的浏览器客户端。Push Service还有一个非常重要的功能：当用户离线时，可以帮我们保存消息队列，直到用户联网后再发送给他们。\r\n\r\n目前，不同的浏览器厂商使用了不同的Push Service。例如，chrome使用了google自家的FCM（前身为GCM），firefox也是使用自家的服务。那么我们是否需要写不同的代码来兼容不同的浏览器所使用的服务呢？答案是并不用。Push Service遵循[Web Push Protocol](https://tools.ietf.org/html/draft-ietf-webpush-protocol-12)，其规定了请求及其处理的各种细节，这就保证了，不同的Push Service也会具有标准的调用方式。\r\n\r\n这里再提一点：我们在上一节中说了Push的标准流程，其中第一步就是浏览器发起订阅，生成一个`PushSubscription`对。Push Service会为每个发起订阅的浏览器生成一个唯一的URL，这样，我们在服务端推送消息时，向这个URL进行推送后，Push Service就会知道要通知哪个浏览器。而这个URL信息也在`PushSubscription`对象里，叫做`endpoint`。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/14/162bfd2d499ba656?w=1408&h=300&f=png&s=86505)\r\n\r\n那么，如果我们知道了`endpoint`的值，是否就代表我们可以向客户端推送消息了呢？并非如此。下面会简单介绍一下Web Push中的安全策略。\r\n\r\n### 2.3. 如何保证Push的安全性\r\n在Web Push中，为了保证客户端只会收到其订阅的服务端推送的消息（其他的服务端即使在拿到`endpoint`也无法推送消息），需要对推送信息进行数字签名。该过程大致如下：\r\n\r\n在Web Push中会有一对公钥与私钥。客户端持有公钥，而服务端持有私钥。客户端在订阅时，会将公钥发送给Push Service，而Push Service会将该公钥与相应的`endpoint`维护起来。而当服务端要推送消息时，会使用私钥对发送的数据进行数字签名，并根据数字签名生成一个叫`Authorization`请求头。Push Service收到请求后，根据`endpoint`取到公钥，对数字签名解密验证，如果信息相符则表明该请求是通过对应的私钥加密而成，也表明该请求来自浏览器所订阅的服务端。反之亦然。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/12/162ba68f0d4a5861?w=998&h=441&f=png&s=83966)\r\n\r\n而公钥与私钥如何生成，会在第三部分的实例中讲解。\r\n\r\n## 3. 如何使用Push API来推送向用户推送信息\r\n到这里，我们已经基本了解了Web Push的流程。光说不练假把式，下面我就通过具体代码来说明如何使用Web Push。\r\n\r\n这部分会基于[sw-cache](https://github.com/alienzhou/learning-pwa/tree/sw-cache)分支上的代码，继续增强我们的“图书搜索”WebApp。\r\n\r\n为了使文章与代码更清晰，将Web Push分为这几个部分：\r\n1. 浏览器发起订阅，并将订阅信息发送至后端；\r\n2. 将订阅信息保存在服务端，以便今后推送使用；\r\n3. 服务端推送消息，向Push Service发起请求；\r\n4. 浏览器接收Push信息并处理。\r\n\r\n> 友情提醒：由于Chrome所依赖的Push Service——FCM在国内不可访问，所以要正常运行demo中的代码需要“梯子”，或者可以选择Firefox来进行测试。\r\n\r\n### 3.1. 浏览器（客户端）生成subscription信息\r\n首先，我们需要使用`PushManager`的`subscribe`方法来在浏览器中进行订阅。\r\n\r\n在《让你的WebApp离线可用》中我们已经知道了如何注册Service Worker。当我们注册完Service Worker后会得到一个`Registration`对象，通过调用`Registration`对象的`registration.pushManager.subscribe()`方法可以发起订阅。\r\n\r\n为了使代码更清晰，本篇demo在之前的基础上，先抽离出Service Worker的注册方法：\r\n\r\n```javascript\r\n// index.js\r\nfunction registerServiceWorker(file) {\r\n    return navigator.serviceWorker.register(file);\r\n}\r\n```\r\n\r\n然后定义了`subscribeUserToPush()`方法来发起订阅：\r\n\r\n```javascript\r\n// index.js\r\nfunction subscribeUserToPush(registration, publicKey) {\r\n    var subscribeOptions = {\r\n        userVisibleOnly: true,\r\n        applicationServerKey: window.urlBase64ToUint8Array(publicKey)\r\n    }; \r\n    return registration.pushManager.subscribe(subscribeOptions).then(function (pushSubscription) {\r\n        console.log('Received PushSubscription: ', JSON.stringify(pushSubscription));\r\n        return pushSubscription;\r\n    });\r\n}\r\n\r\n```\r\n\r\n这里使用了`registration.pushManager.subscribe()`方法中的两个配置参数：`userVisibleOnly`和`applicationServerKey`。\r\n\r\n- `userVisibleOnly`表明该推送是否需要显性地展示给用户，即推送时是否会有消息提醒。如果没有消息提醒就表明是进行“静默”推送。在Chrome中，必须要将其设置为`true`，否则浏览器就会在控制台报错：\r\n\r\n![userVisibleOnly不为true时的报错信息](https://user-gold-cdn.xitu.io/2018/4/13/162ba99a6b69af03?w=1458&h=120&f=png&s=58047)\r\n\r\n- `applicationServerKey`是一个客户端的公钥，[VAPID](https://tools.ietf.org/html/draft-thomson-webpush-vapid-02)定义了其规范，因此也可以称为VAPID keys。如果你还记得2.3中提到的安全策略，应该对这个公钥不陌生。该参数需要Unit8Array类型。因此定义了一个[`urlBase64ToUint8Array`](https://github.com/alienzhou/learning-pwa/blob/push/public/base64util.js)方法将base64的公钥字符串转为Unit8Array。`subscribe()`也是一个Promise方法，在then中我们可以得到订阅的相关信息——一个`PushSubscription`对象。下图展示了这个对象中的一些信息。注意其中的`endpoint`，Push Service会为每个客户端随机生成一个不同的值.\r\n\r\n![PushSubscription信息](https://user-gold-cdn.xitu.io/2018/4/14/162bfd2d499ba656?w=1408&h=300&f=png&s=86505)\r\n\r\n之后，我们再将`PushSubscription`信息发送到后端。这里定义了一个`sendSubscriptionToServer()`方法，该方法就是一个普通的XHR请求，会向接口post订阅信息，为了节约篇幅就不列出具体代码了。\r\n\r\n最后，将这一系列方法组合在一起。当然，使用Web Push前，还是需要进行特性检测`'PushManager' in window`。\r\n\r\n```javascript\r\n// index.js\r\nif ('serviceWorker' in navigator && 'PushManager' in window) {\r\n    var publicKey = 'BOEQSjdhorIf8M0XFNlwohK3sTzO9iJwvbYU-fuXRF0tvRpPPMGO6d_gJC_pUQwBT7wD8rKutpNTFHOHN3VqJ0A';\r\n    // 注册service worker\r\n    registerServiceWorker('./sw.js').then(function (registration) {\r\n        console.log('Service Worker 注册成功');\r\n        // 开启该客户端的消息推送订阅功能\r\n        return subscribeUserToPush(registration, publicKey);\r\n    }).then(function (subscription) {\r\n        var body = {subscription: subscription};\r\n        // 为了方便之后的推送，为每个客户端简单生成一个标识\r\n        body.uniqueid = new Date().getTime();\r\n        console.log('uniqueid', body.uniqueid);\r\n        // 将生成的客户端订阅信息存储在自己的服务器上\r\n        return sendSubscriptionToServer(JSON.stringify(body));\r\n    }).then(function (res) {\r\n        console.log(res);\r\n    }).catch(function (err) {\r\n        console.log(err);\r\n    });\r\n}\r\n```\r\n\r\n注意，这里为了方便我们后面的推送，为每个客户端生成了一个唯一ID`uniqueid`，这里使用了时间戳生成简单的`uniqueid`。\r\n\r\n此外，由于`userVisibleOnly`为`true`，所以需要用户授权开启通知权限，因此我们会看到下面的提示框，选择“允许”即可。你可以在设置中进行通知的管理。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/12/162ba85304cba1f5?w=724&h=340&f=png&s=39311)\r\n\r\n### 3.2. 服务端存储客户端subscription信息\r\n为了存储浏览器post来的订阅信息，服务端需要增加一个接口`/subscription`，同时添加中间件`koa-body`用于处理body\r\n\r\n```javascript\r\n// app.js\r\nconst koaBody = require('koa-body');\r\n/**\r\n * 提交subscription信息，并保存\r\n */\r\nrouter.post('/subscription', koaBody(), async ctx => {\r\n    let body = ctx.request.body;\r\n    await util.saveRecord(body);\r\n    ctx.response.body = {\r\n        status: 0\r\n    };\r\n});\r\n```\r\n\r\n接收到subscription信息后，需要在服务端进行保存，你可使用任何方式来保存它：mysql、redis、mongodb……这里为了方便，我使用了[nedb](https://github.com/louischatriot/nedb)来进行简单的存储。nedb不需要部署安装，可以将数据存储在内存中，也可以持久化，nedb的api和mongodb也比较类似。\r\n\r\n这里`util.saveRecord()`做了这些工作：首先，查询`subscription`信息是否存在，若已存在则只更新`uniqueid`；否则，直接进行存储。\r\n\r\n至此，我们就将客户端的订阅信息存储完毕了。现在，就可以等待今后推送时使用。\r\n\r\n### 3.3. 使用subscription信息推送信息\r\n在实际中，我们一般会给运营或产品同学提供一个推送配置后台。可以选择相应的客户端，填写推送信息，并发起推送。为了简单起见，我并没有写一个推送配置后台，而只提供了一个post接口`/push`来提交推送信息。后期我们完全可以开发相应的推送后台来调用该接口。\r\n\r\n```javascript\r\n// app.js\r\n/**\r\n * 消息推送API，可以在管理后台进行调用\r\n * 本例子中，可以直接post一个请求来查看效果\r\n */\r\nrouter.post('/push', koaBody(), async ctx => {\r\n    let {uniqueid, payload} = ctx.request.body;\r\n    let list = uniqueid ? await util.find({uniqueid}) : await util.findAll();\r\n    let status = list.length > 0 ? 0 : -1;\r\n\r\n    for (let i = 0; i < list.length; i++) {\r\n        let subscription = list[i].subscription;\r\n        pushMessage(subscription, JSON.stringify(payload));\r\n    }\r\n\r\n    ctx.response.body = {\r\n        status\r\n    };\r\n});\r\n```\r\n\r\n来看一下`/push`接口。\r\n\r\n1. 首先，根据post的参数不同，我们可以通过`uniqueid`来查询某条订阅信息：`util.find({uniqueid})`；也可以从数据库中查询出所有订阅信息：`util.findAll()`。\r\n2. 然后通过`pushMessage()`方法向Push Service发送请求。根据第二节的介绍，我们知道，该请求需要符合Web Push协议。然而，Web Push协议的请求封装、加密处理相关操作非常繁琐。因此，Web Push为各种语言的开发者提供了一系列对应的库：[Web Push Libaray](https://github.com/web-push-libs)，目前有NodeJS、PHP、Python、Java等。把这些复杂而繁琐的操作交给它们可以让我们事半功倍。\r\n3. 最后返回结果，这里只是简单的根据是否有订阅信息来进行返回。\r\n\r\n安装node版web-push\r\n\r\n```bash\r\nnpm install web-push --save\r\n```\r\n\r\n前面我们提到的公钥与私钥，也可以通过web-push来生成\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/13/162badb18824ff12?w=644&h=159&f=png&s=26820)\r\n\r\n使用web-push非常简单，首先设置VAPID keys：\r\n\r\n```javascript\r\n// app.js\r\nconst webpush = require('web-push');\r\n/**\r\n * VAPID值\r\n * 这里可以替换为你业务中实际的值\r\n */\r\nconst vapidKeys = {\r\n    publicKey: 'BOEQSjdhorIf8M0XFNlwohK3sTzO9iJwvbYU-fuXRF0tvRpPPMGO6d_gJC_pUQwBT7wD8rKutpNTFHOHN3VqJ0A',\r\n    privateKey: 'TVe_nJlciDOn130gFyFYP8UiGxxWd3QdH6C5axXpSgM'\r\n};\r\n\r\n// 设置web-push的VAPID值\r\nwebpush.setVapidDetails(\r\n    'mailto:alienzhou16@163.com',\r\n    vapidKeys.publicKey,\r\n    vapidKeys.privateKey\r\n);\r\n```\r\n设置完成后即可使用`webpush.sendNotification()`方法向Push Service发起请求。\r\n\r\n最后我们来看下`pushMessage()`方法的细节：\r\n\r\n```javascript\r\n// app.js\r\n/**\r\n * 向push service推送信息\r\n * @param {*} subscription \r\n * @param {*} data \r\n */\r\nfunction pushMessage(subscription, data = {}) {\r\n    webpush.sendNotification(subscription, data, options).then(data => {\r\n        console.log('push service的相应数据:', JSON.stringify(data));\r\n        return;\r\n    }).catch(err => {\r\n        // 判断状态码，440和410表示失效\r\n        if (err.statusCode === 410 || err.statusCode === 404) {\r\n            return util.remove(subscription);\r\n        }\r\n        else {\r\n            console.log(subscription);\r\n            console.log(err);\r\n        }\r\n    })\r\n}\r\n```\r\n`webpush.sendNotification`为我们封装了请求的处理细节。状态码401和404表示该subscription已经无效，可以从数据库中删除。\r\n\r\n### 3.4. Service Worker监听Push消息\r\n调用`webpush.sendNotification()`后，我们就已经把消息发送至Push Service了；而Push Service会将我们的消息推送至浏览器。\r\n\r\n要想在浏览器中获取推送信息，只需在Service Worker中监听`push`的事件即可：\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('push', function (e) {\r\n    var data = e.data;\r\n    if (e.data) {\r\n        data = data.json();\r\n        console.log('push的数据为：', data);\r\n        self.registration.showNotification(data.text);        \r\n    } \r\n    else {\r\n        console.log('push没有任何数据');\r\n    }\r\n});\r\n```\r\n\r\n## 4. 效果展示\r\n我们同时使用firefox与chrome来访问该WebApp，并分别向这两个客户端推送消息。我们可以使用console中打印出来的uniqueid，在postman中发起`/push`请求进行测试。\r\n\r\n![Web Push效果](https://user-gold-cdn.xitu.io/2018/4/13/162bc954b09d78cf?w=1277&h=774&f=gif&s=2877596)\r\n\r\n可以看到，我们分别向firefox与chrome中推送了“welcome to PWA”这条消息。console中的输出来自于Service Worker中对push事件的监听。而弹出的浏览器提醒则来自于之前提到的、订阅时配置的`userVisibleOnly: true`属性。在后续的文章里，我继续带大家了解Notification API（提醒）的使用。\r\n\r\n正如前文所述，Push Service可以在设备离线时，帮你维护推送消息。当浏览器设备重新联网时，就会收到该推送。下面展示了在设备恢复联网后，就会收到推送：\r\n\r\n![恢复网络则会收到推送消息](https://user-gold-cdn.xitu.io/2018/4/14/162bfe83b578881f?w=2560&h=1600&f=gif&s=2478281)\r\n\r\n## 5. 万恶的兼容性\r\n又到了查看[兼容性](https://caniuse.com/#search=push)的时间了。比较重要的是，对于Push API，目前Safari团队并没有明确表态计划支持。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/13/162bfa0147d2b40d?w=2346&h=918&f=png&s=192351)\r\n\r\n当然，其实比兼容性更大的一个问题是，Chrome所依赖的FCM服务在国内是无法访问的，而Firefox的服务在国内可以正常使用。这也是为什么在代码中会有这一项设置：\r\n\r\n```javascript\r\nconst options = {\r\n    // proxy: 'http://localhost:1087' // 使用FCM（Chrome）需要配置代理\r\n};\r\n```\r\n\r\n上面代码其实是用来配置web-push代理的。这里有一点需要注意，目前从npm上安装的web-push是不支持设置代理选项的。针对这点github上专门有[issue](https://github.com/web-push-libs/web-push/issues/280)进行了讨论，并在最近（两周前）合入了[相应的PR](https://github.com/web-push-libs/web-push/commit/f099ec8ff97e86fb6778ece04bd27a36ef93655e)。因此，如果需要web-push支持代理，简单的方式就是基于master进行web-push代码的相应调整。\r\n\r\n虽然由于google服务被屏蔽，导致国内Push功能无法在chrome上使用，但是作为一个重要的技术点，Web Push还是非常值得我们了解与学习的。\r\n\r\n## 6. 写在最后\r\n本文中所有的代码示例均可以在[learn-pwa/push](https://github.com/alienzhou/learning-pwa/tree/push)上找到。注意在git clone之后，切换到push分支。切换其他分支可以看到不同的版本：\r\n- basic分支：基础项目demo，一个普通的图书搜索应用（网站）；\r\n- manifest分支：基于basic分支，添加manifest等功能；\r\n- sw-cache分支：基于manifest分支，添加缓存与离线功能；\r\n- push分支：基于sw-cache分支，添加服务端消息推送功能；\r\n- master分支：应用的最新代码。\r\n\r\n如果你喜欢或想要了解更多的PWA相关知识，欢迎关注我，关注《PWA学习与实践》系列文章。我会总结整理自己学习PWA过程的遇到的疑问与技术点，并通过实际代码和大家一起实践。\r\n\r\n在下一篇文章里，我们先缓下脚步——工欲善其事，必先利其器。在继续了解更多PWA相关技术之前，先了解一些chrome上的PWA调试技巧。之后，我们会再回来继续了解另一个经常与Push API组合在一起的功能——消息提醒，Notification API。\r\n\r\n## 参考资料\r\n- [Generic Event Delivery Using HTTP Pus (draft-ietf-webpush-protocol-12)](https://tools.ietf.org/html/draft-ietf-webpush-protocol-12)\r\n- [FCM简单介绍](https://segmentfault.com/a/1190000010977980)\r\n- [How Push Works](https://developers.google.com/web/fundamentals/push-notifications/how-push-works)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/5","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/5/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/5/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/5/events","html_url":"https://github.com/alienzhou/blog/issues/5","id":390620176,"node_id":"MDU6SXNzdWUzOTA2MjAxNzY=","number":5,"title":"【PWA学习与实践】(4) 解决FireBase login验证失败问题","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2018-12-13T10:45:57Z","updated_at":"2020-04-25T03:57:56Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第四篇。是我在测试其他demo时遇到的一个问题，算是一篇TroubleShooting。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n\r\n## 引言\r\n在前一篇文章《让你的WebApp离线可用》中，我们使用Service Worker来做缓存与离线支持。是有一个重要的问题：**Service Worker必须要在HTTPS协议下才能运行（或者localhost）**。当然，对于一些只有前端资源（不涉及后端服务）的demo，我们完全可以将这些前端（静态资源）托管在一个HTTPS服务下，使得Service Worker可以使用。我选择了google的[FireBase](https://firebase.google.com/)来托管demo（其实github page也是个不错的选择）。\r\n\r\n\r\n使用FireBase非常简单，只需要`firebase login` -->`firebase init`-->`firebase deploy`即可。但是在`firebase login`的过程中，遇到了一些问题。这篇文章主要总结了我在`firebase login`遇到的问题及解决方式：\r\n1. 无法获取authorization code\r\n2. ` Authentication Error: Your credentials are no longer valid.`\r\n\r\n有需要的朋友可以继续看。\r\n\r\n首先，如果你对firebase完全不了解，下面会有一段非常简短的介绍。\r\n\r\n## 什么是FireBase\r\n前段时间学习PWA，在跟着官方教程完成demo后，想要在手机上测试一下效果。然而，遇到的一个问题就是：PWA需要HTTPS协议（或者使用localhost）。\r\n\r\n这就需要我们有一个HTTPS的服务，并在其上面部署我们本地写好的demo。而官方demo的最后，推荐使用firebase来托管你的代码。\r\n\r\n![FireBase的各种功能与服务](https://user-gold-cdn.xitu.io/2018/4/10/162afdd08f75977a?w=700&h=394&f=png&s=66460)\r\n\r\n在FireBase的众多使用场景中，Develop -> Hosting（托管）就是我需要用到的了。然而，在执行`firebase login`（账号登录）过程中，却遇到了一些问题。\r\n\r\n## 问题一：在浏览器登录账号后，无反应（无法获取authorization code）\r\n最开始，我在CLI中输入`firebase login`，选择`y`后，CLI会需要一个authorization code；而浏览器会打开并提示你进行登录。\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/10/162afdd08f8a3d0a?w=1171&h=158&f=png&s=26957)\r\n\r\n这里我用google账户进行授权登录。然而，在授权之后，却迟迟没有响应（无法得到authorization code）。这时候，我发现浏览器显示，似乎是在等待`localhost`进行响应。\r\n\r\n解决这个问题的方法就是：在登录时，使用`firebase login --no-localhost`进行登录。\r\n\r\n重新使用`firebase login --no-localhost`登录。这里我选择了google账号进行登录，重复上面的过程：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/10/162afdd08f8a3d0a?w=1171&h=158&f=png&s=26957)\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/10/162afdd08f994938?w=508&h=563&f=png&s=28870)\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/10/162afdd08f6cd205?w=484&h=685&f=png&s=83614)\r\n\r\n这次，你就会在浏览器中获得一串authorization code值：\r\n\r\n![authorization code](https://user-gold-cdn.xitu.io/2018/4/10/162afdd08f8759e8?w=1240&h=178&f=png&s=16044)\r\n\r\n将它粘贴到CLI中即可。【问题一】解决！\r\n\r\n## 问题二：Error: Authentication Error: Your credentials are no longer valid.\r\n然而，在CLI中输入authorization code之后，在等待了较长时间的验证后，CLI中报出了如下错误：\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/4/10/162afdd08f96d4ed?w=1240&h=165&f=png&s=76650)\r\n\r\n这是怎么回事呢？通过查阅一些资料发现，这很可能是你在电脑上使用“翻墙”工具所导致的。firebase-tool依赖的npm包（faye-websocket）中，未开启代理的相关设置，因此无法进行验证。\r\n\r\n解决这个问题的方法有两种：\r\n### 方法一：在路由器上设置代理，而非本机\r\n有些文章指出，通过在路由器上设置代理，而非在本机开启代理，可以避免这个问题。不过由于一些原因，暂时还没有尝试这种方式，不过通过一些反馈来看，应该是一个有效的方法。\r\n\r\n### 方法二：(hack) 修改代码与相关环境变量\r\n该方法较第一种方法来看，会稍微“硬”那么一些。具体的操作方式如下：\r\n\r\n1. 设置环境变量`http_proxy`，我本机的代理使用的是1087端口。`export http_proxy=http://localhost:1087` \r\n1. 修改faye-websocket，开启代理配置。faye-websocket是firebase依赖的一个WebSocket库，需要为其client.js添加如下配置：\r\n```javascript\r\nvar Client = function(_url, protocols, options) {\r\n    options = options || {};\r\n    // 添加proxy配置\r\n    options.proxy = {\r\n        origin:  'http://localhost:1087',\r\n    };\r\n    …\r\n}\r\n```\r\n如果你是全局安装的firebase-tools，你可以通过如下方法找到client.js\r\n```\r\nNODE_PATH=`npm prefix -g`\r\n// client.js的位置\r\n$NODE_PATH/lib/node_modules/firebase-tools/node_modules/firebase/node_modules/faye-websocket/lib/faye/websocket/client.js\r\n```\r\n3. 设置环境变量NODE_TLS_REJECT_UNAUTHORIZED。`export NODE_TLS_REJECT_UNAUTHORIZED=0`\r\n\r\n4. 重新登录，`firebase login --no-localhost`，重复之前的操作。你会发现，登录成功！\r\n\r\n![image.png](https://user-gold-cdn.xitu.io/2018/4/10/162afdd0b8f77b15?w=1177&h=219&f=png&s=44679)\r\n\r\n【问题二】解决！\r\n\r\np.s. 针对这个问题，github上也有一个issue：[Unable to deploy behind a proxy](https://github.com/firebase/firebase-tools/issues/155)。\r\n\r\n此外，如果你使用了代理，推荐使用全局代理的方式，使你的CLI也使用代理。\r\n\r\n## 写在最后\r\n最后，还是回到我开发PWA时的需求。文章最开始提到了，我是为了在移动端测试PWA demo的效果，所以使用FireBase来托管资源。当然，除了FireBase，还有下面两个办法：\r\n\r\n1. 使用github page。由于github全站都是运行在HTTPS下，因此在github page上托管的静态站点可以使用Service Worker；\r\n\r\n2. 使用localhost/127.0.0.1。了解PWA的话，你会知道除了HTTPS之外，也可以使用localhost（这一设计是为了方便本机调试）。\r\n\r\n本文是[《PWA学习与实践》](https://juejin.im/user/59ad5377518825244d206d2d/posts)系列中的第四篇。这篇文章并没有探讨PWA中实际的技术，而是记录了我在开发、调试P过程与遇到的问题。可能有朋友也会遇到类似问题，因此记录下来和大家分享。\r\n\r\n在下一篇文章中，我们还是会回到PWA背后的技术，来了解一下，**如何使用Push API来实现后端服务向客户端进行消息推送**。\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/4","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/4/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/4/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/4/events","html_url":"https://github.com/alienzhou/blog/issues/4","id":390619644,"node_id":"MDU6SXNzdWUzOTA2MTk2NDQ=","number":4,"title":"【PWA学习与实践】(3) 让你的WebApp离线可用","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T10:44:36Z","updated_at":"2018-12-13T10:44:36Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第三篇文章。文中的代码都可以在[learning-pwa的sw-cache分支](https://github.com/alienzhou/learning-pwa/tree/sw-cache)上找到（`git clone`后注意切换到sw-cache分支）。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n## 1. 引言\r\nPWA其中一个令人着迷的能力就是离线（offline）可用。\r\n\r\n![即使在离线状态下，依然可以访问的PWA](https://user-gold-cdn.xitu.io/2018/4/8/162a560d0b7dfb84?w=1161&h=728&f=gif&s=1190874)\r\n\r\n离线只是它的一种功能表现而已，具体说来，它可以：\r\n- 让我们的Web App在无网（offline）情况下可以访问，甚至使用部分功能，而不是展示“无网络连接”的错误页；\r\n- 让我们在弱网的情况下，能使用缓存快速访问我们的应用，提升体验；\r\n- 在正常的网络情况下，也可以通过各种自发控制的缓存方式来节省部分请求带宽；\r\n- ……\r\n\r\n而这一切，其实都要归功于PWA背后的英雄 —— **Service Worker**。\r\n\r\n那么，Service Worker是什么呢？你可以把Service Worker简单理解为一个独立于前端页面，在后台运行的进程。因此，它不会阻塞浏览器脚本的运行，同时也无法直接访问浏览器相关的API（例如：DOM、localStorage等）。此外，即使在离开你的Web App，甚至是关闭浏览器后，它仍然可以运行。它就像是一个在Web应用背后默默工作的勤劳小蜜蜂，处理着缓存、推送、通知与同步等工作。所以，要学习PWA，绕不开的就是Service Worker。\r\n\r\n![PWA背后的英雄 —— Service Worker](https://user-gold-cdn.xitu.io/2018/4/8/162a560d0b6f194f?w=670&h=447&f=png&s=631884)\r\n\r\n在接下来的几篇文章里，我会从如何使用Service Worker来实现资源的缓存、消息的推送、消息的通知以及后台同步这几个角度，来介绍相关原理与技术实现。这些部分会是PWA技术的重点。需要特别注意的是，由于Service Worker所具有的强大能力，因此规范规定，**Service Worker只能运行在HTTPS域下**。然而我们开发时候没有HTTPS怎么办？别着急，还有一个贴心的地方——为方便本地开发，**Service Worker也可以运行在localhost（127.0.0.1）域下**。\r\n\r\n好了，简单了解了Service Worker与它能实现的功能后，我们还是要回到这一篇的主题，也就是Service Worker的第一部分——如何利用Service Worker来实现前端资源的缓存，从而提升产品的访问速度，做到离线可用。\r\n\r\n## 2. Service Worker是如何实现离线可用的？\r\n这一小节会告诉大家，Service Worker是如何让我们在离线的情况下也能访问Web App的。当然，离线访问只是其中一种表现。\r\n\r\n首先，我们想一下，当访问一个web网站时，我们实际上做了什么呢？总体上来说，我们通过与与服务器建立连接，获取资源，然后获取到的部分资源还会去请求新的资源（例如html中使用的css、js等）。所以，粗粒度来说，我们访问一个网站，就是在获取/访问这些资源。\r\n\r\n可想而知，当处于离线或弱网环境时，我们无法有效访问这些资源，这就是制约我们的关键因素。因此，一个最直观的思路就是：如果我们把这些资源缓存起来，在某些情况下，将网络请求变为本地访问，这样是否能解决这一问题？是的。但这就需要我们有一个本地的cache，可以灵活地将各类资源进行本地存取。\r\n\r\n![如何获取所需的资源？](https://user-gold-cdn.xitu.io/2018/4/8/162a560d0ba6b18b?w=567&h=219&f=png&s=7993)\r\n\r\n有了本地的cache还不够，我们还需要能够有效地使用缓存、更新缓存与清除缓存，进一步应用各种个性化的缓存策略。而这就需要我们有个能够控制缓存的“worker”——这也就是Service Worker的部分工作之一。顺便多说一句，可能有人还记得 [ApplicationCache](https://developer.mozilla.org/en-US/docs/Web/API/Window/applicationCache) 这个API。当初它的设计同样也是为了实现Web资源的缓存，然而就是因为不够灵活等各种缺陷，如今已被Service Worker与cache API所取代了。\r\n\r\nService Worker有一个非常重要的特性：你可以在Service Worker中监听所有客户端（Web）发出的请求，然后通过Service Worker来代理，向后端服务发起请求。通过监听用户请求信息，Service Worker可以决定是否使用缓存来作为Web请求的返回。\r\n\r\n下图展示普通Web App与添加了Service Worker的Web App在网络请求上的差异：\r\n\r\n![普通Web请求(上)与使用Service Worker代理(下)的区别](https://user-gold-cdn.xitu.io/2018/4/8/162a560d0bdb6ed1?w=567&h=271&f=png&s=14952)\r\n\r\n这里需要强调一下，虽然图中好像将浏览器、SW(Service Worker)与后端服务三者并列放置了，但实际上浏览器（你的Web应用）和SW都是运行在你的本机上的，所以这个场景下的SW类似一个“客户端代理”。\r\n\r\n了解了基本概念之后，就可以具体来看下，我们如何应用这个技术来实现一个离线可用的Web应用。\r\n\r\n## 3. 如何使用Service Worker实现离线可用的“秒开”应用\r\n还记得我们之前的那个图书搜索的demo Web App么？不了解的朋友可以看下本系列的[第一篇文章](https://juejin.im/post/5ac8a67c5188255c5668b0b8)，当然你可以忽略细节，继续往下了解技术原理。\r\n\r\n没错，这次我仍然会基于它进行改造。在[上一篇添加了manifest](https://juejin.im/post/5ac8a89ef265da238440d60a)后，它已经拥有了自己的桌面图标，并有一个很像Native App的外壳；而今天，我会让它变得更酷。\r\n\r\n> 如果想要跟着文章内容一起实践，可以在[这里下载到所需的全部代码](https://github.com/alienzhou/learning-pwa/tree/master)。\r\n记得切换到`manifest`分支，因为本篇内容，是基于上一篇的最终代码进行相应的开发与升级。毕竟我们的最终目标是将这个普通的“图书搜索”demo升级为PWA。\r\n\r\n### 3.1. 注册Service Worker\r\n注意，我们的应用始终应该是渐进可用的，在不支持Service Worker的环境下，也需要保证其可用性。要实现这点，可以通过特性检测，在index.js中来注册我们的Service Worker（sw.js）：\r\n\r\n```javascript\r\n// index.js\r\n// 注册service worker，service worker脚本文件为sw.js\r\nif ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.register('./sw.js').then(function () {\r\n        console.log('Service Worker 注册成功');\r\n    });\r\n}\r\n```\r\n这里我们将sw.js文件注册为一个Service Worker，注意文件的路径不要写错了。\r\n\r\n值得一提的是，Service Worker的各类操作都被设计为异步，用以避免一些长时间的阻塞操作。这些API都是以Promise的形式来调用的。所以你会在接下来的各段代码中不断看到Promise的使用。如果你完全不了解Promise，可以先在这里了解基本的Promise概念：[Promise（MDN）](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)和[JavaScript Promise：简介](https://developers.google.com/web/fundamentals/primers/promises)。\r\n\r\n### 3.2. Service Worker的生命周期\r\n当我们注册了Service Worker后，它会经历生命周期的各个阶段，同时会触发相应的事件。整个生命周期包括了：installing --> installed --> activating --> activated --> redundant。当Service Worker安装（installed）完毕后，会触发install事件；而激活（activated）后，则会触发activate事件。\r\n\r\n![Service Worker生命周期](https://user-gold-cdn.xitu.io/2018/4/8/162a560d0bdaf33b?w=579&h=867&f=png&s=39680)\r\n\r\n下面的例子监听了install事件：\r\n```javascript\r\n// 监听install事件\r\nself.addEventListener('install', function (e) {\r\n    console.log('Service Worker 状态： install');\r\n});\r\n```\r\n`self`是Service Worker中一个特殊的全局变量，类似于我们最常见的`window`对象。`self`引用了当前这个Service Worker。\r\n\r\n### 3.3. 缓存静态资源\r\n通过上一节，我们已经学会了如何添加事件监听，来在合适的时机触发Service Worker的相应操作。现在，要使我们的Web App离线可用，就需要将所需资源缓存下来。我们需要一个资源列表，当Service Worker被激活时，会将该列表内的资源缓存进cache。\r\n\r\n```javascript\r\n// sw.js\r\nvar cacheName = 'bs-0-2-0';\r\nvar cacheFiles = [\r\n    '/',\r\n    './index.html',\r\n    './index.js',\r\n    './style.css',\r\n    './img/book.png',\r\n    './img/loading.svg'\r\n];\r\n\r\n// 监听install事件，安装完成后，进行文件缓存\r\nself.addEventListener('install', function (e) {\r\n    console.log('Service Worker 状态： install');\r\n    var cacheOpenPromise = caches.open(cacheName).then(function (cache) {\r\n        return cache.addAll(cacheFiles);\r\n    });\r\n    e.waitUntil(cacheOpenPromise);\r\n});\r\n```\r\n\r\n可以看到，首先在`cacheFiles`中我们列出了所有的静态资源依赖。注意其中的`'/'`，由于根路径也可以访问我们的应用，因此不要忘了将其也缓存下来。当Service Worker install时，我们就会通过`caches.open()`与`cache.addAll()`方法将资源缓存起来。这里我们给缓存起了一个`cacheName`，这个值会成为这些缓存的key。\r\n\r\n上面这段代码中，`caches`是一个全局变量，通过它我们可以操作Cache相关接口。\r\n\r\n> Cache 接口提供缓存的 Request / Response 对象对的存储机制。Cache 接口像 workers 一样, 是暴露在 window 作用域下的。尽管它被定义在 service worker 的标准中,  但是它不必一定要配合 service worker 使用。——MDN\r\n\r\n### 3.4 使用缓存的静态资源\r\n到目前为止，我们仅仅是注册了一个Service Worker，并在其install时缓存了一些静态资源。然而，如果这时运行这个demo你会发现——“图书搜索”这个Web App依然无法离线使用。\r\n\r\n为什么呢？因为我们仅仅缓存了这些资源，然而浏览器并不知道需要如何使用它们；换言之，浏览器仍然会通过向服务器发送请求来等待并使用这些资源。那怎么办？\r\n\r\n聪明的你应该想起来了，我们在文章前半部分介绍Service Worker时提到了“客户端代理”——用Service Worker来帮我们决定如何使用缓存。\r\n\r\n下图是一个简单的策略：\r\n\r\n![有cache时的静态资源请求流程](https://user-gold-cdn.xitu.io/2018/4/8/162a560d2d6b1798?w=567&h=284&f=png&s=19408)\r\n\r\n![无cache时的静态资源请求流程](https://user-gold-cdn.xitu.io/2018/4/8/162a560d30b47136?w=567&h=284&f=png&s=13705)\r\n\r\n1. 浏览器发起请求，请求各类静态资源（html/js/css/img）；\r\n1. Service Worker拦截浏览器请求，并查询当前cache；\r\n1. 若存在cache则直接返回，结束；\r\n1. 若不存在cache，则通过`fetch`方法向服务端发起请求，并返回请求结果给浏览器\r\n\r\n```javascript\r\n// sw.js\r\nself.addEventListener('fetch', function (e) {\r\n    // 如果有cache则直接返回，否则通过fetch请求\r\n    e.respondWith(\r\n        caches.match(e.request).then(function (cache) {\r\n            return cache || fetch(e.request);\r\n        }).catch(function (err) {\r\n            console.log(err);\r\n            return fetch(e.request);\r\n        })\r\n    );\r\n});\r\n```\r\n`fetch`事件会监听所有浏览器的请求。`e.respondWith()`方法接受Promise作为参数，通过它让Service Worker向浏览器返回数据。`caches.match(e.request)`则可以查看当前的请求是否有一份本地缓存：如果有缓存，则直接向浏览器返回`cache`；否则Service Worker会向后端服务发起一个`fetch(e.request)`的请求，并将请求结果返回给浏览器。\r\n\r\n到目前为止，运行我们的demo：当第一联网打开“图书搜索”Web App后，所依赖的静态资源就会被缓存在本地；以后再访问时，就会使用这些缓存而不发起网络请求。因此，即使在无网情况下，我们似乎依旧能“访问”该应用。\r\n\r\n### 3.5. 更新静态缓存资源\r\n然而，如果你细心的话，会发现一个小问题：当我们将资源缓存后，除非注销（unregister）sw.js、手动清除缓存，否则新的静态资源将无法缓存。\r\n\r\n解决这个问题的一个简单方法就是修改`cacheName`。由于浏览器判断sw.js是否更新是通过字节方式，因此修改`cacheName`会重新触发install并缓存资源。此外，在activate事件中，我们需要检查`cacheName`是否变化，如果变化则表示有了新的缓存资源，原有缓存需要删除。\r\n\r\n```javascript\r\n// sw.js\r\n// 监听activate事件，激活后通过cache的key来判断是否更新cache中的静态资源\r\nself.addEventListener('activate', function (e) {\r\n    console.log('Service Worker 状态： activate');\r\n    var cachePromise = caches.keys().then(function (keys) {\r\n        return Promise.all(keys.map(function (key) {\r\n            if (key !== cacheName) {\r\n                return caches.delete(key);\r\n            }\r\n        }));\r\n    })\r\n    e.waitUntil(cachePromise);\r\n    return self.clients.claim();\r\n});\r\n```\r\n\r\n### 3.6.  缓存API数据的“离线搜索”\r\n到这里，我们的应用基本已经完成了离线访问的改造。但是，如果你注意到文章开头的图片就会发现，离线时我们不仅可以访问，还可以使用搜索功能。\r\n\r\n![离线/无网环境下普通Web App(左)与PWA(右)的差异](https://user-gold-cdn.xitu.io/2018/4/8/162a560d5f79572c?w=1238&h=698&f=png&s=130127)\r\n\r\n这是怎么回事呢？其实这背后的秘密就在于，这个Web App也会把XHR请求的数据缓存一份。而再次请求时，我们会优先使用本地缓存（如果有缓存的话）；然后向服务端请求数据，服务端返回数据后，基于该数据替换展示。大致过程如下：\r\n\r\n![图书查询接口的缓存与使用策略](https://user-gold-cdn.xitu.io/2018/4/8/162a560d35c15a67?w=567&h=266&f=png&s=16946)\r\n\r\n首先我们改造一下前一节的代码在sw.js的`fetch`事件里进行API数据的缓存\r\n```javascript\r\n// sw.js\r\nvar apiCacheName = 'api-0-1-1';\r\nself.addEventListener('fetch', function (e) {\r\n    // 需要缓存的xhr请求\r\n    var cacheRequestUrls = [\r\n        '/book?'\r\n    ];\r\n    console.log('现在正在请求：' + e.request.url);\r\n\r\n    // 判断当前请求是否需要缓存\r\n    var needCache = cacheRequestUrls.some(function (url) {\r\n        return e.request.url.indexOf(url) > -1;\r\n    });\r\n\r\n    /**** 这里是对XHR数据缓存的相关操作 ****/\r\n    if (needCache) {\r\n        // 需要缓存\r\n        // 使用fetch请求数据，并将请求结果clone一份缓存到cache\r\n        // 此部分缓存后在browser中使用全局变量caches获取\r\n        caches.open(apiCacheName).then(function (cache) {\r\n            return fetch(e.request).then(function (response) {\r\n                cache.put(e.request.url, response.clone());\r\n                return response;\r\n            });\r\n        });\r\n    }\r\n    /* ******************************* */\r\n\r\n    else {\r\n        // 非api请求，直接查询cache\r\n        // 如果有cache则直接返回，否则通过fetch请求\r\n        e.respondWith(\r\n            caches.match(e.request).then(function (cache) {\r\n                return cache || fetch(e.request);\r\n            }).catch(function (err) {\r\n                console.log(err);\r\n                return fetch(e.request);\r\n            })\r\n        );\r\n    }\r\n});\r\n```\r\n这里，我们也为API缓存的数据创建一个专门的缓存位置，key值为变量`apiCacheName`。在`fetch`事件中，我们首先通过对比当前请求与`cacheRequestUrls`来判断是否是需要缓存的XHR请求数据，如果是的话，就会使用`fetch`方法向后端发起请求。\r\n\r\n在`fetch.then`中我们以请求的URL为key，向cache中更新了一份当前请求所返回数据的缓存：`cache.put(e.request.url, response.clone())`。这里使用`.clone()`方法拷贝一份响应数据，这样我们就可以对响应缓存进行各类操作而不用担心原响应信息被修改了。\r\n\r\n### 3.7. 应用离线XHR数据，完成“离线搜索”，提升响应速度\r\n如果你跟着做到了这一步，那么恭喜你，距离我们酷酷的离线应用还差最后一步了！\r\n\r\n目前为止，我们对Service Worker（sw.js）的改造已经完毕了。最后只剩下如何在XHR请求时有策略的使用缓存了，这一部分的改造全部集中于index.js，也就是我们的前端脚本。\r\n\r\n还是回到上一节的这张图：\r\n\r\n![图书查询接口的缓存与使用策略](https://user-gold-cdn.xitu.io/2018/4/8/162a560d35c15a67?w=567&h=266&f=png&s=16946)\r\n\r\n和普通情况不同，这里我们的前端浏览器会首先去尝试获取缓存数据并使用其来渲染界面；同时，浏览器也会发起一个XHR请求，Service Worker通过将请求返回的数据更新到存储中的同时向前端Web应用返回数据（这一步分就是上一节提到的缓存策略）；最终，如果判断返回的数据与最开始取到的cache不一致，则重新渲染界面，否则忽略。\r\n\r\n为了是代码更清晰，我们将原本的XHR请求部分单独剥离出来，作为一个方法`getApiDataRemote()`以供调用，同时将其改造为了Promise。为了节省篇幅，我部分的代码比较简单，就不单独贴出了。\r\n\r\n这一节最重要的部分其实是读取缓存。我们知道，在Service Worker中是可以通过`caches`变量来访问到缓存对象的。令人高兴的是，在我们的前端应用中，也仍然可以通过`caches`来访问缓存。当然，为了保证渐进可用，我们需要先进行判断`'caches' in window`。为了代码的统一，我将获取该请求的缓存数据也封装成了一个Promise方法：\r\n\r\n```javascript\r\nfunction getApiDataFromCache(url) {\r\n    if ('caches' in window) {\r\n        return caches.match(url).then(function (cache) {\r\n            if (!cache) {\r\n                return;\r\n            }\r\n            return cache.json();\r\n        });\r\n    }\r\n    else {\r\n        return Promise.resolve();\r\n    }\r\n}\r\n```\r\n而原本我们在`queryBook()`方法中，我们会请求后端数据，然后渲染页面；而现在，我们加上基于缓存的渲染：\r\n```javascript\r\nfunction queryBook() {\r\n    // ……\r\n    // 远程请求\r\n    var remotePromise = getApiDataRemote(url);\r\n    var cacheData;\r\n    // 首先使用缓存数据渲染\r\n    getApiDataFromCache(url).then(function (data) {\r\n        if (data) {\r\n            loading(false);\r\n            input.blur();            \r\n            fillList(data.books);\r\n            document.querySelector('#js-thanks').style = 'display: block';\r\n        }\r\n        cacheData = data || {};\r\n        return remotePromise;\r\n    }).then(function (data) {\r\n        if (JSON.stringify(data) !== JSON.stringify(cacheData)) {\r\n            loading(false);                \r\n            input.blur();\r\n            fillList(data.books);\r\n            document.querySelector('#js-thanks').style = 'display: block';\r\n        }\r\n    });\r\n    // ……\r\n}\r\n```\r\n如果`getApiDataFromCache(url).then`返回缓存数据，则使用它先进行渲染。而当`remotePromise`的数据返回时，与`cacheData`进行比对，只有在数据不一致时需要重新渲染页面（注意这里为了简便，粗略地使用了`JSON.stringify()`方法进行对象间的比较）。这么做有两个优势：\r\n\r\n1. 离线可用。如果我们之前访问过某些URL，那么即使在离线的情况下，重复相应的操作依然可以正常展示页面；\r\n2. 优化体验，提高访问速度。读取本地cache耗时相比于网络请求是非常低的，因此就会给我们的用户一种“秒开”、“秒响应”的感觉。\r\n\r\n## 4. 使用Lighthouse测试我们的应用\r\n至此，我们完成了PWA的两大基本功能：Web App Manifest和Service Worker的离线缓存。这两大功能可以很好地提升用户体验与应用性能。我们用Chrome中的Lighthouse来检测一下目前的应用：\r\n\r\n![Lighthouse检测结果](https://user-gold-cdn.xitu.io/2018/4/8/162a560d5f48ee00?w=724&h=130&f=png&s=22130)\r\n\r\n![Lighthouse检测结果 - PWA](https://user-gold-cdn.xitu.io/2018/4/8/162a560d65ba5c20?w=723&h=224&f=png&s=27543)\r\n\r\n可以看到，在PWA评分上，我们的这个Web App已经非常不错了。其中唯一个扣分项是在HTTPS协议上：由于是本地调试，所以使用了http://127.0.0.1:8085，在生产肯定会替换为HTTPS。\r\n\r\n## 5. 这太酷了，但是兼容性呢？\r\n随着今年（2018年）年初，Apple在iOS 11.3中开始支持Service Worker，加上Apple一直以来较为良好的系统升级率，整个PWA在兼容性问题上有了重大的突破。\r\n\r\n虽然Service Worker中的一些其他功能（例如推送、后台同步）Apple并未表态，但是Web App Manifest和Service Worker的离线缓存是iOS 11.3所支持的。这两大核心功能不仅效果拔群，而且目前看来具有还不错的兼容性，非常适合投入生产。\r\n\r\n更何况，作为渐进式网页应用，其最重要的一个特点就是在兼容性支持时自动升级功能与体验；而在不支持时，会静默回退部分新功能。在保证我们的正常服务情况下，尽可能利用浏览器特性，提供更优质的服务。\r\n\r\n![Service Worker兼容性](https://user-gold-cdn.xitu.io/2018/4/8/162a560d66590ff7?w=1240&h=473&f=png&s=133285)\r\n\r\n## 6. 写在最后\r\n本文中所有的代码示例均可以在[learn-pwa/sw-cache](https://github.com/alienzhou/learning-pwa/tree/sw-cache)上找到。注意在git clone之后，切换到sw-cache分支，本文所有的代码均存在于该分支上。切换其他分值可以看到不同的版本：\r\n- basic分支：基础项目demo，一个普通的图书搜索应用（网站）；\r\n- manifest分支：基于basic分支，添加manifest等功能，具体可以看上一篇文章了解；\r\n- sw-cache分支：基于manifest分支，添加缓存与离线功能；\r\n- master分支：应用的最新代码。\r\n\r\n> 最后声明一下，文中的代码作为demo，主要是用于了解与学习PWA技术原理，可能会存在一些不完善的地方，因此，不建议直接使用到生产环境。\r\n\r\n## 参考资料\r\n- [Using Service Workers（MDN）](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)\r\n- [Cache（MDN）](https://developer.mozilla.org/zh-CN/docs/Web/API/Cache)\r\n- [Service Worker使用方式](https://developers.google.com/web/fundamentals/primers/service-workers/)\r\n- [JavaScript Promise：简介](https://developers.google.com/web/fundamentals/primers/promises)\r\n- [Promise（MDN）](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/3","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/3/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/3/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/3/events","html_url":"https://github.com/alienzhou/blog/issues/3","id":390507083,"node_id":"MDU6SXNzdWUzOTA1MDcwODM=","number":3,"title":"【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T03:51:54Z","updated_at":"2018-12-13T03:51:54Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\n本文是《PWA学习与实践》系列的第二篇文章。文中的代码都可以在[learning-pwa的manifest分支](https://github.com/alienzhou/learning-pwa/tree/manifest)上找到（`git clone`后注意切换到manifest分支）。\r\n\r\nPWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。对PWA感兴趣的朋友欢迎关注《PWA学习与实践》系列文章。\r\n\r\n## 1. 引言\r\n\r\n我们知道，在chrome（等一些现代浏览器）中，你可以将访问的网站添加到桌面，这样就会在桌面生成一个类似“快捷方式”的图标，当你点击该图标时，便可以快速访问该网站（Web App）。我们以[第一篇文章](https://juejin.im/post/5ac8a67c5188255c5668b0b8)中的demo为例，其添加到桌面后以及重新打开时的状态如下：\r\n\r\n![普通Web App被添加到桌面后的展示形式](https://user-gold-cdn.xitu.io/2018/4/7/1629fd2a527121d2?w=750&h=482&f=png&s=185553)\r\n\r\n然而，对于PWA来说，有一些重要的特性：\r\n\r\n- Web App可以被添加到桌面并有它自己的应用图标；\r\n- 同时，从桌面开启时，会和原生app一样有它自己的“开屏图”；\r\n- 更进一步的，这个Web App在的样子几乎和原生应用一样——没有浏览器的地址栏、工具条，似乎和Native App一样运行在一个独立的容器中。\r\n\r\n就像下面这样：\r\n\r\n![PWA被添加到桌面后的展示形式](https://user-gold-cdn.xitu.io/2018/4/7/1629fd2a529adc58?w=750&h=482&f=png&s=187366)\r\n\r\n接下来，我们会基于该系列——《PWA技术学习与实践》的前一篇《2018，开始你的PWA学习之旅》中所提及的一个普通Web App的demo来进行改造，来实现PWA的这一效果。或者直接从github clone learning-pwa（https://github.com/alienzhou/learning-pwa/tree/master）这个仓库也可以。切换到manifest分支，即可看到本文的最后成果。\r\n\r\n## 2. Web App Manifest\r\nManifest是一个JSON格式的文件，你可以把它理解为一个指定了Web App桌面图标、名称、开屏图标、运行模式等一系列资源的一个清单。\r\n\r\n> manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。 —— MDN\r\n\r\n我们来看一下，learning-pwa中的[manifest.json](https://github.com/alienzhou/learning-pwa/blob/manifest/public/manifest.json)文件内容\r\n\r\n```\r\n{\r\n    \"name\": \"图书搜索\",\r\n    \"short_name\": \"书查\",\r\n    \"start_url\": \"/\",\r\n    \"display\": \"standalone\",\r\n    \"background_color\": \"#333\",\r\n    \"description\": \"一个搜索图书的小WebAPP（基于豆瓣开放接口）\",\r\n    \"orientation\": \"portrait-primary\",\r\n    \"theme_color\": \"#5eace0\",\r\n    \"icons\": [{\r\n        \"src\": \"img/icons/book-32.png\",\r\n        \"sizes\": \"32x32\",\r\n        \"type\": \"image/png\"\r\n    }, {\r\n        \"src\": \"img/icons/book-72.png\",\r\n        \"sizes\": \"72x72\",\r\n        \"type\": \"image/png\"\r\n    }, {\r\n        \"src\": \"img/icons/book-128.png\",\r\n        \"sizes\": \"128x128\",\r\n        \"type\": \"image/png\"\r\n    }, {\r\n        \"src\": \"img/icons/book-144.png\",\r\n        \"sizes\": \"144x144\",\r\n        \"type\": \"image/png\"\r\n    }, {\r\n        \"src\": \"img/icons/book-192.png\",\r\n        \"sizes\": \"192x192\",\r\n        \"type\": \"image/png\"\r\n    }, {\r\n        \"src\": \"img/icons/book-256.png\",\r\n        \"sizes\": \"256x256\",\r\n        \"type\": \"image/png\"\r\n    }, {\r\n        \"src\": \"img/icons/book-512.png\",\r\n        \"sizes\": \"512x512\",\r\n        \"type\": \"image/png\"\r\n    }]\r\n}\r\n```\r\n可以看出，上面的JSON配置文件非常直观，通过声明各个属性的值，即可改造我们的Web App。那么下面就针对每个具体值进行简单的介绍。\r\n### 2.1. name, short_name\r\n指定了Web App的名称。`short_name`其实是该应用的一个简称。一般来说，当没有足够空间展示应用的`name`时，系统就会使用`short_name`。可以看到本文的例子中，图书搜索这个应用在桌面上展示的名称就是`short_name`书查。\r\n\r\n### 2.2. start_url\r\n这个属性指定了用户打开该Web App时加载的URL。相对URL会相对于manifest。这里我们指定了`start_url`为`/`，访问根目录。\r\n\r\n### 2.3. display\r\n`display`控制了应用的显示模式，它有四个值可以选择：`fullscreen `、`standalone `、`minimal-ui`和`browser `。\r\n\r\n- `fullscreen `：全屏显示，会尽可能将所有的显示区域都占满；\r\n- `standalone `：独立应用模式，这种模式下打开的应用有自己的启动图标，并且不会有浏览器的地址栏。因此看起来更像一个Native App；\r\n- `minimal-ui`：与`standalone `相比，该模式会多出地址栏；\r\n- `browser `：一般来说，会和正常使用浏览器打开样式一致。\r\n\r\n让我们来看下这四种模式的差异：\r\n\r\n![display四种模式的差异](https://user-gold-cdn.xitu.io/2018/4/7/1629fd2a529dbe50?w=750&h=400&f=png&s=20062)\r\n\r\n当然，不同的系统所表现出的具体样式也不完全一样。就像示例中的虚拟按键在`fullscreen `模式下会默认隐藏。\r\n\r\n### 2.4. orientation\r\n控制Web App的方向。设置某些值会具有类似锁屏的效果（禁止旋转），例如例子中的`portrait-primary`。具体的值包括：`any, natural, landscape, landscape-primary, landscape-secondary, portrait, portrait-primary, portrait-secondary`。\r\n\r\n### 2.5. icons， background_color\r\n`icons`用来指定应用的桌面图标。icons本身是一个数组，每个元素包含三个属性：\r\n- sizes：图标的大小。通过指定大小，系统会选取最合适的图标展示在相应位置上。\r\n- src：图标的文件路径。注意相对路径是相对于manifest。\r\n- type：图标的图片类型。\r\n\r\n需要指出的是，我一直提的“开屏图”其实是背景颜色+图标的展示模式（并不会设置一张所谓的开屏图）。`background_color`是在应用的样式资源为加载完毕前的默认背景，因此会展示在开屏界面。`background_color`加上我们刚才定义的`icons`就组成了Web App打开时的“开屏图”。\r\n\r\n### 2.6. theme_color\r\n定义应用程序的默认主题颜色。 这有时会影响操作系统显示应用程序的方式（例如，在Android的任务切换器上，主题颜色包围应用程序）。此外，还可以在meta标签中设置theme_color：`<meta name=\"theme-color\" content=\"#5eace0\"/>`\r\n\r\n### 2.7. description\r\n这个字段的含义非常简单，就是一段对该应用的描述。\r\n\r\n## 3. 使用Manifest\r\n创建好manifest文件后，下一步就是需要知道如何能让我们的Web App使用它——非常简单，只需要在head中添加一个link标签：\r\n```html\r\n<!-- 在index.html中添加以下meta标签 -->\r\n<link rel=\"manifest\" href=\"/manifest.json\">\r\n```\r\n这样，在android上我们使用chrome将应用添加到桌面，就会拥有文章开头处的PWA效果。你可在这里验证manifest.json的内容：[Web Manifest Validator](https://manifest-validator.appspot.com/)\r\n\r\n如果你看到这里，那么恭喜你，已经知道如何让我们的Web App看起来更像一个独立的Native App。是不是非常简单？\r\n\r\n## 4. iOS, Windows?\r\n上面的一切看似美好，然而真的如此么？\r\n\r\n到目前为止，我们的工作都非常顺利：创建manifest.json，添加meta标签，然后把我们的Web App添加到桌面。然而，如果我们在iPhone上访问我们的站点，然后“添加到主屏幕”，你会发现——一切都失效了！是的，你没有看错，一切都回到了原样。\r\n\r\n![manifest的兼容性](https://user-gold-cdn.xitu.io/2018/4/7/1629fd2a52bb59a0?w=1240&h=476&f=png&s=131349)\r\n\r\n如果你看过[caniuse](https://caniuse.com/#search=manifest)上manifest的兼容性，那会令你更加头疼。但是，也不必太过忧伤，在iOS与windows上，我们有其他的方式\r\n\r\n## 5. iOS（safari）中的处理方式\r\nsafari虽然不支持Web App Manifest，但是它有自己的一些head标签来定义相应的资源与展示形式：\r\n\r\n- `apple-touch-icon`：桌面图标，通过在head中添加`<link rel=\"apple-touch-icon\" href=\"your_icon.png\">`即可。其中还可以添加sizes属性，来指示系统使用在各类平台（iphone、ipad…）中使用最合适的图标\r\n- `apple-mobile-web-app-title`：应用的标题。注意，这里需要使用meta标签`<meta name=\"apple-mobile-web-app-title\" content=\"AppTitle\">`\r\n- `apple-mobile-web-app-capable`：类似于manifest中的display的功能，通过设置为yes可以进入standalone模式，同样也是meta标签`<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">`\r\n- `apple-mobile-web-app-status-bar-style`：这会改变iOS移动设备的状态栏的样式，并且只有在standalone模式中才会有效果。`<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">`，不过在iPhoneX上black会导致状态栏不显示任何东西。\r\n\r\n下面是learning-pwa项目中的相关设置\r\n```html\r\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\r\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"default\">\r\n<meta name=\"apple-mobile-web-app-title\" content=\"图书搜索\">\r\n<link rel=\"apple-touch-icon\" href=\"img/icons/book-256.png\">\r\n```\r\n## 6. IE中的处理方式\r\n与Safari类似，IE中也有自己的meta标签来指示相应的资源。其中比较重要的有：\r\n- `application-name`：指明了app的名称\r\n- `msapplication-TileColor`：指明了“tile”的背景颜色\r\n- `msapplication-xxxlogo`：不同大小的“tile”所使用的图标，包括这几种：`msapplication-square70x70logo, msapplication-square150x150logo, msapplication-wide310x150logo, msapplication-square310x310logo`\r\n\r\n下面是learning-pwa项目中的相关设置，其中图标的设置为了方便就复用了已有的图标文件\r\n```html\r\n<meta name=\"application-name\" content=\"图书搜索\" />\r\n<meta name=\"msapplication-TileColor\" content=\"#222\">\r\n<meta name=\"msapplication-square70x70logo\" content=\"img/icons/book-72.png\" />\r\n<meta name=\"msapplication-square150x150logo\" content=\"img/icons/book-144.png\" />\r\n<meta name=\"msapplication-square310x310logo\" content=\"img/icons/book-256.png\" />\r\n```\r\n\r\n## 写在最后\r\n本文主要探索如何让被添加到桌面的Web App具有更贴近Native App的使用体验（桌面图标、开屏页、shell…）。\r\n\r\n因此，我们使用了Web App Manifest。通过我们添加manifest文件，并在HTML中设置相应的meta标签来使用它即可；而在safari与ie中，可以通过一些特有的meta、link标签来实现。是不是很简单，很方便？这就使得我们能够以很低成本的改动我们Web App。这也就是PWA概念的理念之一：你可以渐进式地提高Web App的能力，同时在兼容性上，也会根据不同的浏览器的支持度提供渐进增强的能力。\r\n\r\n好了，这篇文章的内容就到这里了。\r\n\r\n## 参考资料\r\n- [Web App Manifest（MDN）](https://developer.mozilla.org/zh-CN/docs/Web/Manifest)\r\n- [Configuring Web Applications（Safari）](https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html)\r\n- [Pinned site enhancements （Internet Explorer）](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/dev-guides/bg183312(v=vs.85))\r\n- [caniuse manifest](https://caniuse.com/#search=manifest)\r\n- [Web Manifest Validator](https://manifest-validator.appspot.com/)\r\n- [Address Bar Matches Brand Colors](https://developers.google.com/web/tools/lighthouse/audits/address-bar)\r\n- [demo代码地址：learning-pwa/tree/manifest](https://github.com/alienzhou/learning-pwa/tree/manifest)\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/2","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/2/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/2/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/2/events","html_url":"https://github.com/alienzhou/blog/issues/2","id":390505889,"node_id":"MDU6SXNzdWUzOTA1MDU4ODk=","number":2,"title":"【PWA学习与实践】(1) 2018，开始你的PWA学习之旅","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845017,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE3","url":"https://api.github.com/repos/alienzhou/blog/labels/PWA","name":"PWA","color":"008672","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T03:45:14Z","updated_at":"2018-12-13T03:46:03Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"> 《PWA学习与实践》系列文章已整理至[gitbook - PWA学习手册](https://alienzhou.gitbook.io/learning-pwa/)，文字内容已同步至[learning-pwa-ebook](https://github.com/alienzhou/learning-pwa-ebook)。转载请注明作者与出处。\r\n\r\nPWA作为今年最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。\r\n\r\n本系列文章《PWA学习与实践》会逐步拆解PWA背后的各项技术，通过实例代码来讲解这些技术的应用方式。也正是因为PWA中技术点众多、知识细碎，因此我在学习过程中，进行了整理，并产出了《PWA学习与实践》系列文章，希望能带大家全面了解PWA中的各项技术。对PWA感兴趣的朋友欢迎关注。\r\n\r\n首先简单了解一下PWA。\r\n\r\n## 1. 什么是PWA\r\n\r\n> PWA，即Progressive Web App, 是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。\r\n\r\n我们需要理解的是，PWA不是某一项技术，或者某一个新的产物；而是一系列Web技术与标准的集合与应用。通过应用这些新的技术与标准，可以从安全、性能和体验三个方面，优化我们的Web App。所以，其实PWA本质上依然是一个Web App。\r\n\r\n因此，学习PWA其实就是了解与掌握这些PWA背后的技术。本系列文章会针对PWA中所涉及到的技术进行介绍，并配合代码实例来展示各类技术的使用方式。希望通过这一系列文章，让大家对PWA技术有一个更深入的认识。而PWA本身渐进式的思想也可以让我们在业务中“渐进式”地使用这些技术，在成本可控的前提下，不断优化我们的产品。\r\n\r\n## 2. PWA中的一些技术\r\nPWA本身其实是一个概念集合，它不是指某一项技术，而是通过一系列的Web技术与Web标准来优化Web App的安全、性能和体验。其中涉及到的一些技术概念包括了：\r\n\r\n- Web App Manifest\r\n- Service Worker\r\n- Cache API 缓存\r\n- Push&Notification 推送与通知\r\n- Background Sync 后台同步\r\n- 响应式设计\r\n- ……\r\n\r\n这些技术都是你在学习PWA中不可或缺的。而随着[apple在iOS Safari中也开始支持PWA]((https://medium.com/@firt/progressive-web-apps-on-ios-are-here-d00430dee3a7))（其中的某些技术），PWA的舞台更大了。\r\n\r\n## 3. 项目DEMO\r\n为了配合PWA中相关知识的学习，我专门创建了一个demo Web App——\r\n\r\n一个根据关键字查询图书信息的demo（https://github.com/alienzhou/learning-pwa）。\r\n\r\n这个Web App最开始是不具备任何PWA的能力。我会在这一系列文章中以这个demo为例，阐述各项技术的同时，将其应用在demo上。也就是说，在这一系列的文章中，我会和大家一起将一个普通的网页应用逐步升级为一个简单的PWA，通过这种方式一起学习。\r\n\r\n首先简单介绍一下这个demo。这是一个根据关键词搜索图书信息的应用，用户在前端输入关键词，点击搜索，会请求我们自己的服务器，而服务器使用[豆瓣图书API V2](https://developers.douban.com/wiki/?title=book_v2)来获取数据。\r\n\r\n![图书搜索demo](https://user-gold-cdn.xitu.io/2018/4/7/1629fca5313ecb88?w=1238&h=590&f=jpeg&s=30210)\r\n\r\n项目使用[Koa](http://koajs.com/)来搭建node服务器，所以需要node版本>7.6.0，可以使用[nvm](https://github.com/creationix/nvm)来切换到适合的node版本。\r\n\r\n要运行该项目，首先\r\n```bash\r\ngit clone git@github.com:alienzhou/learning-pwa.git\r\n# 切换到基础项目分支\r\ngit checkout basic\r\n```\r\n注意，需要切换到basic分支，master分支是上经过PWA升级后最新的demo代码。只有在basic分支才能看到原始的Web App。接下来，安装依赖：\r\n```\r\nnpm install\r\n```\r\n最后，运行项目：\r\n```\r\nnpm run start\r\n```\r\n然后就可以在`127.0.0.1:8085`上访问到该项目。\r\n\r\n基础demo的代码比较简单，这里就不去赘述demo中的代码细节了。简单了解一下项目结构，前端代码都存放于`public`目录中，具体结构如下：\r\n```\r\n|---public---|---index.html // 前端页面\r\n|            |---index.js // browser的JavaScript脚本\r\n|            |---style.css // 样式文件\r\n|            |---img // 图片文件夹\r\n|---app.js // node服务启动入口\r\n|---util.js // node服务工具库\r\n```\r\n\r\n值得一提的是，后续文章内的代码会以分支的形式存在，每篇文章的最终代码会存放于一个对应的分支中。你可以通过方便得切换分支，来查看每篇文章对应的示例代码。\r\n\r\n- basic分支：基础项目demo，一个普通的图书搜索应用（网站）；\r\n- manifest分支：基于basic分支，添加manifest等功能；\r\n- sw-cache分支：基于manifest分支，添加缓存与离线功能；\r\n- master分支：应用的最新代码。\r\n- ……\r\n\r\n作为本系列的第一篇文章，本文简单介绍了PWA与其相关的技术概念。通过学习PWA，我们可以很快将其中的优秀技术应用到我们的工作里。在下一篇文章中，我就会介绍如何使用manifest来让你的Web App“更Native”，拥有一个App Shell。想了解PWA更多的后续知识，关注《PWA学习与实践》系列文章。\r\n\r\n话不多说，下面就让我们来具体地学习PWA相关技术吧！","performed_via_github_app":null},{"url":"https://api.github.com/repos/alienzhou/blog/issues/1","repository_url":"https://api.github.com/repos/alienzhou/blog","labels_url":"https://api.github.com/repos/alienzhou/blog/issues/1/labels{/name}","comments_url":"https://api.github.com/repos/alienzhou/blog/issues/1/comments","events_url":"https://api.github.com/repos/alienzhou/blog/issues/1/events","html_url":"https://github.com/alienzhou/blog/issues/1","id":390504563,"node_id":"MDU6SXNzdWUzOTA1MDQ1NjM=","number":1,"title":"(S)CSS中实现主题样式的4½种方式 [译]","user":{"login":"alienzhou","id":9822789,"node_id":"MDQ6VXNlcjk4MjI3ODk=","avatar_url":"https://avatars.githubusercontent.com/u/9822789?v=4","gravatar_id":"","url":"https://api.github.com/users/alienzhou","html_url":"https://github.com/alienzhou","followers_url":"https://api.github.com/users/alienzhou/followers","following_url":"https://api.github.com/users/alienzhou/following{/other_user}","gists_url":"https://api.github.com/users/alienzhou/gists{/gist_id}","starred_url":"https://api.github.com/users/alienzhou/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alienzhou/subscriptions","organizations_url":"https://api.github.com/users/alienzhou/orgs","repos_url":"https://api.github.com/users/alienzhou/repos","events_url":"https://api.github.com/users/alienzhou/events{/privacy}","received_events_url":"https://api.github.com/users/alienzhou/received_events","type":"User","site_admin":false},"labels":[{"id":1159845018,"node_id":"MDU6TGFiZWwxMTU5ODQ1MDE4","url":"https://api.github.com/repos/alienzhou/blog/labels/CSS","name":"CSS","color":"7057ff","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2018-12-13T03:38:10Z","updated_at":"2018-12-13T03:41:45Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"原Slides: [4½ Methods for Theming in (S)CSS](https://speakerdeck.com/csswizardry/4half-methods-for-theming-in-s-css)\r\n作者: Harry Roberts\r\n\r\n> PM说要实现一个一键设置主题的功能，作为技术，你能想到的实现方式有哪些呢？\r\n\r\n## 1. 什么是主题样式？\r\n\r\n相信大家对网页的主题样式功能肯定不陌生。对于一些站点，在基础样式上，开发者还会为用户提供多种主题样式以供选择。\r\n\r\n下面就是一个主题样式功能：用户可以在右侧选择自己喜欢的主题色，从而得到一个“个性”的页面。\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/12/12/1679e2f8c6f75eea?w=1918&h=1038&f=png&s=199638)\r\n\r\n还有时候，我们开发了一个系统用来售卖，采购我们系统的客户可能有多个。也许其中一个客户很喜欢我们当前的深色色系主题，但是另一个系统的采购方希望我们能为它们定制一套新的样式。他们希望买来的系统能贴合它们自己的品牌调性，变为浅色的。这其实也是一种主题样式的需求。\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/12/12/1679e2fac347b63b?w=1920&h=1200&f=png&s=373192)\r\n\r\n\r\n在上面的讨论里，除了“主题”外，我们又引出了一个概念——个性化。经常，我们说到主题时，还会有一种说法叫做：个性化主题。这两者在英文中分别有两个对应的词： Theming 与 Customisation。\r\n\r\n当我们说主题（Theming）与个性化定制（Customisation）的时候，很多时候其实并没有区分两者。但实际上，两者还是有一些微妙的区别的。\r\n\r\n### 1.1. 主题 Theming 与个性化定制 Customisation 的区别\r\n\r\n我们说的主题（Theming）与个性化定制（Customisation）的时候，还是有一些微妙的区别的。\r\n\r\n\r\n#### 主题：由开发者定义\r\n\r\n主要表现在：\r\n\r\n- 系统的输入是由开发者定义的\r\n- 一般来说具有有限的种类\r\n- 具有已知的规则与常量\r\n\r\n例如，我们常见的一些应用会提供夜间主题、阅读模式，这些也算是主题（Theming）的范畴。\r\n\r\n\r\n#### 个性化定制：由用户定义\r\n\r\n特点表现在：\r\n\r\n- 系统的输入是由用户来提供\r\n- 一般具有无限种可能\r\n- 规则更灵活，用户“为所欲为”\r\n\r\n\r\n可以看到，“个性化”其实更强调了用户对系统的的影响力。\r\n\r\n很多时候，我们谈到“主题”与“个性化定制”时，也许并没有一个明确的边界。从上面的描述也可以看出，两者似乎是处于天平的两端，区别主要在于开发者对规则的控制力度以及所能实现的差异化的粒度。\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/12/12/1679e2fd21633517?w=1678&h=1006&f=png&s=515617)\r\n\r\n而我们更多的是在两点之间找到一个平衡点。\r\n\r\n### 1.2. 对实现“主题功能”的建议\r\n\r\n我们已经对主题样式有了初步的了解，如果你也在产品中遇到了主题样式的相关需求，不妨先看看以下几点建议：\r\n\r\n1. 尽可能避免这个功能。因为很多时候这可能只是个伪需求。\r\n2. KISS原则（Keep It Simple, Stupid!）。尽可能降低其复杂性。\r\n3. 尽量只去改变外观，而不要改动元素盒模型（box-model）。\r\n4. 严格控制你的规则，避免预期外的差异。\r\n5. 把它作为一个锦上添花的功能来向上促销（up-sell）。\r\n\r\n## 2. 实现“主题样式”的方式\r\n\r\n### 2.1. 方式一：Theme Layer\r\n\r\n> Overriding default style with additional CSS.\r\n\r\n这应该是实现主题功能的一种最常用的手段了。首先，我们的站点会有一个最初的基础样式（或者叫默认样式）；然后通过添加一些后续的额外的CSS来覆盖与重新定义部分样式。\r\n\r\n#### 具体实现\r\n\r\n首先，我们引入基础的样式 `components.*` 文件\r\n\r\n```scss\r\n@import \"components.tabs\";\r\n@import \"components.buttons\"\r\n```\r\n\r\n其中 `components.tabs` 文件内容如下\r\n\r\n```scss\r\n.tab {\r\n    margin: 0;\r\n    padding: 0;\r\n    background-color: gray;\r\n}\r\n```\r\n\r\n然后，假设我们的某个主题的样式文件存放于 `theme.*` 文件：\r\n\r\n对应于 `components.tabs`，`theme.tabs` 文件内容如下\r\n\r\n```scss\r\n.tab {\r\n    background-color: red;\r\n}\r\n```\r\n\r\n因此，我们只需要引入主题样式文件即可\r\n\r\n```css\r\n@import \"components.tabs\";\r\n@import \"components.buttons\"\r\n\r\n@import \"theme.tabs\";\r\n```\r\n\r\n这样当前的样式就变为了\r\n\r\n```scss\r\n.tab {\r\n    margin: 0;\r\n    padding: 0;\r\n    /* background-color: gray; */\r\n    background-color: red;\r\n}\r\n```\r\n\r\n#### 优点\r\n\r\n- 实现方式简单\r\n- 可以实现将主题应用与所有元素\r\n\r\n#### 缺点\r\n\r\n- 过多的冗余代码\r\n- 许多的CSS其实是无用的，浪费了带宽\r\n- 把样式文件切分到许多文件中，更加琐碎\r\n\r\n---\r\n\r\n### 2.2. 方式二：Stateful Theming\r\n\r\n> Styling a UI based on a state or condition.\r\n\r\n该方式可以实现基于条件选择不同的主题皮肤，并允许用户在客户端随时切换主题。非常适合需要客户端样式切换功能，或者需要对站点某一部分（区域）进行独立样式设置的场景。\r\n\r\n#### 具体实现\r\n\r\n还是类似上一节中 Tab 的这个例子，我们可以将 Tab 部分的 (S)CSS 改为如下形式：\r\n\r\n```scss\r\n.tab {\r\n    background-color: gray;\r\n    \r\n    .t-red & {\r\n        background-color: red;\r\n    }\r\n    \r\n    .t-blue & {\r\n        background-color: blue;\r\n    }\r\n}\r\n```\r\n\r\n这里我们把`.t-red`与`.t-blue`称为 Tab 元素的上下文环境（context）。Tab 元素会根据 context 的不同展示出不同的样式。\r\n\r\n最后我们给`body`元素加上这个开关\r\n\r\n```html\r\n<body class=\"t-red\">\r\n    <ul class=\"tabs\">...</ul>\r\n</body>\r\n```\r\n\r\n此时 Tab 的颜色为红色。\r\n\r\n当我们将`t-red`改为`t-blue`时，Tab 就变为了蓝色主题。\r\n\r\n进一步的，我们可以创建一些 (S)CSS 的 util class（工具类）来专门控制一些 CSS 属性，帮助我们更好地控制主题。例如我们使用如下的`.u-color-current`类来控制不同主题下的字体颜色\r\n\r\n```scss\r\n.u-color-current {\r\n    .t-red & {\r\n        color: red;\r\n    }\r\n    \r\n    .t-blue & {\r\n        color: blue;\r\n    }\r\n}\r\n```\r\n\r\n这样，当我们在不同主题上下文环境下使用`.u-color-current`时，就可以控制元素展示出不同主题的字体颜色\r\n\r\n```html\r\n<body class=\"t-red\">\r\n    <h1 class=\"page-title u-color-current\">...</h1>\r\n</body>\r\n```\r\n\r\n上面这段代码会控制`<h1>`元素字体颜色为红色主题时的颜色。\r\n\r\n#### 优点\r\n\r\n- 将许多主题放在了同一处代码中\r\n- 非常适合主题切换的功能\r\n- 非常适合站点局部的主题化\r\n- 可以实现将主题应用于所有元素\r\n\r\n#### 缺点\r\n\r\n- 有时有点也是缺点，将许多主题混杂在了同一块代码中\r\n- 可能会存在冗余\r\n\r\n---\r\n\r\n### 2.3. 方式三：Config Theming\r\n\r\n> Invoking a theme based on settings.\r\n\r\n这种方式其实是在开发侧来实现主题样式的区分与切换的。基于不同的配置，配合一些开发的自动化工具，我们可以在开发时期根据配置文件，编译生成不同主题的 CSS 文件。\r\n\r\n它一般会结合使用一些 CSS 预处理器，可以对不同的 UI 元素进行主题分离，并且向客户端直接提供主题样式下最终的 CSS。\r\n\r\n#### 具体实现\r\n\r\n我们还是以 Sass 为例：\r\n\r\n首先会有一份 Sass 的配置文件，例如`settings.config.scss`，在这份配置中定义当前的主题值以及一些其他变量\r\n\r\n```scss\r\n$theme: red;\r\n```\r\n\r\n然后对于一个 Tab 组件，我们这么来写它的 Sass 文件\r\n\r\n```scss\r\n.tab {\r\n    margin: 0;\r\n    padding: 0;\r\n    \r\n    @if ($theme == red) {\r\n        background-color: red;\r\n    } @else {\r\n        background-color: gray;\r\n    }\r\n}\r\n```\r\n\r\n这时，我们在其之前引入相应的配置文件后\r\n\r\n```scss\r\n@import \"settings.config\";\r\n@import \"components.tabs\";\r\n```\r\n\r\nTab 组件就会呈现出红色主题。\r\n\r\n当然，我们也可以把我们的`settings.config.scss`做的更健壮与易扩展一些\r\n\r\n```scss\r\n$config: (\r\n    theme: red,\r\n    env: dev,\r\n)\r\n\r\n// 从$config中获取相应的配置变量\r\n@function config($key) {\r\n    @return map-get($config, $key);\r\n}\r\n```\r\n\r\n与之前相比，这时候使用起来只需要进行一些小的修改，将直接使用`theme`变量改为调用`config`方法\r\n\r\n```scss\r\n.tab {\r\n    margin: 0;\r\n    padding: 0;\r\n    \r\n    @if (config(theme) == red) {\r\n        background-color: red;\r\n    } @else {\r\n        background-color: gray;\r\n    }\r\n}\r\n```\r\n\r\n#### 优点\r\n\r\n- 访问网站时，只会传输所需的 CSS，节省带宽\r\n- 将主题的控制位置放在了一个地方（例如上例中的`settings.config.scss`文件）\r\n- 可以实现将主题应用于所有元素\r\n\r\n#### 缺点\r\n\r\n- 在 Sass 中会有非常多逻辑代码\r\n- 只支持有限数量的主题\r\n- 主题相关的信息会遍布代码库中\r\n- 添加一个新主题会非常费劲\r\n\r\n---\r\n\r\n### 2.4. 方式四：Theme Palettes\r\n\r\n> Holding entire themes in a palette file.\r\n\r\n这种方式有些类似于我们绘图时，预设了一个调色板（palette），然后使用的颜色都从其中取出一样。\r\n\r\n在实现主题功能时，我们也会有一个类似的“调色板”，其中定义了主题所需要的各种属性值，之后再将这些信息注入到项目中。\r\n\r\n当你经常需要为客户端提供完全的定制化主题，并且经常希望更新或添加主题时，这种模式会是一个不错的选择。\r\n\r\n#### 具体实现\r\n\r\n在方式三中，我们在一个独立的配置文件中设置了一些“环境”变量，来标示当前所处的主题。而在方式四中，我们会更进一步，抽取出一个专门的 palette 文件，用于存放不同主题的变量信息。\r\n\r\n例如，现在我们有一个`settings.palette.red.scss`文件\r\n\r\n```scss\r\n$color: red;\r\n$color-tabs-background: $color-red;\r\n```\r\n\r\n然后我们的`components.tabs.scss`文件内容如下\r\n\r\n```css\r\n.tabs {\r\n    margin: 0;\r\n    padding: 0;\r\n    backgroung-color: $color-tabs-background;\r\n}\r\n```\r\n\r\n这时候，我们只需要引入这两个文件即可\r\n\r\n```css\r\n@import \"settings.palette.red\";\r\n@import \"components.tabs\";\r\n```\r\n\r\n可以看到，`components.tabs.scss`中并没有关于主题的逻辑判断，我们只需要专注于编辑样式，剩下就是选择所需的主题调色板（palette）即可。\r\n\r\n#### 优点\r\n\r\n- 编译出来的样式代码无冗余\r\n- 非常适合做一些定制化主题，例如一个公司采购了你们的系统，你可以很方便实现一个该公司的主题\r\n- 可以从一个文件中完全重制出你需要的主题样式\r\n\r\n#### 缺点\r\n\r\n- 由于主要通过设定不同变量，所以代码确定后，能实现的修改范围会是有限的\r\n\r\n---\r\n\r\n### 2.5. 方式五：用户定制化 User Customisation\r\n\r\n> Letting users style their own UIs.\r\n\r\n这种模式一般会提供一个个性化配置与管理界面，让用户能自己定义页面的展示样式。\r\n\r\n“用户定制化”在社交媒体产品、SaaS 平台或者是 Brandable Software 中最为常见。\r\n\r\n#### 具体实现\r\n\r\n要实现定制化，可以结合方式二中提到的 util class。\r\n\r\n首先，页面中支持自定义的元素会被预先添加 util class，例如 Tab 元素中的`u-user-color-background`\r\n\r\n```html\r\n<ul class=\"tabs u-user-color-background\">...</ul>\r\n```\r\n\r\n此时，`u-user-color-background`还并未定义任何样式。而当用户输入了一个背景色时，我们会创建一个`<style>`标签，并将 hex 值注入其中\r\n\r\n```html\r\n<style id=\"my-custom\">\r\n    .u-user-color-background {\r\n        background-color: #00ffff;\r\n    }\r\n</style>\r\n```\r\n\r\n这时用户就得到了一个红色的 Tab。\r\n\r\nTwitter 就是使用这种方式来实现用户定制化的界面样式的：\r\n\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/12/12/1679e300d854a05e?w=1353&h=749&f=png&s=377033)\r\n\r\n#### 优点\r\n\r\n- 不需要开发人员的输入信息（是用户定义的）\r\n- 允许用户拥有自己“独一无二”的站点\r\n- 非常实用\r\n\r\n#### 缺点\r\n\r\n- 不需要开发人员的输入信息也意味着你需要处理更多的“不可控”情况\r\n- 会有许多的冗余\r\n- 会浪费 CSS 的带宽\r\n- 失去部分 CSS 的浏览器缓存能力\r\n\r\n---\r\n\r\n## 3. 如何选择方案？\r\n\r\n最后来聊聊方案的选择。\r\n\r\n在第二部分我们已经了解了五种实现方式（或者说4½种方法，因为第五种其实更偏个性化定制一些），那么面对产品需求，我们应该如何选择呢？\r\n\r\n这里有一个不是非常严谨的方式可以参考。你可以通过尝试问自己下面这几个问题来做出决定：\r\n\r\n- **是你还是用户谁来确定样式？**\r\n用户：选择【方式五】User Customisation\r\n\r\n- **主题是否会在客户端中被切换？**\r\n是：选择【方式二】Stateful Theming 或【方式五】User Customisation\r\n\r\n- **是否有主题能让用户切换？**\r\n是：选择【方式二】Stateful Theming\r\n\r\n- **你是希望网站的某些部分需要有不同么？**\r\n是：选择【方式二】Stateful Theming\r\n\r\n- **是否有预设的主题让客户端来选择？**\r\n是：选择【方式三】Config Theming\r\n\r\n- **是否是类似“贴牌”这类场景？**\r\n是：选择【方式一】Theme Layer 或【方式四】Theme Palettes\r\n\r\n\r\n","performed_via_github_app":null}]